<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fancy options parsing - Learning Haskell by building a blog generator</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A step by step guide to learning Haskell by building a simple static blog generator">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-about.html"><strong aria-hidden="true">1.</strong> About this tutorial</a></li><li class="chapter-item expanded "><a href="../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible html content (functions)</a></li><li class="chapter-item expanded "><a href="../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="../03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="../03-html/09-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../03-html/10-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="../04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (typeclasses)</a></li><li class="chapter-item expanded "><a href="../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="../05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="../05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="../05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="../05-glue/04-optparse.html" class="active"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="../06-next.html"><strong aria-hidden="true">6.</strong> Where to go next?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Learning Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fancy-options-parsing"><a class="header" href="#fancy-options-parsing">Fancy options parsing</a></h1>
<p>We'd like to define a nicer interface for our program. And while we could manage something
ourselves with <code>getArgs</code> and pattern matching, using a library for this case is easier.
We are going to use a package called
<a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>.</p>
<p><code>optparse-applicative</code> provides us with an EDSL (yes, another one) to build
command arguments parser. Things like commands, switches, and flags can be built
and composed together to make a parser for command-line arguments without actually
writing operations on strings as we did when we wrote our Markup parser, and will
provide other benefits such as automatic generation of usage lines, help screens,
error reporting, and more.</p>
<p>While <code>optparse-applicative</code>'s dependency footprint isn't very large,
it is likely that a user of our library wouldn't need command-line parsing
in this particular case, so it makes sense to add this dependency on the <code>executable</code>
rather than the <code>library</code> in the cabal file:</p>
<pre><code class="language-cabal">executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , optparse-applicative
    , hs-blog
  ghc-options:
    -O
</code></pre>
<h2 id="building-a-command-line-parser"><a class="header" href="#building-a-command-line-parser">Building a command-line parser</a></h2>
<p>The optparse-applicative package has pretty decent
<a href="https://hackage.haskell.org/package/optparse-applicative-0.16.1.0#optparse-applicative">documentation</a>,
but we will cover a few important things to pay attention to in this chapter.</p>
<p>In general, there are four important things we need to do:</p>
<ol>
<li>
<p>Define our model - we want to define an ADT that describes the various options
and commands for our program.</p>
</li>
<li>
<p>Define a parser that will produce our model when run</p>
</li>
<li>
<p>Run the parser on our program arguments input</p>
</li>
<li>
<p>Pattern match on the model and call the right operations according to the options</p>
</li>
</ol>
<h3 id="define-a-model"><a class="header" href="#define-a-model">Define a model</a></h3>
<p>Let's envision our command-line interface for a second, what would we like it to
look like?</p>
<p>We want to be able to convert a single file or input stream and produce either a file
or an input stream, or we want to process a whole directory and create a new directory.
We can model it in an ADT like this:</p>
<pre><code class="language-hs">data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show
</code></pre>
<blockquote>
<p>Note that we could technically also use <code>Maybe FilePath</code> to encode both <code>SingleInput</code>
and <code>SingleOutput</code>, but then we would have to remember what <code>Nothing</code> meant
in each context. By creating a new type with properly named constructors
for each option we make it easier for readers of the code to understand
the meaning of our code.</p>
</blockquote>
<p>In terms of interface, we could decide that when a user uses our program
without arguments, they would like to read from stdin and write to stdout.
If they'd like to read from or write to a file, they can use the optional flags
<code>--input FILEPATH</code> and <code>--output FILEPATH</code> respectively.</p>
<p>If the user would like to convert a directory, they can use the <code>directory</code>
command and supply the two mandatory flags <code>--input FILEPATH</code> and
<code>--output FILEPATH</code>.</p>
<p>Feel free to change the interface as you'd like!</p>
<h3 id="build-a-parser"><a class="header" href="#build-a-parser">Build a parser</a></h3>
<p>This is the most interesting part of the process. How do we build a parser
that fit our model? What is a parser even?</p>
<p>The <code>optparse-applicative</code> library introduces a new type called <code>Parser</code>.
<code>Parser</code>, similar to <code>Maybe</code> and <code>IO</code>, has the kind <code>* -&gt; *</code> - when it
is supplied with a saturated (or concrete) type such as <code>Int</code>, <code>Bool</code> or
<code>Options</code>, it can become a saturated type (one that has values).</p>
<p>A <code>Parser a</code> represents a specification of a parser for a set of options
that will produce a value of type <code>a</code> when the command-line arguments are
successfully parsed.
This is a bit similar to how <code>IO a</code> represents a description of a program
that can produce a value of type <code>a</code>. The main difference between these
two types is that while we can't really convert an <code>IO a</code> to an <code>a</code>
(we just chain IO operations and have the Haskell runtime execute them),
we <em>can</em> convert a <code>Parser a</code> to a function that takes a list of strings
representing the program arguments and produces an <code>a</code> if it manages
to parse the arguments.</p>
<p>As we've seen with previous EDSLs, this library uses the <em>combinator pattern</em>
as well. We need consider what are the basic primitives for building
a parser, and what are the methods of composing small parsers into bigger
parsers.</p>
<p>Let's see an example for a small parser:</p>
<pre><code class="language-hs">inp :: Parser FilePath
inp =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;FILENAME&quot;
      &lt;&gt; help &quot;Input file&quot;
    )

out :: Parser FilePath
out =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;FILENAME&quot;
      &lt;&gt; help &quot;Output file&quot;
    )
</code></pre>
<p><code>strOption</code> is a parser builder. It is a function that takes <em>option
modifiers</em> as an argument, and returns a parser that will parse a string.
We can specify the type to be <code>FilePath</code> because <code>FilePath</code> is an
alias to <code>String</code>. The parser builder describes how to part the data type,
and the modifiers describe its properties, such as the flag name,
the shorthand of the flag name, and how it would be described in the usage
and help messages.</p>
<blockquote>
<p>Actually <code>strOption</code> can return any string type
that implements the interface <code>IsString</code>. There are a few such types,
such as <code>Text</code>, a much more efficient unicode text type from the <code>text</code> package.
It is more efficient than <code>String</code> because while <code>String</code> is implemented as a
linked list of <code>Char</code>, <code>Text</code> is implemented as an array of bytes.
<code>Text</code> is usually what we should use for text values. We haven't
been using it up until now because it is slightly less ergonomic to use
than <code>String</code>. But it is often the preferred type to use for text!</p>
</blockquote>
<p>As you can see, modifiers can be composed using the <code>&lt;&gt;</code> function,
which means they are an instances of <code>Semigroup</code>!</p>
<p>With such interface it means that we don't have to supply all of the modifier
options, we can just use the one that are relevant. So if we don't want to
have a shortend flag name, we don't have to add it.</p>
<h4 id="functor"><a class="header" href="#functor">Functor</a></h4>
<p>For the data type we've defined, having <code>Parser FilePath</code> takes us
a good step in the right direction, but it is not exactly what we need
for a <code>SingleConvert</code>. We need a <code>Parser SingleInput</code> and a
<code>Parser SingleOutput</code>. If we had a <code>FilePath</code>, we could convert
it into <code>SingleInput</code> by using the <code>FileInput</code> constructor.
Remember, <code>FileInput</code> is also a function:</p>
<pre><code class="language-hs">FileInput :: FilePath -&gt; SingleInput
FileOutput :: FilePath -&gt; SingleOutput
</code></pre>
<p>However, to convert a parser, we need functions with these types:</p>
<pre><code class="language-hs">f :: Parser FilePath -&gt; Parser SingleInput
g :: Parser FilePath -&gt; Parser SingleOutput
</code></pre>
<p>Fortunately, the <code>Parser</code> interface provides us with a function to &quot;lift&quot;
a function like <code>FilePath -&gt; SingleInput</code> to work on parsers, making
it a function with the type <code>Parser FilePath -&gt; Parser SingleInput</code>.
Of course, this function will work for any input and output,
so if we have a function with the type <code>a -&gt; b</code>, we can pass it to
that function and get a new function of the type <code>Parser a -&gt; Parser b</code>.</p>
<p>This function is called <code>fmap</code>:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b

-- Or with its infix version
&lt;$&gt;  :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
</code></pre>
<p>We've seen <code>fmap</code> before in the interface of other types:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]

fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>fmap</code> is a type class function like <code>&lt;&gt;</code> and <code>show</code>, it belongs
to the type class <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor"><code>Functor</code></a>:</p>
<pre><code class="language-hs">class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>And it has the following laws:</p>
<pre><code class="language-hs">-- 1. Identity law:
--    if we don't change the values, nothing should change
fmap id = id

-- 2. Composition law:
--    Composing the lifted functions is the same a composing
--    them after fmap
fmap (f . g) == fmap f . fmap g
</code></pre>
<p>Any type <code>f</code> that can implement <code>fmap</code> and follow these laws can be an
instance of functor.</p>
<blockquote>
<p>Notice how <code>f</code> has a kind <code>* -&gt; *</code>, we can infer the kind of <code>f</code>
by looking at the other types in the type signature of <code>fmap</code>:</p>
<ol>
<li><code>a</code> and <code>b</code> have the kind <code>*</code> because they are used as arguments/return
types of functions</li>
<li><code>f a</code> has the kind <code>*</code> because it is used as an argument to a function, therefore</li>
<li><code>f</code> has the kind <code>* -&gt; *</code></li>
</ol>
</blockquote>
<p>Let's choose a data type and see if we can implement a <code>Functor</code> instance.
We need to choose a data type that has the kind <code>* -&gt; *</code>. <code>Maybe</code> fits the bill.
We need to implement a function <code>fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code>.
Here's one very simple (and wrong) implementation:</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX = Nothing
</code></pre>
<p>check it yourself! It compiles and everything! But unfortunately it does
satisfy the first law. <code>fmap id = id</code> means that
<code>mapMaybe id (Just x) == Just x</code>, however from the definition we can
clearly see that <code>mapMaybe id (Just x) == Nothing</code>.</p>
<p>This is a good example of how Haskell doesn't help us make sure the laws
are satisfied, and why they are important. Unlawful <code>Functor</code> instances
will behave differently than we'd expect a <code>Functor</code> to behave.
Let's try again!</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX =
  case maybeX of
    Nothing -&gt; Nothing
    Just x -&gt; Just (func x)
</code></pre>
<p>This <code>mapMaybe</code> will satisfy the functor laws. This can be proved
by doing algebra - if we can do substitution and reach the other side of the
equation in each law, then the law holds.</p>
<p>Functor is a very important type class, and many types implement this interface.
As we know, <code>IO</code>, <code>Maybe</code>, <code>[]</code> and <code>Parser</code> all have the kind <code>* -&gt; *</code>,
and all allows us to map over their &quot;payload&quot; type.</p>
<p>Often people try to look for analogies and metaphors to what a type class mean,
but type classes with funny names like <code>Functor</code> don't usually have an
analogy or a methapor that fits them so well. It is easier to give up
on the metaphor and think about it as it is - an interface with laws.</p>
<p>We can use <code>fmap</code> on <code>Parser</code> to make a parser that returns <code>FilePath</code>
return a <code>SingleInput</code> or <code>SingleOutput</code> instead:</p>
<pre><code class="language-hs">pInputFile :: Parser SingleInput
pInputFile = fmap FileInput parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

pOutputFile :: Parser SingleOutput
pOutputFile = FileOutput &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Output file&quot;
        )
</code></pre>
<h4 id="applicative"><a class="header" href="#applicative">Applicative</a></h4>
<p>Now that we have two parsers,
<code>ppInputFile :: Parser SingleInput</code>
and <code>pOutputFile :: Parser SingleOutput</code>,
we want to <em>combine</em> them as <code>Options</code>. Again, if we only had
<code>SingleInput</code> and <code>SingleOutput</code>, we could use the constructor <code>ConvertSingle</code>:</p>
<pre><code class="language-hs">ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options
</code></pre>
<p>Can we do a similar trick to the one we saw before with <code>fmap</code>?
Does a function that can lift a binary function to work
on <code>Parser</code>s instead? One with this type signature:</p>
<pre><code>???
  :: (       SingleInput -&gt;        SingleOutput -&gt;        Options)
  -&gt; (Parser SingleInput -&gt; Parser SingleOutput -&gt; Parser Options)
</code></pre>
<p>Yes. This function is called <code>liftA2</code> and it is from the <code>Applicative</code>
type class. <code>Applicative</code> (also known as an applicative functor) has three
primary functions:</p>
<pre><code class="language-hs">class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c 
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative"><code>Applicative</code></a>
is another very popular type class with many instances.</p>
<p>Just like any <code>Monoid</code> as a <code>Semigroup</code>, any <code>Applicative</code>
is a <code>Functor</code>. This means that any type that wants to implement
the <code>Applicative</code> interface should also implement the <code>Functor</code> interface.</p>
<p>Beyond what a regular functor can do, which is to lift a function over
a certain <code>f</code>, applicative functors allow us to apply a function to
multiple instances of a certain <code>f</code>, as well as &quot;lift&quot; any value into an <code>f a</code>.</p>
<p>You should already be familiar with <code>pure</code>, we've seen it when we
talked about <code>IO</code>. For <code>IO</code>, <code>pure</code> let us create an <code>IO</code> action
that would return a specific value without doing IO.
With <code>pure</code> for <code>Parser</code>, we can create a <code>Parser</code> that when run
will return a specific value as output. </p>
<p><code>liftA2</code> and <code>&lt;*&gt;</code> are two functions that can be implemented in
terms of one another. <code>&lt;*&gt;</code> is actually the more useful between
the two, because when combined with <code>fmap</code>, it can be used
to apply a function with many arguments over many values of the
same type which is an instance of an applicative functor.</p>
<p>To combine our two parsers to one, we can use either <code>liftA2</code> or
<code>&lt;*&gt;</code> and <code>fmap</code> (or more specifically the infix version <code>&lt;$&gt;</code>):</p>
<pre><code class="language-hs">-- with liftA2
pConvertSingle :: Parser Options
pConvertSingle =
  liftA2 ConvertSingle pInputFile pOutputFile

-- with &lt;$&gt; and &lt;*&gt;
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pInputFile &lt;*&gt; pOutputFile
</code></pre>
<p>Note that both <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> associate to the left,
so we have invisible parenthesis that look like this:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile
</code></pre>
<p>Let's take a deeper look at the types of the sub-expressions
we have here, to prove that this type-checks:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options

pInputFile :: Parser SingleInput
pOutputFile :: Parser SingleOutput

ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options

&lt;$&gt; :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a` is `SingleInput -&gt; SingleOutput -&gt; Options`
  -- and `b` is `SingleOutput -&gt; Options`,

ConvertSingle &lt;$&gt; pInputFile :: Parser (SingleOutput -&gt; Options)

&lt;*&gt; :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a -&gt; b` is `SingleOutput -&gt; Options`
  -- so `a` is `SingleOutput` and `b` is `Options`

-- So we get:
(ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile :: Parser Options
</code></pre>
<p>With <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> we can chain as many parsers (or any applicative really)
as we want. This is because two things: currying and parametric polymorphism:
Because functions in Haskell take exactly one argument and return exactly one,
any multiple argument function can be represented as <code>a -&gt; b</code>.</p>
<p>You can find the laws for the applicative functors in this article called
<a href="https://wiki.haskell.org/Typeclassopedia#Laws_2">Typeclassopedia</a>, which
talks about various useful type classes and their laws.</p>
<p>Applicatives are a very important concept and will appear in various
parsers interface (not just for command-line arguments, but also json
parsers and general parsers), I/O, concurrency, non-determinism, and more.
The reason this library is called optparse-applicative is because
it uses the <code>Applicative</code> interface as the main API for
constructing parsers.</p>
<hr />
<p>Exercise: create a similar interface for the <code>ConvertDir</code> constructor of <code>Options</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir
</code></pre>
</details>
<hr />
<h4 id="alternative"><a class="header" href="#alternative">Alternative</a></h4>
<p>One thing we forgot about is that each input and output for
<code>ConvertSingle</code> could also potentially use the standard input instead.
Up until now we only offered one option: reading from or writing to a file,
but we'd like to offer the alternative standard i/o. We can do that by using
the function <code>&lt;|&gt;</code> from the <code>Alternative</code> typeclass, which <code>Parser</code> implements:</p>
<pre><code class="language-hs">class Applicative f =&gt; Alternative f where 
  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a
  empty :: f a 
</code></pre>
<p><code>Alternative</code> looks very similar to the <code>Monoid</code> typeclass,
but it works on applicative functors. This type class isn't
very common and is mostly used for parsing libraries,
but it provides us with an interface to combine two <code>Parser</code>s.
If the first one fails to parse, we try the other.</p>
<p>We can create new parsers <code>pStdin</code> and <code>pStdout</code>:</p>
<pre><code class="language-hs">pStdIn :: Parser SingleInput
pStdin =
  flag' Stdin
    ( help &quot;Standard input&quot;
    )

pStdout :: Parser SingleOutput
pStdout =
  flag' Stdout
    ( help &quot;Standard output&quot;
    )
</code></pre>
<p>Create new unifying parsers for <code>SingleInput</code> and <code>SingleOutput</code>:</p>
<pre><code class="language-hs">pSingleInput :: Parser SingleInput
pSingleInput =
  pInputFile &lt;|&gt; pStdin

pSingleOutput :: Parser SingleInput
pSingleOutput =
  pInputFile &lt;|&gt; pStdout
</code></pre>
<p>And use those for <code>pConvertSingle</code> instead:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  ConvertDir &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput
</code></pre>
<p>Our interface is still incomplete, we should still combine
<code>pConvertSingle</code> and <code>pConvertDir</code> and offer them as alternative
options for our interface.</p>
<pre><code class="language-hs">pOptions :: Parser Options
pOptions = pConvertSingle &lt;|&gt; pConvertDir
</code></pre>
<h4 id="parserinfo"><a class="header" href="#parserinfo">ParserInfo</a></h4>
<p>When we finished building a parser, we should wrap it up in a <code>ParserInfo</code>
that adds some extra information to the parser (such as a helper message,
program description, and more depending on what we'd like to add),
and make it ready to run. The optparse-applicative tutorial suggests something like this:</p>
<pre><code class="language-hs">opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )
</code></pre>
<p>Here, <code>info</code> generates a <code>ParserInfo</code> for a parser with additional information
to print, and, <code>helper</code> adds a helper output screen in case the parser fails.</p>
<h3 id="running-a-parser"><a class="header" href="#running-a-parser">Running a parser</a></h3>
<p><code>optparse-applicative</code> provides non-<code>IO</code> interface to parse arguments,
but the most convenient way to use it is to let it take care of fetching
program arguments, try to parse them, and throw errors and help messages in case
it fails. This can be done with the function <code>execParser :: ParserInfo a -&gt; IO a</code>.</p>
<p>Right after <code>main</code> start, we can run a parser and take the result using <code>&lt;-</code>.</p>
<pre><code class="language-hs">main :: IO ()
main = do
  options &lt;- execParser opts
  -- ... rest of the program
</code></pre>
<p>Let's see our program up until now in <code>app/Main.hs</code>:</p>
<pre><code class="language-hs">-- | Entry point for the hs-blog-gen program

module Main where

import Options.Applicative

main :: IO ()
main = do
  options &lt;- execParser opts
  error &quot;not implemented yet&quot;

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

-- | A single input source
data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

-- | A single output sink
data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show

------------------------------------------------
-- * Parser

opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )

-- | Parser for all options
pOptions :: Parser Options
pOptions = pConvertSingle &lt;|&gt; pConvertDir

------------------------------------------------
-- * Single source to sink conversion parser

-- | Parser for single source to sink option
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertDir &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput

-- | Parser for single input source
pSingleInput :: Parser SingleInput
pSingleInput =
  pInputFile &lt;|&gt; pStdin

-- | Parser for single output sink
pSingleOutput :: Parser SingleInput
pSingleOutput =
  pInputFile &lt;|&gt; pStdout

-- | Input file parser
pInputFile :: Parser SingleInput
pInputFile = fmap FileInput parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

-- | Output file parser
pOutputFile :: Parser SingleOutput
pOutputFile = FileOutput &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Output file&quot;
        )

-- | stdin parser
pStdIn :: Parser SingleInput
pStdin =
  flag' Stdin
    ( help &quot;Standard input&quot;
    )

-- | stdout parser
pStdout :: Parser SingleOutput
pStdout =
  flag' Stdout
    ( help &quot;Standard output&quot;
    )

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir

-- | Parser for input directory
pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

-- | Parser for output directory
pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )
</code></pre>
<h3 id="pattern-matching-on-the-command-options"><a class="header" href="#pattern-matching-on-the-command-options">Pattern matching on the command options</a></h3>
<p>After running the command-line arguments parser, we can pattern match
on our model and call the right functions. Currently, our program
does not expose this kind of API. So let's go to our <code>src/HsBlog.hs</code>
module and change the API. We can delete <code>main</code> from that file and
add two functions instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO.html#t:Handle"><code>Handle</code></a>
is an I/O abstraction over file system objects, including <code>stdin</code> and <code>stdout</code>.
Before, we used <code>writeFile</code> and <code>getContents</code> - these functions either
get a <code>FilePath</code> to open and work on, or they assume the <code>Handle</code>.
We can use the explicit versions that take a <code>Handle</code> from <code>System.IO</code> instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)
</code></pre>
<hr />
<p>For <code>convertDirectory</code>, we will need to create the output directory,
get the files in a directory,
do something <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Foldable.html#v:for_">for_</a> each file, and so on.
The API from the
<a href="https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html"><code>directory</code></a> can help us do that. Make sure to add the dependency to the cabal file
in the <code>library</code> section.</p>
<hr />
<p>In <code>app/Main.hs</code>, we will need to pattern match on the <code>Options</code> and
prepare to call the right functions from <code>HsBlog</code>:</p>
<p>Add:</p>
<pre><code class="language-hs">import System.IO
</code></pre>
<p>And:</p>
<pre><code class="language-hs">run :: Options -&gt; IO ()
run options =
  case options of
    ConvertDir input output -&gt;
      convertDirectory input output

    ConvertSingle input output -&gt; do
      (title, inputHandle) &lt;-
        case input of
          Stdin -&gt;
            (,) &quot;&quot; &lt;$&gt; stdin
          InputFile file -&gt;
            (,) file &lt;$&gt; openFile file ReadMode

      outputHandle &lt;-
        case output of
          Stdout -&gt; stdout
          OutputFile file -&gt;
            openFile file WriteMode

      convertSingle title inputHandle outputHandle
      hClose inputHandle
      hClose outputHandle
</code></pre>
<p>Let's look at our full <code>app/Main.hs</code> and <code>src/HsBlog.hs</code>:</p>
<details><summary>app/Main.hs</summary>
<pre><code class="language-hs">-- | Entry point for the hs-blog-gen program

module Main where

import Options.Applicative
import HsBlog

main :: IO ()
main = do
  options &lt;- execParser opts
  error &quot;not implemented yet&quot;

-- | Run the generator
run :: Options -&gt; IO ()
run options =
  case options of
    ConvertDir input output -&gt;
      convertDirectory input output

    ConvertSingle input output -&gt; do
      (title, inputHandle) &lt;-
        case input of
          Stdin -&gt;
            (,) &quot;&quot; &lt;$&gt; stdin
          InputFile file -&gt;
            (,) file &lt;$&gt; openFile file ReadMode

      outputHandle &lt;-
        case output of
          Stdout -&gt; stdout
          OutputFile file -&gt;
            openFile file WriteMode

      convertSingle title inputHandle outputHandle
      hClose inputHandle
      hClose outputHandle

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

-- | A single input source
data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

-- | A single output sink
data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show

------------------------------------------------
-- * Parser

opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )

-- | Parser for all options
pOptions :: Parser Options
pOptions = pConvertSingle &lt;|&gt; pConvertDir

------------------------------------------------
-- * Single source to sink conversion parser

-- | Parser for single source to sink option
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertDir &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput

-- | Parser for single input source
pSingleInput :: Parser SingleInput
pSingleInput =
  pInputFile &lt;|&gt; pStdin

-- | Parser for single output sink
pSingleOutput :: Parser SingleInput
pSingleOutput =
  pInputFile &lt;|&gt; pStdout

-- | Input file parser
pInputFile :: Parser SingleInput
pInputFile = fmap FileInput parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

-- | Output file parser
pOutputFile :: Parser SingleOutput
pOutputFile = FileOutput &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Output file&quot;
        )

-- | stdin parser
pStdIn :: Parser SingleInput
pStdin =
  flag' Stdin
    ( help &quot;Standard input&quot;
    )

-- | stdout parser
pStdout :: Parser SingleOutput
pStdout =
  flag' Stdout
    ( help &quot;Standard output&quot;
    )

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir

-- | Parser for input directory
pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

-- | Parser for output directory
pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )
</code></pre>
</details>
<details><summary>src/HsBlog.hs</summary>
<pre><code class="language-hs">-- HsBlog.hs
module HsBlog
  ( convertSingle
  , convertDirectory
  , process
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)
import System.IO

convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory = error &quot;Not implemented&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()

</code></pre>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../05-glue/03-project.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../06-next.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../05-glue/03-project.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../06-next.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
