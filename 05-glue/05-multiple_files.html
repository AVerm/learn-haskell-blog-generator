<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Handling errors and multiple files - Learning Haskell by building a blog generator</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A step by step guide to learning Haskell by building a simple static blog generator">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-about.html"><strong aria-hidden="true">1.</strong> About this tutorial</a></li><li class="chapter-item expanded "><a href="../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible html content (functions)</a></li><li class="chapter-item expanded "><a href="../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="../03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="../03-html/09-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../03-html/10-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="../04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (typeclasses)</a></li><li class="chapter-item expanded "><a href="../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="../05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="../05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="../05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="../05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li><li class="chapter-item expanded "><a href="../05-glue/05-multiple_files.html" class="active"><strong aria-hidden="true">5.5.</strong> Handling errors and multiple files</a></li><li class="chapter-item expanded "><a href="../05-glue/06-finishing_touches.html"><strong aria-hidden="true">5.6.</strong> Finishing touches</a></li></ol></li><li class="chapter-item expanded "><a href="../06-faq.html"><strong aria-hidden="true">6.</strong> Frequently asked questions</a></li><li class="chapter-item expanded "><a href="../07-next.html"><strong aria-hidden="true">7.</strong> Where to go next?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Learning Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="handling-errors-and-multiple-files"><a class="header" href="#handling-errors-and-multiple-files">Handling errors and multiple files</a></h1>
<p>We have left an unimplemented function last chapter,
There are a few more things left for us to do to actually call our program a static blog generator.
We still need to process multiple files in a directory and create an index landing page with links to other pages.</p>
<h2 id="links-in-html"><a class="header" href="#links-in-html">Links in Html</a></h2>
<p>Our Html EDSL currently does not support links or other content modifiers such as bold and italics.
We should add these so we can use them when creating an index.</p>
<p>Up until now we've passed <code>String</code> to <code>Structure</code> creating functions such as <code>p_</code>
and <code>h_</code>. Instead, we could create and pass them a new type, <code>Content</code>, we
can be regular text, links, images, and so on.</p>
<hr />
<p><strong>Exercise</strong>: implement what we've just discussed. Follow the compiler errors and refactor what needs refactoring.</p>
<details><summary>Solution</summary>
<details><summary>src/Html/Internal.hs</summary>
<pre><code class="language-hs">-- Html/Internal.hs
module HsBlog.Html.Internal where

import Numeric.Natural

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

newtype Content
  = Content String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

-- * Structure

p_ :: Content -&gt; Structure
p_ = Structure . el &quot;p&quot; . getContentString

h1_ :: Content -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . getContentString

h_ :: Natural -&gt; Content -&gt; Structure
h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . getContentString

ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)

ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)

code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot; . escape

instance Semigroup Structure where
  (&lt;&gt;) c1 c2 =
    Structure (getStructureString c1 &lt;&gt; getStructureString c2)

instance Monoid Structure where
  mempty = Structure &quot;&quot;

-- * Content

txt_ :: String -&gt; Content
txt_ = Content . escape

link_ :: FilePath -&gt; Content -&gt; Content
link_ path content =
  Content $
    elAttr
      &quot;a&quot;
      (&quot;href=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&quot;)
      (getContentString content)

img_ :: FilePath -&gt; Content
img_ path =
  Content $ &quot;&lt;img src=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&gt;&quot;

b_ :: Content -&gt; Content
b_ content =
  Content $ el &quot;b&quot; (getContentString content)

i_ :: Content -&gt; Content
i_ content =
  Content $ el &quot;i&quot; (getContentString content)

instance Semigroup Content where
  (&lt;&gt;) c1 c2 =
    Content (getContentString c1 &lt;&gt; getContentString c2)

instance Monoid Content where
  mempty = Content &quot;&quot;

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

elAttr :: String -&gt; String -&gt; String -&gt; String
elAttr tag attrs content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot; &quot; &lt;&gt; attrs &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString structure =
  case structure of
    Structure str -&gt; str

getContentString :: Content -&gt; String
getContentString content =
  case content of
    Content str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar


</code></pre>
</details>
<details><summary>src/Html.hs</summary>
<pre><code class="language-hs">-- Html.hs

module HsBlog.Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h_
  , h1_
  , ul_
  , ol_
  , code_
  , txt_
  , img_
  , link_
  , b_
  , i_
  , render
  )
where

import HsBlog.Html.Internal
</code></pre>
</details>
<details><summary>src/Convert.hs</summary>
<pre><code class="language-hs">-- Convert.hs
module HsBlog.Convert where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html

convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure

convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Header n txt -&gt;
      Html.h_ n $ Html.txt_ txt

    Markup.Paragraph p -&gt;
      Html.p_ $ Html.txt_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map (Html.p_ . Html.txt_) list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map (Html.p_ . Html.txt_) list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
</details>
</details>
<hr />
<h2 id="creating-an-index-page"><a class="header" href="#creating-an-index-page">Creating an index page</a></h2>
<p>With our extended Html EDSL, we can now create an index page with links to the other pages.</p>
<p>To create an index page, we need a list of files with their <em>target destination</em>,
as well as their <code>Markup</code> (so we can extract information to include in our index page,
such as the first header and paragraph). Our output should be an <code>Html</code> page.</p>
<p>We need to implement the following function:</p>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup)] -&gt; Html
</code></pre>
<details><summary>Solution</summary>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Header 1 header : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ header))
                &lt;&gt; foldMap convertStructure (take 3 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      &quot;Blog&quot;
      ( Html.h1_ (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )
</code></pre>
</details>
<h2 id="processing-directories"><a class="header" href="#processing-directories">Processing directories</a></h2>
<p>As was hinted in the last chapter, we are going to use the
<a href="https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html"><code>directory</code></a>
package to complete our task. We need to:</p>
<ul>
<li>Create the output directory</li>
<li>Grab all file names in a directory</li>
<li>Filter them according to their extension, we want to process <code>txt</code> file and
copy other files without modification</li>
<li>We want to parse each text file, build an index of the result,
convert the files to html, and write everything to the target directory</li>
</ul>
<p>While our parsing function can't really fail, trying to read or write a file
to the filesystem can fail in several way. It would be nice if our silly little
static blog generator was robust enough that it wouldn't fail completely if one
single file gave it some trouble. This is a good oportunity to learn about
error handling in Haskell, both in uneffectful code and for I/O code.</p>
<h3 id="handling-errors-with-either"><a class="header" href="#handling-errors-with-either">Handling errors with Either</a></h3>
<p>There are quite a few ways to indicate and handle errors in Haskell.
We are going to look at one solution: using the type
<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html">Either</a>.
Either is defined like this:</p>
<pre><code class="language-hs">data Either a b
  = Left a
  | Right b
</code></pre>
<p>Simply put, a value of type <code>Either a b</code> can contain either a value of type <code>a</code>,
or a value of type <code>b</code>.
We can tell them apart from the contructor used.</p>
<pre><code class="language-hs">Left True :: Either Bool b
Right 'a' :: Either a Char
</code></pre>
<p>Using this type, we can represent computations that may fail by using the
<code>Left</code> constructor to indicate failure with some error value attached,
and the <code>Right</code> constructor with one type to represent success with the
expected result.</p>
<p>Since <code>Either</code> is polymorphic, we can use any two types to represent
failure and success. It is often useful to describe the failure modes
using an ADT.</p>
<p>For example, let's say that we want to parse a <code>Char</code> as a decimal digit
to an <code>Int</code>. This operation could fail if the Character is not a digit.
We can represent this error a data type:</p>
<pre><code class="language-hs">data ParseDigitError
  = NotADigit Char
  deriving Show
</code></pre>
<p>And our parsing function can have the type:</p>
<pre><code class="language-hs">parseDigit :: Char -&gt; Either ParseDigitError Int
</code></pre>
<p>Now when we implement our parsing function we can return <code>Left</code> on an error
describing the problem, and <code>Right</code> with the parsed value on successful parsing:</p>
<pre><code class="language-hs">parseDigit :: Char -&gt; Either ParseDigitError Int
parseDigit c =
  case c of
    '0' -&gt; Right 0
    '1' -&gt; Right 1
    '2' -&gt; Right 2
    '3' -&gt; Right 3
    '4' -&gt; Right 4
    '5' -&gt; Right 5
    '6' -&gt; Right 6
    '7' -&gt; Right 7
    '8' -&gt; Right 8
    '9' -&gt; Right 9
    _ -&gt; Left (NotADigit c)
</code></pre>
<p><code>Either a</code> is also an instance of <code>Functor</code> and <code>Applicative</code>,
so we have some combinators to work with if we want to combine these
kind of computations.</p>
<p>For example, if we had three characters and we wanted to try and parse
each of them and then find the maximum between them, we could use the
applicative interface:</p>
<pre><code class="language-hs">max3chars :: Char -&gt; Char -&gt; Char -&gt; Either ParseDigitError Int
max3chars x y z =
  (\a b c -&gt; max a (max b c))
    &lt;$&gt; parseDigit x
    &lt;*&gt; parseDigit y
    &lt;*&gt; parseDigit z
</code></pre>
<p>The <code>Functor</code> and <code>Applicative</code> interfaces of <code>Either a</code> allow us to
apply functions on the payload values of <code>Either a</code> types (where the <code>a</code> is the
same between all of applied values them) and <strong>delay</strong> the error handling to a
later phase. Semantically, the first Either in order that returns a <code>Left</code>
will be the return value. We can see how this works in the implementation
of the applicative instance:</p>
<pre><code class="language-hs">instance Applicative (Either e) where
    pure          = Right
    Left  e &lt;*&gt; _ = Left e
    Right f &lt;*&gt; r = fmap f r
</code></pre>
<p>At some point, someone who will actually want to <strong>inspect</strong> the result
and see if we got an error (with the <code>Left</code> constructor) or the expected value
(with the <code>Right</code> constructor) by pattern matching on the result.</p>
<h4 id="applicative--traversable"><a class="header" href="#applicative--traversable">Applicative + Traversable</a></h4>
<p>The <code>Applicative</code> interface of <code>Either</code> is very powerful, and can be combine
with a different abstraction called
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Traversable.html#g:1"><code>Traversable</code></a> -
for data structures that can be traversed from left to right, like a linked list or a binary tree.
With these, we can combine an unspecified amount of values such as <code>Either ParseDigitError Int</code>
As long as they are all in a data structure that implements <code>Traversable</code>.</p>
<p>Let's see an example:</p>
<pre><code class="language-hs">ghci&gt; :t &quot;1234567&quot;
&quot;1234567&quot; :: String
-- remember, a String is an alias for a list of Char
ghci&gt; :info String
type String :: *
type String = [Char]
  	-- Defined in ‘GHC.Base’

ghci&gt; :t map parseDigit &quot;1234567&quot;
map parseDigit mystring :: [Either ParseDigitError Int]
ghci&gt; map parseDigit &quot;1234567&quot;
[Right 1,Right 2,Right 3,Right 4,Right 5,Right 6,Right 7]

ghci&gt; :t sequenceA
sequenceA :: (Traversable t, Applicative f) =&gt; t (f a) -&gt; f (t a)
-- Substitute `t` with `[]`, and `f` with `Either Error` for a specialized version

ghci&gt; sequenceA (map parseDigit mystring)
Right [1,2,3,4,5,6,7]

ghci&gt; map parseDigit &quot;1a2&quot;
[Right 1,Left (NotADigit 'a'),Right 2]
ghci&gt; sequenceA (map parseDigit &quot;1a2&quot;)
Left (NotADigit 'a')
</code></pre>
<p>The pattern of doing <code>map</code> and then <code>sequenceA</code> is another function called <code>traverse</code>:</p>
<pre><code class="language-hs">ghci&gt; :t traverse
traverse
  :: (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
ghci&gt; traverse parseDigit &quot;1234567&quot;
Right [1,2,3,4,5,6,7]
ghci&gt; traverse parseDigit &quot;1a2&quot;
Left (NotADigit 'a')
</code></pre>
<p>We can use <code>traverse</code> on any two types where one implements the <code>Applicative</code>
interface, like <code>Either a</code> or <code>IO</code>, and the other implements the <code>Traversable</code>,
like <code>[]</code> (linked lists) and <a href="https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#t:Map"><code>Map k</code></a>
(also known as a dictionary in other languages - a mapping from keys to values).
For example using <code>IO</code> and <code>Map</code>. Note that we can construct a <code>Map</code> data structure
from a list of tuples using the
<a href="https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#v:fromList"><code>fromList</code></a>
function - the first value in the tuple is the key, and the second is the type.</p>
<pre><code class="language-hs">ghci&gt; import qualified Data.Map as M -- from the containers package

ghci&gt; file1 = (&quot;output/file1.html&quot;, &quot;input/file1.txt&quot;)
ghci&gt; file2 = (&quot;output/file2.html&quot;, &quot;input/file2.txt&quot;)
ghci&gt; file3 = (&quot;output/file3.html&quot;, &quot;input/file3.txt&quot;)
ghci&gt; files = M.fromList [file1, file2, file3]
ghci&gt; :t files :: M.Map FilePath FilePath -- FilePath is an alias of String
files :: M.Map FilePath FilePath :: M.Map FilePath FilePath

ghci&gt; readFiles = traverse readFile
ghci&gt; :t readFiles
readFiles :: Traversable t =&gt; t FilePath -&gt; IO (t String)

ghci&gt; readFiles files
fromList [(&quot;output/file1.html&quot;,&quot;I'm the content of file1.txt\n&quot;),(&quot;output/file2.html&quot;,&quot;I'm the content of file2.txt\n&quot;),(&quot;output/file3.html&quot;,&quot;I'm the content of file3.txt\n&quot;)]
ghci&gt; :t readFiles files
readFiles files :: IO (Map String String)
</code></pre>
<p>Above, we created a function <code>readFiles</code> that will take a mapping from <em>output file path</em>
to <em>input file path</em> and returns an IO operation that when run will read the input files
and replace their contents right there in the map! Surely this will be useful later.</p>
<h4 id="multiple-errors"><a class="header" href="#multiple-errors">Multiple errors</a></h4>
<p>Note, since <code>Either</code> has the kind <code>* -&gt; * -&gt; *</code> (it takes two type
parameters) <code>Either</code> cannot be an instance of <code>Functor</code> and <code>Applicative</code>,
instances for these type classes can only be implemented for types that have the
kind <code>* -&gt; *</code>.
Remember that when we look at a type class function signature like:</p>
<pre><code class="language-hs">fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>And we want to implement it for a specific type (in place of the <code>f</code>),
we need to be able to <em>substitute</em> the <code>f</code> with the target type. If we'd try
to do it with <code>Either</code> we'll get:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Either a -&gt; Either b
</code></pre>
<p>And neither <code>Either a</code> or <code>Either b</code> are <em>saturated</em>, so this won't type check.
For the same reason if we'll try to substitute <code>f</code> with, say, <code>Int</code>, we'll get:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Int a -&gt; Int b
</code></pre>
<p>Which also doesn't make sense.</p>
<p>So while we can't use <code>Either</code>, we can use <code>Either e</code>, which has the kind
<code>* -&gt; *</code>. Now let's try substituting <code>f</code> with <code>Either e</code> in this signature:</p>
<pre><code class="language-hs">liftA2 :: Applicative =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<p>And we'll get:</p>
<pre><code class="language-hs">liftA2 :: (a -&gt; b -&gt; c) -&gt; Either e a -&gt; Either e b -&gt; Either e c
</code></pre>
<p>What this teaches us is that we can only use the applicative interface to
combine two <code>Either</code> <strong>with the same type for the <code>Left</code> constructor</strong>.</p>
<p>So what can we do if we have two functions that can return different errors?
There are a few approaches, the most prominent ones are:</p>
<ol>
<li>Make them return the same error type. Write an ADT that holds all possible
error descriptions. This can work in some cases but isn't always ideal
because for example a user calling <code>parseDigit</code> shouldn't be force to
handle a possible case that the input might be an empty string.</li>
<li>Use a specialized error type for each type, and when they are composed together,
map the error type of each function to a more general error type. This can
be done with the function <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Bifunctor.html#v:first"><code>first</code></a> from the <code>Bifunctor</code> type class.</li>
</ol>
<h4 id="monadic-interface"><a class="header" href="#monadic-interface">Monadic interface</a></h4>
<p>The applicative interface allows us to lift a function on to work on multiple
<code>Either</code> values (or other applicative functor instances such as <code>IO</code> and <code>Parser</code>). 
But more often than not, we'd like to be able to use a value from one computation
that might return an error in another computation that might return an error.</p>
<p>For example, a compiler such has GHC operates in stages, such as lexical analysis,
parsing, typechecking, and so on. Each stage depends on the output of the stage
before it, and each stage might fail. We can write the types for these functions:</p>
<pre><code class="language-hs">tokenize :: String -&gt; Either Error [Token]

parse :: [Token] -&gt; Either Error AST

typcheck :: AST -&gt; Either Error TypedAST
</code></pre>
<p>We want to compose these functions so that they work in a chain. The output of <code>tokenize</code>
goes to <code>parse</code>, the output of <code>parse</code> goes into to <code>typecheck</code>.</p>
<p>We know that we can lift a function over an <code>Either</code> (and other functors),
we could also lift a function that returns an <code>Either</code>:</p>
<pre><code class="language-hs">-- reminder the type of fmap
fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- specialized for `Either Error`
fmap :: (a -&gt; b) -&gt; Either Error a -&gt; Either Error b

-- here, `a` is [Token] and `b` is `Either Error AST`:

fmap parse (tokenize string) :: Either Error (Either Error AST)
</code></pre>
<p>While this code compiles, it isn't great, because we are building
layers of <code>Either Error</code> and we can't use this trick again with
<code>typecheck</code>! <code>typecheck</code> expects an <code>AST</code>, but if we try to fmap it
on <code>fmap parse (tokenize string)</code>, the <code>a</code> will be <code>Either Error AST</code>
instead.</p>
<p>What we would really like is to flatten this structure instead of build it.
If we look at the kind of values <code>Either Error (Either Error AST)</code> could have,
it looks something like this:</p>
<ul>
<li><code>Left &lt;error&gt;</code></li>
<li><code>Right (Left error)</code></li>
<li><code>Right (Right &lt;ast&gt;)</code></li>
</ul>
<hr />
<p><strong>Exercise</strong>: What if we just used pattern matching for this instead? How would this look like?</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">case tokenize string of
  Left err -&gt;
    Left err
  Right tokens -&gt;
    case parse tokens of
      Left err -&gt;
        Left err
      Right ast -&gt;
        typecheck ast
</code></pre>
<p>If we run into an error in a stage, we return that error and stop. If we succeed, we
use the value on the next stage.</p>
</details>
<hr />
<p>Flattening this structure for <code>Either</code> is very similar to that last part - the body
of the <code>Right tokens</code> case:</p>
<pre><code class="language-hs">flatten :: Either e (Either e a) -&gt; Either e a
flatten e =
  case e of
    Left l -&gt; Left l
    Right x -&gt; x
</code></pre>
<p>Because we have this function, we can now use it on the output of
<code>fmap parse (tokenize string) :: Either Error (Either Error AST)</code>
from before:</p>
<pre><code>flatten (fmap parse (tokenize string)) :: Either Error AST
</code></pre>
<p>And now we can use this function again to compose with <code>typecheck</code>:</p>
<pre><code>flatten (fmap typecheck (flatten (fmap parse (tokenize string)))) :: Either Error TypedAST
</code></pre>
<p>This <code>flatten</code> + <code>fmap</code> combination looks like a reccuring pattern which
we can combine into a function:</p>
<pre><code class="language-hs">flatMap :: (a -&gt; Either e b) -&gt; Either a -&gt; Either b
flatMap func val = flatten (fmap func val)
</code></pre>
<p>And now we can write the code this way:</p>
<pre><code class="language-hs">flatMap typecheck (flatMap parse (tokenize string)) :: Either Error TypedAST

-- Or using backticks syntax to convert the function to infix form:
typecheck `flatMap` parse `flatMap` tokenize string

-- Or create a custom infix operator: (=&lt;&lt;) = flatMap
typeCheck =&lt;&lt; parse =&lt;&lt; tokenize string
</code></pre>
<p>This function, <code>flatten</code> (and <code>flatMap</code> as well), have different names in Haskell.
They are called <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Monad.html#v:join"><code>join</code></a>
and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Monad.html#v:-61--60--60-"><code>=&lt;&lt;</code></a> (pronounced &quot;reverse bind&quot;),
and they are the essence of another incredibly useful abstraction in Haskell.</p>
<p>If we have a type that can implement:</p>
<ol>
<li>The <code>Functor</code> interface, specifically the <code>fmap</code> function</li>
<li>The <code>Applicative</code> interface, most importantly the <code>pure</code> function</li>
<li>This <code>join</code> function</li>
</ol>
<p>They can implement an instance of the <code>Monad</code> type class.</p>
<p>With functors, we were able to &quot;lift&quot; a function to work over the type implementing the functor type class:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>With applicative functors we were able to &quot;lift&quot; a function of multiple arguments
over multiple values of a type implementing the applicative functor type class,
and also lift a value into that type:</p>
<pre><code class="language-hs">pure :: a -&gt; f a

liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<p>With monads we can now flatten (or, &quot;join&quot; in Haskell terminology) types that implement
the <code>Monad</code> interface:</p>
<pre><code class="language-hs">join :: m (m a) -&gt; m a

-- this is =&lt;&lt; with the arguments reversed, pronounced &quot;bind&quot;
(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>With <code>&gt;&gt;=</code> we can write our compilation pipeline from before in a left-to-right
manner, which seems to be more popular for monads:</p>
<pre><code class="language-hs">tokenize string &gt;&gt;= parse &gt;&gt;= typecheck
</code></pre>
<p>We have already run into this function before when we talked about <code>IO</code>. Yes,
<code>IO</code> also implements the <code>Monad</code> interface. The monadic interface for <code>IO</code>
helped us with creating an proper ordering of effects.</p>
<p>The essence of the <code>Monad</code> interface is the <code>join</code>/<code>&gt;&gt;=</code> functions, and as we've seen
we can implement <code>&gt;&gt;=</code> in terms of <code>join</code>, we can also implement <code>&gt;&gt;=</code> in terms
of <code>join</code> (try it!).</p>
<p>The monadic interface can mean very different things for different types. For <code>IO</code> this
is ordering of effects, for <code>Either</code> it is early cutoff, for <code>Shake</code>
(from the <a href="https://shakebuild.com">shake build system</a>) this means dynamic dependencies,
for <a href="https://hackage.haskell.org/package/logict-0.7.1.0"><code>Logic</code></a> this means backtracking computation.</p>
<p>Again, don't worry about analogies and metaphors, focus on the API and the <a href="https://wiki.haskell.org/Monad_laws">laws</a>.</p>
<blockquote>
<p>Hey, did you check the monad laws? left identity, right identity and associativity? We've already
discussed a type class with exactly these laws - the <code>Monoid</code> type class. Maybe this is related
to the famous quote about monads beings just monoids in something something... Seriously writing
this is the first time I've made this connection myself!</p>
</blockquote>
<h5 id="do-notation"><a class="header" href="#do-notation">Do notation?</a></h5>
<p>Remember <a href="02-io.html#do-notation">do notation</a>? Turns out it works for any type that is
an instance of <code>Monad</code>. How cool is that? Instead of writing:</p>
<pre><code class="language-hs">pipeline :: String -&gt; Either Error TypedAST
pipeline string =
  tokenize string &gt;&gt;= \tokens -&gt;
    parse tokens &gt;&gt;= \ast -&gt;
      typecheck ast
</code></pre>
<p>We can write:</p>
<pre><code class="language-hs">pipeline :: String -&gt; Either Error TypedAST
pipeline string = do
  tokens &lt;- tokenize string
  ast &lt;- parse tokens
  typecheck ast
</code></pre>
<p>And it will work! Still, in this particular case <code>tokenize string &gt;&gt;= parse &gt;&gt;= typecheck</code>
is so concise it can only be beat by using
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Monad.html#v:-62--61--62-">&gt;=&gt;</a></p>
<pre><code class="language-hs">&gt;=&gt; :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c

-- compare with function composition:
(.) ::            (a -&gt;   b) -&gt; (b -&gt;   c) -&gt; a -&gt;   c
</code></pre>
<pre><code class="language-hs">pipeline = tokenize &gt;=&gt; parse &gt;=&gt; typecheck
</code></pre>
<p>This ability of Haskell's to create very concise code using great abstractions makes it
great once one is familiarity with the abstractions, knowing the monad abstractions,
we are now already familiar with the core composition API of many libraries - for example:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/stm">Concurrent</a>
and <a href="https://hackage.haskell.org/package/async">asynchronous programming</a></li>
<li><a href="https://gilmi.me/blog/post/2020/12/05/scotty-bulletin-board">Web programming</a></li>
<li><a href="http://hspec.github.io/">Testing</a></li>
<li><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2">Emulating stateful computation</a></li>
<li><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#g:2">sharing environment between computations</a></li>
<li>and many more.</li>
</ul>
<h5 id="either-summary"><a class="header" href="#either-summary">Either summary</a></h5>
<p>Using <code>Either</code> for error handling is useful for two reasons:</p>
<ol>
<li>We encode possible errors using types, and we <strong>force users to acknowledge and handle</strong> them, thus
making our code more resilient to crashes and bad behaviour.</li>
<li>The <code>Functor</code>, <code>Applicative</code> and <code>Monad</code> interfaces provides us with mechanisms for
<strong>composing</strong> functions that might fail (almost) effortlessly - reducing boilerplate while
maintaining strong guarantees about our code!</li>
</ol>
<h4 id="either-with-io"><a class="header" href="#either-with-io">Either with IO?</a></h4>
<p>When we create <code>IO</code> actions that may require I/O we risk running into all kinds of errors.
For example, when we use <code>writeFile</code>, we could run out of disk space in the middle of writing,
or the file might be write protected. While these scenarios aren't super common, they are definitely
possible.</p>
<p>We could've potentially encoded Haskell functions like <code>readFile</code> and <code>writeFile</code> as <code>IO</code> operations
that return <code>Either</code>, for example:</p>
<pre><code class="language-hs">readFile :: FilePath -&gt; IO (Either ReadFileError String)
writeFile :: FilePath -&gt; String -&gt; IO (Either WriteFileError ())
</code></pre>
<p>However there are a couple of issues here, the first is that now composing <code>IO</code> actions
became more difficult. Previously we could write:</p>
<pre><code class="language-hs">readFile &quot;input.txt&quot; &gt;&gt;= writeFile &quot;output.html&quot;
</code></pre>
<p>But now the types no longer match - <code>readFile</code> will return an <code>Either ReadFileError String</code>,
but <code>writeFile</code> wants to take a <code>String</code> as input. We are forced to handle the error
before calling <code>writeFile</code>.</p>
<h5 id="composing-io--either-using-exceptt"><a class="header" href="#composing-io--either-using-exceptt">Composing IO + Either using ExceptT</a></h5>
<p>One way to handle this is by using <strong>monad transformers</strong>. Monad transformers are a method
to stack monad capabilities on top of one another. They are called transformers because
<strong>they take a type that has an instance of monad as input, and return a new type that
implements the monad interface, stacking a new capability on top of that</strong>.</p>
<p>For example, if we want to create a value with a type similar to <code>IO (Either Error a)</code>
that we can compose using the monadic interface (the function <code>&gt;&gt;=</code>) with other values
of a type similar to <code>IO (Either Error a)</code>, we can using a monad transformer
called <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#g:2"><code>ExceptT</code></a>.
Let's see how <code>ExceptT</code> is defined:</p>
<pre><code class="language-hs">newtype ExceptT e m a = ExceptT (m (Either e a))
</code></pre>
<p>Remember, a <code>newtype</code> is a new name for an existing type. And if we substitute
<code>e</code> with <code>Error</code> and <code>m</code> with <code>IO</code> we'll get exactly <code>IO (Either Error a)</code> as we wanted.
And we can convert an <code>ExceptT Error IO a</code> into <code>IO (Either Error a)</code> using
the function <code>runExceptT</code>:</p>
<pre><code class="language-hs">runExceptT :: ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p><code>ExceptT</code> implements the monadic interface in a way that combines the capabilities of
<code>Either</code>, and whatever <code>m</code> it takes.</p>
<hr />
<p>Unsure how this works? Try to implement <code>&gt;&gt;=</code> for <code>IO (Either Error a)</code>:</p>
<pre><code class="language-hs">bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b)
</code></pre>
<details><summary>Solution</summary>
<pre><code class="language-hs">bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b)
bindExceptT mx f = do
  x &lt;- mx -- `x` has the type `Either Error a`
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; f y
</code></pre>
<p>Note that we didn't actually use the implementation details of <code>Error</code> or <code>IO</code>,
<code>Error</code> isn't mentioned at all, and for <code>IO</code> we only used the monadic interface with
the do notation. We could write the same function with a more generalized type signature:</p>
<pre><code class="language-hs">bindExceptT :: Monad m =&gt; m (Either e a) -&gt; (a -&gt; m (Either e b)) -&gt; m (Either e b)
bindExceptT mx f = do
  x &lt;- mx -- `x` has the type `Either e a`
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; f y
</code></pre>
<p>And because <code>newtype ExceptT e m a = ExceptT (m (Either e a))</code> we can just
pack and unpack that <code>ExceptT</code> constructor and get:</p>
<pre><code class="language-hs">bindExceptT :: Monad m =&gt; ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b
bindExceptT mx f = ExceptT $ do
  -- `runExceptT mx` has the type `m (Either e a)`
  -- `x` has the type `Either e a`
  x &lt;- runExceptT mx
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; f y
</code></pre>
</details>
<hr />
<blockquote>
<p>Note that when stacking monad transformers, the order in which we stack them matters.
With <code>ExceptT Error IO a</code>, we have an <code>IO</code> operation that when run will return <code>Either</code>
an error or a value.</p>
</blockquote>
<p><code>ExceptT</code> can enjoy both worlds - we can return error values using the function <code>throwError</code>:</p>
<pre><code class="language-hs">throwError :: e -&gt; ExceptT e m a
</code></pre>
<p>and we can &quot;lift&quot; functions that return a value of the underlying monadic type <code>m</code> to return
a value of <code>ExceptT e m a</code> instead:</p>
<pre><code class="language-hs">lift :: m a -&gt; ExceptT e m a
</code></pre>
<p>for example:</p>
<pre><code class="language-hs">getLine :: IO String

lift getLine :: ExceptT e IO String
</code></pre>
<blockquote>
<p>(Actually, <code>lift</code> is also a type class function from <code>MonadTrans</code>, the type class
of monad transformers. So technically <code>lift getLine :: MonadTrans t =&gt; t IO String</code>,
but we are specializing for concreteness)</p>
</blockquote>
<p>Now, if we had:</p>
<pre><code class="language-hs">readFile :: FilePath -&gt; ExceptT IOError IO String

writeFile :: FilePath -&gt; String -&gt; ExceptT IOError IO ()
</code></pre>
<p>We could compose them again without issue:</p>
<pre><code class="language-hs">readFile &quot;input.txt&quot; &gt;&gt;= writeFile &quot;ouptut.html&quot;
</code></pre>
<p>But remember - the error type <code>e</code> (in both the case <code>Either</code> and <code>Except</code>)
must be the same between composed functions! This means that the type representing
errors for both <code>readFile</code> and <code>writeFile</code> must be the same - that would also
force anyone using these functions to handle these errors - should a user who
called <code>writeFile</code> be required to handle a &quot;file not found&quot; error? Should a user
who called <code>readFile</code> be required to handle an &quot;out of disk space&quot; error?
There are many many more possible IO errors! &quot;network unreachable&quot;, &quot;out of memory&quot;,
&quot;cancelled thread&quot;, we cannot require a user to handle all these errors, or
even cover them all in a data type.</p>
<p>So what do we do?</p>
<p>We give up on this approach <strong>for IO code</strong>, and use a different one: Exceptions.</p>
<h3 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h3>
<h2 id="alright-already-lets-get-to-work"><a class="header" href="#alright-already-lets-get-to-work">Alright already, let's get to work!</a></h2>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This was quite a chapter. Let's recount the things we've learned.</p>
<p>We discussed several ways to handle errors in Haskell:</p>
<ol>
<li>Encoding errors as a data type and using the <code>Either</code> type to encode &quot;a value or an error&quot;.
Useful approach for uneffectful code.</li>
<li>Using <code>ExceptT</code> when we want to combine the approach in (1) on top on an existing
type with monadic capabilities.</li>
<li>Using exceptions for IO code</li>
</ol>
<p>We've also learned a few new abstractions and techniques:</p>
<ol>
<li>The <code>Traversable</code> type class, for data structures that can be traversed from left to right
such as linked lists, binary trees and <code>Map</code>s.
Pretty useful when combined with another applicative functor type like <code>Either</code>.</li>
<li>The <code>Monad</code> type class extends the <code>Applicative</code> type class with the <code>join :: m (m a) -&gt; m a</code>
function. We learned that <code>Either</code> implements this type class interface and so does <code>IO</code>.</li>
<li>The <code>MonadTrans</code> type class for <em>monad transformers</em> for types that take other monads as inputs
and provide a monadic interface (<code>&gt;&gt;=</code>, do notation, etc.) while combining both their capabilities.
We saw how to stack an <code>Either</code>-like monad transformer, <code>ExceptT</code>, on top of <code>IO</code>.
<blockquote>
<p>Note - when we stack <code>ExceptT</code> on top of a different type called
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Functor-Identity.html">Identity</a>
that also implements the <code>Monad</code> interface, we get a type that is exactly like <code>Either</code>,
which is called <a href="https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Except.html#t:Except">Except</a>
(without the <code>T</code> at the end). You might sometimes want to use <code>Except</code> instead of <code>Either</code>
because it has a more appropriate name and API for error handling than <code>Either</code>.</p>
</blockquote>
</li>
</ol>
<p>We are almost done. Only a couple more things left to do with this project. Let's go!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../05-glue/04-optparse.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../05-glue/06-finishing_touches.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../05-glue/04-optparse.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../05-glue/06-finishing_touches.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
