<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Haskell by building a blog generator</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A step by step guide to learning Haskell by building a simple static blog generator">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-about.html"><strong aria-hidden="true">1.</strong> About this tutorial</a></li><li class="chapter-item expanded "><a href="02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible html content (functions)</a></li><li class="chapter-item expanded "><a href="03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="03-html/09-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="03-html/10-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (typeclasses)</a></li><li class="chapter-item expanded "><a href="04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-glue/01-io.html"><strong aria-hidden="true">5.1.</strong> Working with IO</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Learning Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-tutorial"><a class="header" href="#about-this-tutorial">About this tutorial</a></h1>
<blockquote>
<p>Note: This is WIP</p>
</blockquote>
<p>In this tutorial we will implement a very simple static blog generator in Haskell, converting documents written in our own custom markup language to html.</p>
<p>We will:</p>
<ol>
<li>Implement a tiny HTML printer library</li>
<li>Define and parse our custom markup language</li>
<li>Read files and glue things together</li>
<li>Add command line arguments parsing</li>
<li>Alternatively serve the blog over http</li>
</ol>
<p>In each chapter of the book we will focus on a particular task we wish to achieve, and through the chapter we'll learn just enough Haskell to complete the task.</p>
<p>This book is an alternatively presentation of:
<a href="https://github.com/soupi/learn-haskell-blog-generator">soupi/learn-haskell-blog-generator</a>, which presents the chapters one commit at a time.</p>
<p>You might be also interested in:</p>
<ul>
<li><a href="https://soupi.github.io/rfc/reading_simple_haskell/">Reading Simple Haskell</a></li>
<li><a href="https://github.com/soupi/haskell-study-plan/">Haskell Study Plan</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h1>
<p>In this chapter we will create a simple html hello world.</p>
<p>A Haskell source file is composed of definitions.</p>
<p>The most common definition has the following form:</p>
<pre><code class="language-hs">&lt;name&gt; = &lt;expression&gt;
</code></pre>
<p>Note that:</p>
<ol>
<li>We cannot write naked expressions without binding them to a name</li>
<li>Names must start with a lowercase letter</li>
<li>We cannot use the same name more than once in a file</li>
</ol>
<p>A source file containing a definition of the name <code>main</code> is treated as an executable, and the expression <code>main</code> is bound to is the entry point to the program.</p>
<p>Let's create a new Haskell source file called <code>hello.hs</code>, and write the following line there:</p>
<pre><code class="language-hs">main = putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>We've defined a new name, <code>main</code>, and bound it to the expression <code>putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>.</p>
<p>the body of <code>main</code> means calling the function <code>putStrLn</code> with the string <code>&quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>.
<code>putStrLn</code> takes a single string as input and prints that string to the standard output.</p>
<p><strong>Note</strong>: we don't need parenthesis to pass arguments to functions in Haskell.</p>
<p>Running this program will result in the following text printed on the screen:</p>
<pre><code>&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>To run this little program, we can either compile it using the command line program <code>ghc</code>, like this: <code>ghc hello.hs</code> which will create a few files:</p>
<ol>
<li><code>hello.o</code> - Object file</li>
<li><code>hello.hi</code> - Haskell interface file</li>
<li><code>hello</code> - A native executable file</li>
</ol>
<p>and then run <code>hello</code>.</p>
<p>Or, alternatively, interpret the source file using the command line program <code>runghc</code>, like this: <code>runghc hello.hs</code> which will run the program without compiling it or creating any files.</p>
<pre><code class="language-sh">&gt; runghc hello.hs
&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>We can also redirect the output of the program to a file and then open it in firefox.</p>
<pre><code class="language-sh">&gt; runghc hello.hs &gt; hello.html
&gt; firefox hello.html
</code></pre>
<p>This command should open firefox and display a web page with <code>Hello, world!</code> written in it.</p>
<p>In this tutorial we'll use <code>runghc</code> regularily, because it saves us time to run the program without compiling it.</p>
<hr />
<p><strong>Note</strong>: If you've installed a ghc toolchain via stack and not ghcup, and the commands above do not work because <code>ghc</code> or <code>runghc</code> are missing, prefix the commands above with <code>stack exec -- </code>. Stack will locate the globally installed ghc and use it. So for example <code>runghc hello.hs</code> becomes <code>stack exec -- runghc hello.hs</code>. See the <a href="https://docs.haskellstack.org/en/stable/GUIDE/#exec">Stack user guide</a> for more details.</p>
<hr />
<h2 id="more-bindings"><a class="header" href="#more-bindings">More bindings</a></h2>
<p>We can define the html string passed to <code>putStrLn</code> in a new name instead. Change the content of file <code>hello.hs</code> we defined above to:</p>
<pre><code class="language-hs">main = putStrLn myhtml

myhtml = &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p><strong>Note</strong>: the order in which we declare the bindings does not matter. Try reversing the order of definitions and see for yourself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-an-html-printer-library"><a class="header" href="#building-an-html-printer-library">Building an HTML printer library</a></h1>
<p>In this part we'll explore a few basic building blocks in Haskell,
including functions, types and modules, while building a small HTML printer library
with which we will later construct HTML pages from our markup blog posts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flexible-html-content-functions"><a class="header" href="#flexible-html-content-functions">Flexible html content (functions)</a></h1>
<p>We'd like to be able to write different html contents without having to write the whole html-body tags over and over again.</p>
<p>To define a function, we create a definition like we saw previously and add the arguments names after the name and before the equals sign (<code>=</code>). So a function definition has the following form:</p>
<pre><code class="language-hs">&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; = &lt;expression&gt;
</code></pre>
<p>The argument names will be available in scope on the right side of the equals sign (in the <code>&lt;expression&gt;</code>), and the function name will be <code>&lt;name&gt;</code>.</p>
<p>We'll define a function that takes a string which is the content and wraps it in the relevant <code>html</code> and <code>body</code> tags by concatenating them before and after the content.
We use the operator <code>&lt;&gt;</code> to concatenate two strings.</p>
<pre><code class="language-hs">wrapHtml content = &quot;&lt;html&gt;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>This function, <code>wrapHtml</code>, takes one argument named <code>content</code> and returns a string that prefixes <code>&lt;html&gt;&lt;body&gt;</code> before the content and appends <code>&lt;/body&gt;&lt;/html&gt;</code>.
It is common to use camelCase in Haskell.</p>
<p>Now we can adjust our <code>myhtml</code> definition from the previous chapter:</p>
<pre><code class="language-hs">myhtml = wrapHtml &quot;Hello, world!&quot;
</code></pre>
<p>Again, notice that we don't need parenthesis when calling functions. Function calls have the form:</p>
<pre><code class="language-hs">&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt;
</code></pre>
<p>However, if we wanted to substitute <code>myhtml</code> with the expression <code>myhtml</code> is bound to in <code>main = putStrLn myhtml</code>, we would have to wrap the expression in paranthesis:</p>
<pre><code class="language-hs">main = putStrLn (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<p>If we accidentally write this instead:</p>
<pre><code class="language-hs">main = putStrLn wrapHtml &quot;Hello, world!&quot;
</code></pre>
<p>we'll get an error from GHC stating that <code>putStrLn</code> is applied to two arguments, but it only takes one. this is because the above is of the form <code>&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt;</code> as we defined earlier. By using parenthesis we can group together the expressions in the right order.</p>
<hr />
<p>Exercises:</p>
<ol>
<li>
<p>Separate the functionality of <code>wrapHtml</code> to two functions:</p>
<ol>
<li>One that wraps content in <code>html</code> tag</li>
<li>one that wraps content in a <code>body</code> tag</li>
</ol>
<p>Name the new functions <code>html_</code> and <code>body_</code>.</p>
</li>
<li>
<p>Change <code>myhtml</code> to use these two functions.</p>
</li>
<li>
<p>Add another two similar functions for the tags <code>&lt;head&gt;</code> and <code>&lt;title&gt;</code> and name them <code>head_</code> and <code>title_</code>.</p>
</li>
<li>
<p>Create a new function, <code>makeHtml</code>, which takes two strings as input:</p>
<ol>
<li>One string for the title</li>
<li>One string for the body content</li>
</ol>
<p>And construct an HTML string using the functions implemented in the previous exercises.</p>
<p>The output for:</p>
<pre><code class="language-hs">makeHtml &quot;My page title&quot; &quot;My page content&quot;
</code></pre>
<p>Should be:</p>
<pre><code class="language-html">&lt;html&gt;&lt;head&gt;&lt;title&gt;My page title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;My page content&lt;/body&gt;&lt;/html&gt;
</code></pre>
</li>
<li>
<p>Use <code>makeHtml</code> in <code>myhtml</code> instead of using <code>html_</code> and <code>body_</code> directly</p>
</li>
</ol>
<hr />
<p>Solutions:</p>
<details>
  <summary>Solution for exercise #1</summary>
<pre><code class="language-hs">html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #2</summary>
<pre><code class="language-hs">myhtml = html_ (body_ &quot;Hello, world!&quot;)
</code></pre>
</details>
<details>
  <summary>Solution for exercise #3</summary>
<pre><code class="language-hs">head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #4</summary>
<pre><code class="language-hs">makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)
</code></pre>
</details>
<details>
  <summary>Solution for exercise #5</summary>
<pre><code class="language-hs">myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;
</code></pre>
</details>
<details>
  <summary>Our final program</summary>
<pre><code class="language-hs">-- hello.hs

main = putStrLn myhtml

myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;

makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;

head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
<p>We can now run our <code>hello.hs</code> program, pipeline the output into a file,
and open it in our browser:</p>
<pre><code class="language-sh">runghc hello.hs &gt; hello.html
firefox hello.html
</code></pre>
<p>It should display <code>Hello, world!</code> on the page and <code>Hello title</code> on the page's title.</p>
</details>
<hr />
<h2 id="indentation"><a class="header" href="#indentation">Indentation</a></h2>
<p>You might ask how does Haskell know a definition is complete?
The answer is: Haskell uses indentation to know when things should be grouped together.</p>
<p>Indentation in Haskell can be a bit tricky, but in general: code which is supposed to be part of another expression should be indented further than the beginning of that expression.</p>
<p>We know two definitions are separate because the second one is not indented further than the first one.</p>
<h3 id="indentation-tips"><a class="header" href="#indentation-tips">Indentation tips</a></h3>
<ol>
<li>Choose a specific amount of spaces for indentation (2 spaces, 4 spaces, etc) and stick to it. Prefer spaces to tabs.</li>
<li>Do not indent more than once in any given time.</li>
<li>When in doubt, drop line as needed and indent once.</li>
</ol>
<p>Here are a few examples:</p>
<pre><code class="language-hs">main =
    putStrLn &quot;Hello, world!&quot;
</code></pre>
<p>or:</p>
<pre><code class="language-hs">main =
    putStrLn
        (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<p><strong>Avoid the following styles</strong>, which use more than one indentation steps:</p>
<pre><code class="language-hs">main = putStrLn
        (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<pre><code class="language-hs">main = putStrLn
                (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-type-signatures"><a class="header" href="#adding-type-signatures">Adding type signatures</a></h1>
<p>Haskell is a statically typed language. That means that every
expression has a type, and we check that the types are valid with
regards to each other before running the program. If we discover that
they are not valid, an error message will be printed and the program
will not run.</p>
<p>An example of type error would be if we'd pass a function more
arguments that it take, or pass a number instead of a string.</p>
<p>Haskell is also type inferred, so we don't <em>need</em> to specify the type
of expressions - Haskell can infer from the context of the expression
what its type is, and that's what we did up until now. But specifying
types is useful - it adds a layer of documentation for you or others
that will look at the code later, and it helps verify to some degree
that what was intended (with the type signature) is what was
written (with the expression).</p>
<p>We use double-colon (<code>::</code>) to specify the type of names. We usually
write it right above the definition of the name itself.</p>
<p>Here are a few examples of types we can write:</p>
<ul>
<li><code>Int</code> - The type of integer numbers</li>
<li><code>String</code> - The type of strings</li>
<li><code>Bool</code> - The type of booleans</li>
<li><code>()</code> - The type of the expression <code>()</code>, also called unit</li>
<li><code>a -&gt; b</code> - The type of a function from an expression of type <code>a</code> to an expression of type <code>b</code></li>
<li><code>IO ()</code> - The type of an expression that represents an IO subroutine that returns <code>()</code></li>
</ul>
<p>Let's specify the type of <code>title_</code>:</p>
<pre><code class="language-hs">title_ :: String -&gt; String
</code></pre>
<p>We can see in the code that the type of <code>title_</code> is a function that takes
a <code>String</code> and returns a <code>String</code>.</p>
<p>Let's also specify the type of <code>makeHtml</code>:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; String -&gt; String
</code></pre>
<p>Previously, we thought about <code>makeHtml</code> as a function that takes
two strings and returns a string.</p>
<p>But actually, all functions in Haskell take <strong>exactly one argument</strong> as input
and return <strong>exactly one value</strong> as output. It's just convenient to refer
to functions like <code>makeHtml</code> as functions with multiple inputs.</p>
<p>In our case, <code>makeHtml</code> is a function that takes <strong>one</strong> string argument,
and returns a <strong>function</strong>. <em>The function it returns</em> takes a string argument
as well and finally returns a string.</p>
<p>The magic here is that <code>-&gt;</code> is right associative.</p>
<p>When we write:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; String -&gt; String
</code></pre>
<p>Haskell parses it as:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; (String -&gt; String)
</code></pre>
<p>Consecuently, the expression <code>makeHtml &quot;My title&quot;</code> is also a function!
One that will take a string (the content) and will return the expected
html string with &quot;My title&quot; in the title.</p>
<p>This is called <strong>partial application</strong>.</p>
<p>To illustrate, let's define <code>html_</code> and <code>body_</code> in a different way by
defining a new function, <code>el</code>.</p>
<pre><code class="language-hs">el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>el is a function that takes a tag and content, and wraps the content
with the tag.</p>
<p>We can now implement <code>html_</code> and <code>body_</code> by partially applying <code>el</code> and
only provide the tag.</p>
<pre><code class="language-hs">html_ :: String -&gt; String
html_ = el &quot;html&quot;

body_ :: String -&gt; String
body_ = el &quot;body&quot;
</code></pre>
<p>Note that we didn't need to add the argument on the left side of
equals sign because Haskell functions are &quot;<strong>first class</strong>&quot; - they behave
exactly like normal expressions. You can define names to them like
regular values, put them in data structures, pass them to functions,
everything you can do with regular values like <code>Int</code> or <code>String</code>.</p>
<p>The way Haskell treats names is very similar to copy paste. anywhere
you see <code>html_</code> in the code, you can replace it with <code>el &quot;html&quot;</code>. They are
the same (this is what the equals signs say, right? That the two sides
are the same). This property, of behind able to <em>substitute</em> the two sides of the
equals sign with one another, is called <strong>referential transparency</strong>. And
it is pretty unique to Haskell (and a few language that are very
similar to it like PureScript and Elm)!</p>
<h3 id="anonymouslambda-functions"><a class="header" href="#anonymouslambda-functions">Anonymous/lambda functions</a></h3>
<p>To further drive the point that Haskell functions are first class and
all functions take exactly one argument,
I'll mention that the syntax we've been using up until
now to define function is just syntactic sugar! We can also define
<strong>anonymous functions</strong> - functions without a name, anywhere we'd like.
anonymous functions are also known as <strong>lambda functions</strong>.
This is a tribute to the original, most primitive
functional programming language - the lambda calculus.</p>
<p>We can create an anonymous function anywhere we'd expect an expression
such as <code>&quot;hello&quot;</code> with the following syntax:</p>
<pre><code class="language-hs">\&lt;argument&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>This little <code>\</code> (which bears some resemblance to the lowercase greek letter lambda 'λ')
marks the head of the lambda function,
and the arrow (<code>-&gt;</code>) marks the beginning of the body of the function.
We can even chain lambda, making them &quot;multiple argument functions&quot; by
defining another lambda in the body for another, like this:</p>
<pre><code class="language-hs">three = (\num1 -&gt; \num2 -&gt; num1 + num2) 1 2
</code></pre>
<p>Just as before, we evaluate functions by substituting the function argument with
the applied value. In the example above we subtitute <code>num1</code> with <code>1</code>, and get
<code>(\num2 -&gt; 1 + num2) 2</code>. Then subtitute <code>num2</code> with <code>2</code> and get <code>1 + 2</code>.
We'll talk more about substitution later.</p>
<p>So, when we write:</p>
<pre><code class="language-hs">el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>Haskell actually translates this under the hood to:</p>
<pre><code class="language-hs">el :: String -&gt; (String -&gt; String)
el = \tag -&gt; \content -&gt;
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>Hopefully this form makes it a bit clearer why Haskell functions
always take one argument and return another, even when we have
syntactic sugar that might suggest otherwise.</p>
<p>I'll mention one more syntactic sugar for anonymous functions:
We don't actually have to write multiple argument anonymous functions
this way, we can just write: </p>
<pre><code class="language-hs">\&lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>to save us some trouble. For example:</p>
<pre><code class="language-hs">three = (\num1 num2 -&gt; num1 + num2) 1 2
</code></pre>
<p>But it's worth remembering what they are under the hood.</p>
<p>We won't be needing anonymous/lambda functions at this point,
but we'll talk more about them later and see where they can be useful.</p>
<hr />
<p>Exercises:</p>
<ol>
<li>
<p>Add types for all of the functions we created until now</p>
</li>
<li>
<p>Change the implementation of the html functions we built to use <code>el</code> instead</p>
</li>
<li>
<p>Add a couple more functions for defining paragraphs and headers:</p>
<ol>
<li><code>p_</code> which uses the tag <code>&lt;p&gt;</code> for paragraphs</li>
<li><code>h1_</code> which uses the tag <code>&lt;h1&gt;</code> for headers</li>
</ol>
</li>
<li>
<p>Replace our <code>Hello, world!</code> string with richer content, use <code>h1_</code> and <code>p_</code>.
We can append html strings created by <code>h1_</code> and <code>p_</code> using the append operator <code>&lt;&gt;</code>.</p>
</li>
</ol>
<hr />
<p>Solutions:</p>
<details>
  <summary>Solution for exercise #1</summary>
<pre><code class="language-hs">myhtml :: String
myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;

makeHtml :: String -&gt; String -&gt; String
makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ :: String -&gt; String
html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ :: String -&gt; String
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;

head_ :: String -&gt; String
head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ :: String -&gt; String
title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #2</summary>
<pre><code class="language-hs">html_ :: String -&gt; String
html_ = el &quot;html&quot;
   
body_ :: String -&gt; String
body_ = el &quot;body&quot;

head_ :: String -&gt; String
head_ = el &quot;head&quot;

title_ :: String -&gt; String
title_ = el &quot;title&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #3</summary>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;

h1_ :: String -&gt; String
h1_ = el &quot;h1&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #4</summary>
<pre><code class="language-hs">myhtml :: String
myhtml =
  makeHtml
    &quot;Hello title&quot;
    (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)
</code></pre>
</details>
<hr />
<details>
  <summary>Our final program</summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn myhtml

myhtml :: String
myhtml =
  makeHtml
    &quot;Hello title&quot;
    (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)


makeHtml :: String -&gt; String -&gt; String
makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ :: String -&gt; String
html_ = el &quot;html&quot;
   
body_ :: String -&gt; String
body_ = el &quot;body&quot;

head_ :: String -&gt; String
head_ = el &quot;head&quot;

title_ :: String -&gt; String
title_ = el &quot;title&quot;

p_ :: String -&gt; String
p_ = el &quot;p&quot;

h1_ :: String -&gt; String
h1_ = el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-domain-specific-languages"><a class="header" href="#embedded-domain-specific-languages">Embedded Domain Specific Languages</a></h1>
<p>Right out of the bat we run into a common pattern in Haskell: creating
Embedded Domain Specific Languages (EDSLs for short).</p>
<p>Domain specific languages (DSLs) are specialized programming languages that are
tailored to specific domains. In contrast of general purpose languages,
which try to work well in many domains.</p>
<p>A few examples of DSLs are:</p>
<ul>
<li>make - for defining build systems</li>
<li>DOT - for defining graphs</li>
<li>Sed - for defining text transformations</li>
<li>CSS - for defining styling</li>
<li>HTML - for defining web pages</li>
</ul>
<p>An <em>embedded</em> domain specific language is a little language which is
embedded inside another programming language, making the
a program written in the EDSL a valid program in the language it was written in.</p>
<p>The little HTML library we've been writing can be considered an EDSL.
It is used specifically for building web pages (by returning html strings),
and is valid Haskell code!</p>
<p>In Haskell we frequently create and use EDSLs to express domains specific
logic. We have EDSLs for concurrency, command-line options parsing, JSON and HTML,
Creating build systems, writing tests, and many more.</p>
<p>Specialized languages are useful because they can solve specific problems in
a concise (and often safe) way, and embedding them in general purpose programming
languages provides us to use the full power of the language for our domain logic,
including syntax highlighting and various tools available for the language.</p>
<p>The drawback of embedding domain specific languages is that we have to adhere
the rules of the programming language we embed in, such as syntactic and semantic rules.</p>
<p>Some languages alleviate this drawback by providing meta-programming capabilities
in the form of macros or other features. And while Haskell does provide such
capabilities as well, it is also expressive and concise enough that many EDSLs
do not need them.</p>
<p>Instead, many Haskell EDSLs use a pattern called <em>the combinator pattern</em>:
They define <em>primitives</em> and <em>combinators</em> -
primitives are basic building blocks of the language,
and combinators are functions that combine primitives to more complex structures.</p>
<p>In our HTML EDSL, our primitives are functions such as <code>html_</code> and <code>title_</code>
that can be used to create a single HTML node, and we pass other
constructed nodes as input to these functions, and combine them to a more complex
structure with the append function <code>&lt;&gt;</code>.</p>
<p>There are still a few tricks we can use to make our HTML EDSL better:</p>
<ol>
<li>
<p>We can use Haskell's type system to make sure we only construct <em>valid</em>
HTML (so for example we don't create a <code>&lt;title&gt;</code> node
without a <code>&lt;head&gt;</code> node, or have user content that 
can include unscaped special characters),
and throw a type error when the user tries to do something invalid.</p>
</li>
<li>
<p>We can improve the syntactic structure of the language so it
looks like it is rendered using lists.</p>
</li>
<li>
<p>Our HTML EDSL can move to its own module so it can be reused in multiple modules</p>
</li>
</ol>
<p>In the next few sections we'll take a look at how to define our own types and
how to work with modules to make it harder to make errors, and a little bit
about linked lists in Haskell.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safer-html-construction-with-types"><a class="header" href="#safer-html-construction-with-types">Safer HTML construction with types</a></h1>
<p>In this section we'll learn how to create our own distinguished types
for HTML, and how they can help us avoid invalid construction of HTML strings.</p>
<p>There are a few ways of defining new types in Haskell, in this section
we are going to meet two ways: <code>newtype</code> and <code>type</code>.</p>
<h2 id="newtype"><a class="header" href="#newtype"><code>newtype</code></a></h2>
<p><code>newtype</code> lets us give a new name to an already existing type in a
way that the two cannot mix together.</p>
<p>A <code>newtype</code> declaration looks like this:</p>
<pre><code class="language-hs">newtype &lt;type-name&gt; = &lt;constructor&gt; &lt;existing-type&gt;
</code></pre>
<p>For example in our case we can define a distinct type for <code>Html</code> like this:</p>
<pre><code class="language-hs">newtype Html = Html String
</code></pre>
<p>The first <code>Html</code>, to the left of the equals sign, lives in the <em>types</em>
namespace, meaning that you will only see that name to the right of a
double-colon sign (<code>::</code>).</p>
<p>The second <code>Html</code> lives in the <em>expressions</em> (or terms/values) namespace,
meaning that you will see it where you expect expressions (we'll touch where
exactly that can be in a moment).</p>
<p>The two names, <code>&lt;type-name&gt;</code> and <code>&lt;constructor&gt;</code>, do not have to be the
same, but they often are. And note that both have to start with a
capital letter.</p>
<p>The right-hand side of the newtype declaration describes how an
expression of that type looks like. In our case, we expect a value of
type <code>Html</code> to have the constructor <code>Html</code> and then an expression of
type string, for example: <code>Html &quot;hello&quot;</code> or <code>Html (&quot;hello &quot; &lt;&gt; &quot;world&quot;)</code>.</p>
<p>You can think of the constructor as a function that takes the argument
and returns something of our new type:</p>
<pre><code class="language-hs">Html :: String -&gt; Html
</code></pre>
<p><strong>Note</strong>: We cannot use an expression of type <code>Html</code> the same way we'd
use a <code>String</code>. so <code>&quot;hello &quot; &lt;&gt; Html &quot;world&quot;</code> would fail at type
checking.</p>
<p>This is useful when we want <em>encapsulation</em>. We can define and use
existing representation and functions for our underlying type, but not
mix them with other, unrelated (to our domain) types. Similar as
meters and feet can both be numbers, but we don't want to accidently
add feets to meters without any conversion.</p>
<p>To get this actually working well, we'll need a bit more than just
newtypes. In the next chapter we'll introduce modules and smart constructors.</p>
<p>For now, let's create a couple of types for our use case.
We want two separate types to represent:</p>
<ol>
<li>A complete Html document</li>
<li>A type for nodes that can go inside the <body> tag</li>
</ol>
<p>We want them to be distinct because we don't want to mix them together.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">newtype Html = Html String

newtype HtmlStructure = HtmlStructure String
</code></pre>
</details>
<h2 id="type"><a class="header" href="#type"><code>type</code></a></h2>
<p>A <code>type</code> definition looks really similar - the only difference is that
we have no constructor:</p>
<pre><code class="language-hs">type &lt;type-name&gt; = &lt;existing-type&gt;
</code></pre>
<p>For example in our case we can write:</p>
<pre><code class="language-hs">type HtmlTitle = String
</code></pre>
<p><code>type</code>, on the other hand, is just a name alias. so <code>HtmlTitle</code>
and <code>String</code> are interchangeable. We can use <code>type</code>s
to give a bit more clarity to our code.</p>
<h2 id="using-newtypes"><a class="header" href="#using-newtypes">Using <code>newtype</code>s</a></h2>
<p>Back to <code>newtype</code>s. So how can we use the underlying type? We first
need to extract it out of the type. We do this using pattern matching.</p>
<p>Pattern matching can be used in two ways, in case expressions and in
function definitions.</p>
<ol>
<li>case expressions are kinda beefed up switch expressions and look like this:</li>
</ol>
<pre><code class="language-hs">case &lt;expression&gt; of
  &lt;pattern&gt; -&gt; &lt;expression&gt;
  ...
  &lt;pattern&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>The <code>&lt;expression&gt;</code> is the thing we want to unpack, and the <code>pattern</code>
is it's concrete shape. For example:</p>
<pre><code class="language-hs">getHtmlStructureString :: HtmlStructure -&gt; String
getHtmlStructureString myhbc =
  case myhbc of
    HtmlStructure str -&gt; str
</code></pre>
<p>This way we can extract the String out of <code>HtmlStructure</code> and return
it.</p>
<p>In later commits we'll introduce <code>data</code> declarations (which are kind of
a struct + enum chimera), where we can define multiple constructors to
a type. Then the multiple patterns of a case expression will make more
sense.</p>
<ol start="2">
<li>Alternatively, when declaring a function, we can also use pattern matching on the
arguments:</li>
</ol>
<pre><code class="language-hs">func &lt;pattern&gt; = &lt;expression&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">getHtmlStructureString :: HtmlStructure -&gt; String
getHtmlStructureString (HtmlStructure str) = str
</code></pre>
<p>Using the types we created, we can change the html functions we defined before,
namely <code>html_</code>, <code>body_</code>, <code>p_</code>, etc, to operate on these types instead of <code>String</code>s.</p>
<p>But first let's meet another operator that will make our code more concise.</p>
<h2 id="chaining-functions"><a class="header" href="#chaining-functions">Chaining functions</a></h2>
<p>Another interesting and extremely common operator
(which is a regular library function in Haskell) is <code>.</code> (pronounced compose).
This operator was made to look like the composition operator
you may know from math (<code>∘</code>).</p>
<p>Let's look at its type and implementation:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(.) f g x = f (g x)
</code></pre>
<p>Compose takes 3 arguments: two functions (named <code>f</code> and <code>g</code> here) and
a third argument named <code>x</code>. It then passes the argument <code>x</code> to the second
function <code>g</code>, and calls the first function <code>f</code> with the result of <code>g x</code>.</p>
<p>Note that <code>g</code> takes as input something of the type
<code>a</code> and returns something of the type <code>b</code>, and <code>f</code> takes
something of the type <code>b</code>, and returns something of the type <code>c</code>.</p>
<p>Another important thing to note is that types which start with
a <em>lowercase letter</em> are <strong>type variables</strong>.
Think of them as similar to regular variables. Just like
<code>content</code> could be any string, like <code>&quot;hello&quot;</code> or <code>&quot;world&quot;</code>, a type variable
can be any type: <code>Bool</code>, <code>String</code>, <code>String -&gt; String</code>, etc.</p>
<p>The catch is that type variables must match in a signature, so if for
example we write a function with the type signature <code>a -&gt; a</code>, the
input type and the return type <strong>must</strong> match, but it could be
any type - we cannot know what it is. So the only way to implement a
function with that signature is:</p>
<pre><code class="language-hs">mysteryFunction :: a -&gt; a
mysteryFunction x = x
</code></pre>
<p>If we tried any other way, for example returning some made up value
like <code>&quot;hello&quot;</code>, or try to use <code>x</code> like a value of a type we know like
writing <code>x + x</code>, the type checker will complain.</p>
<p>Also, remember that <code>-&gt;</code> is right associative? This signature is equivalent to:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>Doesn't it look like a function that takes two functions and returns a
third function that is the composition of the two?</p>
<p>We can now use this operator to change or html functions. Let's start
with one example: <code>p_</code>.</p>
<p>Before, we had:</p>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;
</code></pre>
<p>And now, we can write:</p>
<pre><code class="language-hs">p_ :: String -&gt; HtmlStructure
p_ = HtmlStructure . el &quot;p&quot;
</code></pre>
<p>The function <code>p_</code> will take an arbitrary <code>String</code> which is the content
of the paragraph we wish to create, will wrap it in <code>&lt;p&gt;</code> tags,
and then wrap it in the <code>HtmlStructure</code> constructor - producing the
output type <code>HtmlStructure</code>.</p>
<p>Let's take a deeper look and see what are the types of the two
functions here are:</p>
<ul>
<li><code>HtmlStructure :: String -&gt; HtmlStructure</code></li>
<li><code>el &quot;p&quot; :: String -&gt; String</code></li>
<li><code>HtmlStructure . el &quot;p&quot; :: String -&gt; HtmlStructure</code></li>
<li><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></li>
</ul>
<p>When we try to figure out if an expression type check, we try to match
the types and see if they work. If they are the same type, all is
well. If one of them is a type variable and the other isn't we write
down that the type variable should now be the concrete type, and see
if everything still works.</p>
<p>So in our case we know from the type signature that the input type to
the function <code>String</code> and the output type is <code>HtmlStructure</code>, this
means:</p>
<ol>
<li><code>a</code> is equivalent to <code>String</code> (we write <code>~</code> to denote equivalence), and</li>
<li><code>c ~ HtmlStructure</code></li>
</ol>
<p>We also know that:</p>
<ol start="3">
<li><code>b ~ String</code> because we pass <code>HtmlStructure</code> to <code>.</code> as the first arguments, which means</li>
<li><code>String -&gt; HtmlStructure</code> must
match with the type of the first argument of <code>.</code> which is <code>b -&gt; c</code>, so</li>
<li><code>b ~ String</code> which fits with our previous knowledge from (3)</li>
<li><code>-&gt; ~ -&gt;</code></li>
<li><code>c ~ HtmlStructure</code> which also fits with (2)</li>
</ol>
<p>We keep doing this process until we come to the conclusion that there
aren't any types that don't match (we don't have two different
concrete types that are supposed to be equivalent).</p>
<h2 id="appending-htmlstructure"><a class="header" href="#appending-htmlstructure">Appending HtmlStructure</a></h2>
<p>Before when we wanted to create richer html content and appended
nodes to one another, we used the append (<code>&lt;&gt;</code>) operator.
Since we are now not using <code>String</code> anymore, we need another way
to do it.</p>
<p>While it is possible to overload <code>&lt;&gt;</code> using a feature in
Haskell called type classes, we will instead create a new function
and call it <code>append_</code>, and cover type classes later.</p>
<p><code>append_</code> should take two <code>HtmlStructure</code>s, and return a third <code>HtmlStructure</code>,
appending the inner <code>String</code> in the first <code>HtmlStructure</code> to the second and wrapping the result back in <code>HtmlStructure</code>.</p>
<p>Try implementing <code>append_</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">append_ :: HtmlStructure -&gt; HtmlStructure -&gt; HtmlStructure
append_ (HtmlStructure a) (HtmlStructure b) =
  HtmlStructure (a &lt;&gt; b)
</code></pre>
</details>
<h2 id="converting-back-an-html-to-string"><a class="header" href="#converting-back-an-html-to-string">Converting back an <code>Html</code> to <code>String</code></a></h2>
<p>After constructing a valid <code>Html</code> value, we want to be able to
print it to the output so we can display it in our browser.
For that, we need to write a function that takes an <code>Html</code> and converts it to a <code>String</code>, which we can then pass to <code>putStrLn</code>.</p>
<p>Implement the <code>render</code> function.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<h2 id="the-rest-of-the-owl"><a class="header" href="#the-rest-of-the-owl">The rest of the owl</a></h2>
<p>Try changing the code we wrote in previous chapters to use the new types we created.</p>
<p><strong>Tips</strong>: we can combine <code>makeHtml</code> and <code>html_</code>, and remove <code>body_</code> <code>head_</code> and <code>title_</code>
by calling <code>el</code> directly in <code>html_</code>, which can now have the type <code>HtmlTitle -&gt; HtmlStructure -&gt; Html</code>. This will make our html EDSL less flexible but more compact.</p>
<p>We could, alternatively, create newtypes for <code>HtmlHead</code> and <code>HtmlBody</code> and
pass those to <code>html_</code>, and there is value in doing that, but I've chose
to keep the API a bit simple for now, we can always refactor later!</p>
<details>
  <summary> <b>Solution</b> </summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Header&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )

newtype Html
  = Html String

newtype HtmlStructure
  = HtmlStructure String

type HtmlTitle
  = String

html_ :: HtmlTitle -&gt; HtmlStructure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getHtmlStructureString content)
      )
    )

p_ :: String -&gt; HtmlStructure
p_ = HtmlStructure . el &quot;p&quot;

h1_ :: String -&gt; HtmlStructure
h1_ = HtmlStructure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: HtmlStructure -&gt; HtmlStructure -&gt; HtmlStructure
append_ c1 c2 =
  HtmlStructure (getHtmlStructureString c1 &lt;&gt; getHtmlStructureString c2)

getHtmlStructureString :: HtmlStructure -&gt; String
getHtmlStructureString content =
  case content of
    HtmlStructure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<p>All of this is nice and fun. And indeed now we can't write <code>&quot;Hello&quot;</code>
where we'd expect either a paragraph or a header, but we can still
write <code>HtmlStructure &quot;hello&quot;</code> and get something that isn't a
paragraph or a header. Next we'll see how we can make this illegal as
well using modules and smart constructors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preventing-incorrect-use-with-modules"><a class="header" href="#preventing-incorrect-use-with-modules">Preventing incorrect use with modules</a></h1>
<p>In this section we will move the Html generation library to its own module.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Each Haskell source file is a module. The module name should have the
same name as the source file and should start with a capital
letter. Sub-directories should also be part of the name and we use <code>.</code>
do denote a sub-directory. We'll see that in the next section.</p>
<p>The only exception to the rule are entry points to the program -
modules with the name 'Main' that define <code>main</code> in them. Their source
file names could have any name they want.</p>
<p>A module declaration looks like this:</p>
<pre><code class="language-hs">module &lt;module-name&gt;
  ( &lt;export-list&gt;
  )
where
</code></pre>
<p>The export list can be omitted if you want to export everything
defined in the module, but we don't. We will list exactly the
functions and type we want to export.</p>
<p>We will create a new source file named <code>Html.hs</code> and add the following
module declaration code at the top of the file:</p>
<pre><code class="language-hs">module Html
  ( Html
  , HtmlTitle
  , HtmlStructure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where
</code></pre>
<p>Note that we do not export:</p>
<ol>
<li>
<p>the constructors for our new types, only the types themselves.
If we wanted to export the constructors as well we would've written
<code>Html(Html)</code> or <code>Html(..)</code>. This way the user cannot create their own
<code>HtmlStructure</code> simply by writing <code>HtmlStructure &quot;Hello&quot;</code>.</p>
</li>
<li>
<p>Internal functions used by the library, such as <code>el</code> and <code>getHtmlStructureString</code>.</p>
</li>
</ol>
<p>And we will also move the html related functions from our <code>hello.hs</code> file
to this new <code>Html.hs</code> file:</p>
<pre><code class="language-hs">newtype Html
  = Html String

newtype HtmlStructure
  = HtmlStructure String

type HtmlTitle
  = String

html_ :: HtmlTitle -&gt; HtmlStructure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getHtmlStructureString content)
      )
    )

p_ :: String -&gt; HtmlStructure
p_ = HtmlStructure . el &quot;p&quot;

h1_ :: String -&gt; HtmlStructure
h1_ = HtmlStructure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: HtmlStructure -&gt; HtmlStructure -&gt; HtmlStructure
append_ c1 c2 =
  HtmlStructure (getHtmlStructureString c1 &lt;&gt; getHtmlStructureString c2)

getHtmlStructureString :: HtmlStructure -&gt; String
getHtmlStructureString content =
  case content of
    HtmlStructure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
<p>Now, anyone importing our module (using the <code>import</code> statement which
can be used below module declarations but above any other
declaration), will only be able to import what we export.</p>
<p>Add the following code at the top of the <code>hello.hs</code> file:</p>
<pre><code class="language-hs">import Html
</code></pre>
<p>The <code>hello.hs</code> file should now look like this:</p>
<pre><code class="language-hs">-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Header&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )
</code></pre>
<p>And the <code>Html.hs</code> file should look like this:</p>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , HtmlTitle
  , HtmlStructure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where

newtype Html
  = Html String

newtype HtmlStructure
  = HtmlStructure String

type HtmlTitle
  = String

html_ :: HtmlTitle -&gt; HtmlStructure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getHtmlStructureString content)
      )
    )

p_ :: String -&gt; HtmlStructure
p_ = HtmlStructure . el &quot;p&quot;

h1_ :: String -&gt; HtmlStructure
h1_ = HtmlStructure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: HtmlStructure -&gt; HtmlStructure -&gt; HtmlStructure
append_ c1 c2 =
  HtmlStructure (getHtmlStructureString c1 &lt;&gt; getHtmlStructureString c2)

getHtmlStructureString :: HtmlStructure -&gt; String
getHtmlStructureString content =
  case content of
    HtmlStructure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escaping-characters"><a class="header" href="#escaping-characters">Escaping characters</a></h1>
<p>Now that <code>Html</code> has its own source file and module, and creating
html code can be done only via the functions we exported,
we can also handle user input that may contain characters we
that may conflict with our meta language html,
such as <code>&lt;</code> and <code>&gt;</code> which are used for creating HTML tags.</p>
<p>We can convert these characters into different strings that HTML can handle.</p>
<p>See <a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html">https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html</a>
for a list of characters we need to escape.</p>
<p>Let's create a new function called <code>escape</code>:</p>
<pre><code class="language-hs">escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
<p>In <code>escape</code> we see a few new things:</p>
<ol>
<li>let expressions - we can define local names using this syntax:</li>
</ol>
<pre><code class="language-hs">let
  &lt;name&gt; = &lt;expression&gt;
in
  &lt;expression&gt;
</code></pre>
<p>This will make <name> available as a variable in the second <expression>.</p>
<ol start="2">
<li>
<p>Pattern matching with multiple patterns - we match on different
characters and convert them to a string. Note that <code>_</code> is a &quot;catch
all&quot; pattern that will always succeed.</p>
</li>
<li>
<p>Two new functions: <code>map</code> and <code>concat</code>, we'll talk about these more in depth</p>
</li>
</ol>
<h2 id="linked-lists-briefly"><a class="header" href="#linked-lists-briefly">Linked lists briefly</a></h2>
<p>Linked lists are a very common data structure in Haskell, so common that
they have their own special syntax:</p>
<ol>
<li>The type for lists are denoted with brackets and inside them is the type of the element. For example:
<ul>
<li><code>[Int]</code> - a list of integers</li>
<li><code>[Char]</code> - a list of characters</li>
<li><code>[String]</code> - a list of strings</li>
<li><code>[[String]]</code> - a list of a list of strings</li>
</ul>
</li>
<li>An expression representing a empty list is written like this: <code>[]</code></li>
<li>Prepending an element to a list is done with the operator <code>:</code> (pronounced cons) which is right-associative (like <code>-&gt;</code>).
For example: <code>1 : []</code>, or <code>1 : 2 : 3 : []</code>.</li>
<li>The above lists can also be written like this: <code>[1]</code> and <code>[1, 2, 3]</code>.</li>
</ol>
<p>Also, Strings are linked lists of chararacters - String is defined as:
<code>type String = [Char]</code>, so we can use them the same way we use lists.</p>
<hr />
<p>Do note, however, that linked lists, despite their convenience, are often
not the right tool for the job. They are not particularily space efficient
and are slow for appending, random access and more. That also makes <code>String</code>
a lot less efficient than it could be. And I generally recommend using a
different string type, <code>Text</code>, instead, which is available in an external package.
We will talk about lists, <code>Text</code>, and other data structures in the future!</p>
<hr />
<p>We can implement our own operations on lists by using pattern matching and recursion.
And we'll touch on this subject later when talking about ADTs.</p>
<p>For now, we will use the various functions found in the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html">Data.List</a> module. Specifically, <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:map">map</a> and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:concat">concat</a>.</p>
<p><code>map</code> applying a function to each of the elements in a list. Its type signature is:</p>
<pre><code class="language-hs">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">map not [False, True, False] == [True, False, True]
</code></pre>
<p>Or as can be seen in our <code>escape</code> function, this can help us escape each character:</p>
<pre><code class="language-hs">map escapeChar ['&lt;','h','1','&gt;'] == [&quot;&amp;lt;&quot;,&quot;h&quot;,&quot;1&quot;,&quot;&amp;gt;&quot;]
</code></pre>
<p>However, note that the <code>escapeChar</code> has the type <code>Char -&gt; String</code>,
so the result type of <code>map escapeChar ['&lt;','h','1','&gt;']</code> is <code>[String]</code>,
and what we really want is a <code>String</code> and not <code>[String]</code>.</p>
<p>This is where <code>concat</code> enters the picture. <code>concat</code> has the type</p>
<pre><code class="language-hs">concat :: [[a]] -&gt; [a]
</code></pre>
<p>It flattens a list of list of something into a list of something.
In our case in will flatten <code>[String]</code> into <code>String</code>, remember that this works
because <code>String</code> is a <strong>type alias</strong> for <code>[Char]</code>, so we actually have
<code>[[Char]] -&gt; [Char]</code>.</p>
<hr />
<h2 id="escaping"><a class="header" href="#escaping">Escaping</a></h2>
<p>The user of our library can currently only supply strings in a few places:</p>
<ol>
<li>Page title</li>
<li>Paragraphs</li>
<li>Headers</li>
</ol>
<p>We can apply our escape function at these places before doing anything else with it.
That way all html constructions are safe.</p>
<p>Try adding the escaping function in those places.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">html_ :: HtmlTitle -&gt; HtmlStructure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getHtmlStructureString content)
      )
    )

p_ :: String -&gt; HtmlStructure
p_ = HtmlStructure . el &quot;p&quot; . escape

h1_ :: String -&gt; HtmlStructure
h1_ = HtmlStructure . el &quot;h1&quot; . escape
</code></pre>
</details>
<hr />
<details>
  <summary><b>Our revised Html.hs</b></summary>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , HtmlTitle
  , HtmlStructure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where

-- * Types

newtype Html
  = Html String

newtype HtmlStructure
  = HtmlStructure String

type HtmlTitle
  = String

-- * EDSL

html_ :: HtmlTitle -&gt; HtmlStructure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getHtmlStructureString content)
      )
    )

p_ :: String -&gt; HtmlStructure
p_ = HtmlStructure . el &quot;p&quot; . escape

h1_ :: String -&gt; HtmlStructure
h1_ = HtmlStructure . el &quot;h1&quot; . escape

append_ :: HtmlStructure -&gt; HtmlStructure -&gt; HtmlStructure
append_ c1 c2 =
  HtmlStructure (getHtmlStructureString c1 &lt;&gt; getHtmlStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getHtmlStructureString :: HtmlStructure -&gt; String
getHtmlStructureString content =
  case content of
    HtmlStructure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
</details>
<p>Trying constructing an invalid html in <code>hello.hs</code> to see if this works or not!</p>
<p>Now we can use our tiny html library safely. But what if the user
wants to use our library with something we didn't think about, for
example adding unordered lists? We are completely blocking them from
extending our library. We'll talk about this next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exposing-internal-functionality-internal-modules"><a class="header" href="#exposing-internal-functionality-internal-modules">Exposing internal functionality (Internal modules)</a></h1>
<p>When a user runs into trouble with using a library the best course of
actions usually are to open an issue in the repository or submit a pull
request, but sometimes the user needs things to work <em>now</em>.</p>
<p>We admit that we are not perfect and can't think of all use cases for our
library. Sometimes the restrictions we add are too great and may limit
the usage of advanced users that know how things work under the hood and
need certain functionality to present in our library.</p>
<p>For that we can expose internal modules to provide some flexibility for
advanced users. Internal modules are not a language concept but
rather a (fairly common) design pattern in Haskell.</p>
<p>Internal modules are simply modules named <code>Internal</code>.
These modules are considered risky to use by convention.
Internal modules will export all of the functionality in a
module, and we will add another module without the <code>Internal</code> suffix
which will import from our internal module and only export the api
we'd like to export.</p>
<p>Internal modules should be considered unstable and risky to use. If
you end up using one, make sure to open a ticket in the library after
the storm has passed!</p>
<p>We will create a new directory named <code>Html</code> and inside it a new file
named <code>Internal.hs</code>. The name of this module should be <code>Html.Internal</code>.</p>
<p>This module will contain all of the code that was previously in the <code>Html</code>
module, but <strong>we will change the module declaration in <code>Html.Internal</code>
and <em>omit</em> the export list</strong>:</p>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

...
</code></pre>
<p>And now in <code>Html.hs</code>, we will remove the code that we moved to <code>Html/Internal.hs</code>
and in its stead we'll import the internal module:</p>
<pre><code class="language-hs">-- Hello.hs

module Html
  ( Html
  , HtmlTitle
  , HtmlStructure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where
</code></pre>
<p>Now, users of our library can still import <code>Html</code> and safely use our library,
but if they run into trouble and have a dire need to implement unordered lists
to work with our library, they could always work with <code>Html.Internal</code> instead.</p>
<details>
  <summary><b>Our revised Html.hs and Html/Internal.hs</b></summary>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , HtmlTitle
  , HtmlStructure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where

import Html.Internal
</code></pre>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype HtmlStructure
  = HtmlStructure String

type HtmlTitle
  = String

-- * EDSL

html_ :: HtmlTitle -&gt; HtmlStructure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getHtmlStructureString content)
      )
    )

p_ :: String -&gt; HtmlStructure
p_ = HtmlStructure . el &quot;p&quot; . escape

h1_ :: String -&gt; HtmlStructure
h1_ = HtmlStructure . el &quot;h1&quot; . escape

append_ :: HtmlStructure -&gt; HtmlStructure -&gt; HtmlStructure
append_ c1 c2 =
  HtmlStructure (getHtmlStructureString c1 &lt;&gt; getHtmlStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getHtmlStructureString :: HtmlStructure -&gt; String
getHtmlStructureString content =
  case content of
    HtmlStructure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>We need a few more features for our html library to be useful for
our blog software. Add the following features to our <code>Html.Internal</code> module
and expose them from <code>Html</code>.</p>
<h2 id="1-unordered-lists"><a class="header" href="#1-unordered-lists">1. Unordered lists</a></h2>
<p>These lists have the form:</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>We want in our library a new function:</p>
<pre><code class="language-hs">ul_ :: [HtmlStructure] -&gt; HtmlStructure
</code></pre>
<p>So that users can write this:</p>
<pre><code class="language-hs">ul_
  [ p_ &quot;item 1&quot;
  , p_ &quot;item 2&quot;
  , p_ &quot;item 3&quot;
  ]
</code></pre>
<p>and get this:</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;item 1&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;item 2&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;item 3&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h2 id="2-ordered-lists"><a class="header" href="#2-ordered-lists">2. Ordered lists</a></h2>
<p>Very similar to unordered lists, but instead of <code>&lt;ul&gt;</code> we use <code>&lt;ol&gt;</code></p>
<h2 id="3-code-blocks"><a class="header" href="#3-code-blocks">3. Code blocks</a></h2>
<p>Very similar to <code>&lt;p&gt;</code>, but use the <code>&lt;pre&gt;</code> tag. Call this function <code>code_</code>.</p>
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<details>
  <summary>Unordered lists</summary>
<pre><code class="language-hs">ul_ :: [HtmlStructure] -&gt; HtmlStructure
ul_ =
  HtmlStructure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getHtmlStructureString)
</code></pre>
</details>
<details>
  <summary>Ordered lists</summary>
<pre><code class="language-hs">ol_ :: [HtmlStructure] -&gt; HtmlStructure
ol_ =
  HtmlStructure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getHtmlStructureString)
</code></pre>
<p>Note: the two functions above could be unified.</p>
</details>
<details>
  <summary>Code blocks</summary>
<pre><code class="language-hs">code_ :: String -&gt; HtmlStructure
code_ = HtmlStructure . el &quot;pre&quot;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>In this chapter we built a very minimal HTML EDSL.
We will later use this library to convert our custom markup formatted text to HTML.</p>
<p>We've also learned about:</p>
<ul>
<li>Defining and using functions</li>
<li>Types and type signatures</li>
<li>Embedded domain specific languages</li>
<li>Chaining functions using the <code>.</code> operator</li>
<li>Preventing incorrect use with <code>newtype</code>s</li>
<li>Defining modules and the <code>Internal</code> module pattern</li>
<li>Encapsulation using <code>newtype</code>s and modules</li>
</ul>
<p>Here's our complete program up to this point:</p>
<pre><code class="language-hs">-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Header&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )
</code></pre>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , HtmlTitle
  , HtmlStructure
  , html_
  , h1_
  , p_
  , ul_
  , ol_
  , code_
  , append_
  , render
  )
where

import Html.Internal
</code></pre>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype HtmlStructure
  = HtmlStructure String

type HtmlTitle
  = String

-- * EDSL

html_ :: HtmlTitle -&gt; HtmlStructure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getHtmlStructureString content)
      )
    )

p_ :: String -&gt; HtmlStructure
p_ = HtmlStructure . el &quot;p&quot; . escape

h1_ :: String -&gt; HtmlStructure
h1_ = HtmlStructure . el &quot;h1&quot; . escape

ul_ :: [HtmlStructure] -&gt; HtmlStructure
ul_ =
  HtmlStructure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getHtmlStructureString)

ol_ :: [HtmlStructure] -&gt; HtmlStructure
ol_ =
  HtmlStructure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getHtmlStructureString)

code_ :: String -&gt; HtmlStructure
code_ = HtmlStructure . el &quot;pre&quot;

append_ :: HtmlStructure -&gt; HtmlStructure -&gt; HtmlStructure
append_ c1 c2 =
  HtmlStructure (getHtmlStructureString c1 &lt;&gt; getHtmlStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getHtmlStructureString :: HtmlStructure -&gt; String
getHtmlStructureString content =
  case content of
    HtmlStructure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-markup-language"><a class="header" href="#custom-markup-language">Custom markup language</a></h1>
<p>In this chapter we will define our own simple markup language
and parse documents written in this language into Haskell data structures.</p>
<p>Our simple markup language will contain the following features:</p>
<ul>
<li>Headers - prefix by a number of <code>*</code> characters</li>
<li>Paragraphs - a group of lines without empty lines in between</li>
<li>Unordered lists - a group of lines each prefixed with <code>- </code></li>
<li>Unordered lists - a group of lines each prefixed with <code># </code></li>
<li>Code blocks - a group of lines each prefixed with <code>&gt; </code></li>
</ul>
<p>Here's a sample document which we will use as an example:</p>
<pre><code class="language-org">* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; ➜ ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main, or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
</code></pre>
<p>Which we will, eventually, want to convert into this (modulo formatting) html:</p>
<pre><code class="language-html">&lt;h1&gt;Compiling programs with ghc&lt;/h1&gt;

&lt;p&gt;Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.
&lt;/p&gt;

&lt;p&gt;Create a new Haskell source file named hello.hs, and write
the following code in it:
&lt;/p&gt;

&lt;pre&gt;main = putStrLn &quot;Hello, Haskell!&quot;
&lt;/pre&gt;

&lt;p&gt;Now, we can compile the program by invoking ghc with the file name:&lt;/p&gt;

&lt;pre&gt;
➜ ghc hello.hs
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...
&lt;/pre&gt;

&lt;p&gt;GHC created the following files:
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hello.hi - Haskell interface file&lt;/li&gt;
  &lt;li&gt;hello.o - Object file, the output of the compiler before linking&lt;/li&gt;
  &lt;li&gt;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GHC will produce an executable when the source file satisfies both conditions:
&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Defines the main function in the source file&lt;/li&gt;
  &lt;li&gt;Defines the module name to be Main, or does not have a module declaration&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Otherwise, it will only produce the .o and .hi files.
&lt;/p&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="representing-the-markup-language-as-a-haskell-data-type"><a class="header" href="#representing-the-markup-language-as-a-haskell-data-type">Representing the markup language as a Haskell data type</a></h1>
<p>One of the clear differentiators between Haskell and other ML-family of languages
from most mainstream languages is the ability to represent data precisely and succinctly.</p>
<p>So how do we represent our markup language using Haskell?</p>
<p>Previously, in our HTML builder library, we used <code>newtype</code>s to differentiate
between html documents, structures and titles, but we didn't really need to
differentiate between different kinds of structures such as paragraphs and headers,
not without parsing the data at least.</p>
<p>In this case, we have a list of structures, and each structure could be
one of a few specific options (a paragraph, a header, a list, etc),
and we want to be able to know which structure is which so we can easily
convert it into the equivalent HTML representation.</p>
<p>For that, we have <code>data</code> definitions. <code>data</code> gives us the ability to
create custom types by grouping multiple types together and having
alternative structures. Think of them as combination of both structs and enums.</p>
<p><code>data</code> declarations look like this:</p>
<pre><code class="language-hs">data &lt;Type-name&gt; &lt;type-args&gt;
  = &lt;Data-constructor1&gt; &lt;types&gt;
  | &lt;Data-constructor2&gt; &lt;types&gt;
  | ...
</code></pre>
<p>It looks really similar to <code>newtype</code>, but there are two important
differences:</p>
<ol>
<li>In the <types> part we can write many types (Like <code>Int</code>, <code>String</code>, or <code>Bool</code>).
For <code>newtype</code>s we can only write one.</li>
<li>We can have alternative structures using <code>|</code>, <code>newtype</code>s have no
alternatives.</li>
</ol>
<p>This is because <code>newtype</code>s is used to provide a type safe <strong>alias</strong>,  and <code>data</code>
is used to build a new <strong>composite</strong> type that can potentially have <em>alternatives</em>.</p>
<p>Let's see a couple of examples of data types:</p>
<ol>
<li>
<p>Bool</p>
<pre><code class="language-hs">data Bool
  = True
  | False
</code></pre>
<p>We created a new data type named <code>Bool</code> with the possible values <code>True</code> or <code>False</code>.
In this case we only have <em>constructor</em> alternatives and none of the alternatives
carriers additional values, this is similar to enums in other languages.</p>
</li>
<li>
<p>Person</p>
<pre><code class="language-hs">data Person
  = Person String Int -- where the first is the name and the second is
                      -- the age
</code></pre>
<p>We created a new data type named <code>Person</code>. Values of the type <code>Person</code>
look like this:</p>
<pre><code>Person &lt;some-string&gt; &lt;some-int&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">Person &quot;Gil&quot; 32
</code></pre>
<p>In this case we create a <em>composite</em> of multiple types, without alternatives.
This is similar to structs in other language, but structs give each field
a name, and here we distinguish them by position.</p>
<p>Alternatively, Haskell has <em>syntactic sugar</em> for naming fields called <strong>records</strong>.
The above definition can also be written like this:</p>
<pre><code class="language-hs">data Person
  = Person
    { name :: String
	, age :: Int
	}
</code></pre>
<p>Values of this type can be written exactly as before,</p>
<pre><code class="language-hs">Person &quot;Gil&quot; 32
</code></pre>
<p>Or with this syntax:</p>
<pre><code class="language-hs">Person { name = &quot;Gil&quot;, age = 32 }
</code></pre>
<p>Haskell will also generate functions that can be used to extract the fields from the composite type:</p>
<pre><code class="language-hs">name :: Person -&gt; String
age :: Person -&gt; Int
</code></pre>
<p>Which can be used like this:</p>
<pre><code class="language-hs">ghci&gt; age (Person { name = &quot;Gil&quot;, age = 32 })
32
</code></pre>
<p>Unfortunately, this also means that if we defined a different data type with the field
<code>age</code>, the functions which GHC needs to generate will clash.</p>
<p>The easiest way to solve this is to give fields unique names, for example
by adding a prefix:</p>
<pre><code class="language-hs">data Person
  = Person
    { pName :: String
	, pAge :: Int
	}
</code></pre>
<p>Another way is by using extensions to the Haskell language, which we will cover
in later chapters.</p>
</li>
<li>
<p>Tuple</p>
<pre><code class="language-hs">data Tuple a b
  = Tuple a b
</code></pre>
<p>This is pretty similar to <code>Person</code>, but we can plug any type we want
for this definition. For example:</p>
<pre><code class="language-hs">Tuple &quot;Clicked&quot; True :: Tuple String Bool

Tuple 'a' 'z' :: Tuple Char Char
</code></pre>
<p>This type has special syntax in Haskell:</p>
<pre><code class="language-hs">(&quot;Clicked&quot;, True) :: (String, Bool)

('a', 'z') :: (Char, Char)
</code></pre>
<p>This <code>Tuple</code> definition is polymorphic, we define the structure but are able to
plug different types into the structure to get concerete types. This about <code>Tuple</code>
as just a <em>template</em> for a data type waiting to be filled, or as a <em>function</em> waiting
for types as input in order to return a data type.</p>
</li>
<li>
<p>Either</p>
<pre><code class="language-hs">data Either a b
  = Left a
  | Right b
</code></pre>
<p>Similar to Tuple but instead of having only one constructor, we have
two. This means that we can choose which side we want. Here are a
couple of Values of type <code>Either String Int</code>:</p>
<pre><code class="language-hs">Left &quot;Hello&quot;

Right 17
</code></pre>
<p>This type is useful for modeling errors. Either we succeeded and got
what we wanted (The <code>Right</code> constructor with the value), or we didn't
and got an error instead (The <code>Left</code> constructor with a string or a
custom error type).</p>
</li>
</ol>
<p>Here we use it to model the different kinds of content types we have
in our markup language. We tag each structure using the data constructor
and provide the rest of the information (the paragraph text, the list items, etc)
in the <code>&lt;types&gt;</code> section of the data declaration for each constructor:</p>
<pre><code class="language-hs">type Document
  = [Structure]

data Structure
  = Header Int String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
</code></pre>
<hr />
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<p>Represent the following markup documents as value of <code>Document</code>:</p>
<ol>
<li>
<pre><code class="language-org">Hello, world!
</code></pre>
</li>
<li>
<pre><code class="language-org">* Welcome

To this tutorial about Haskell.
</code></pre>
</li>
<li>
<pre><code class="language-org">Remember that multiple lines with no separation
are grouped together to a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
</code></pre>
</li>
<li>
<pre><code class="language-org">* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; ➜ ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main, or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
</code></pre>
</li>
</ol>
<p>Solutions:</p>
<details>
  <summary>Solution 1</summary>
<pre><code class="language-hs">doc :: Document
doc =
  [ Paragraph &quot;Hello, world!&quot;
  ]
</code></pre>
</details>
<details>
  <summary>Solution 2</summary>
<pre><code class="language-hs">doc :: Document
doc =
  [ Header 1 &quot;Welcome&quot;
  , Paragraph &quot;To this tutorial about Haskell.&quot;
  ]
</code></pre>
</details>
<details>
  <summary>Solution 3</summary>
<pre><code class="language-hs">doc :: Document
doc =
  [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot;
  , OrderedList
    [ &quot;Item 1 of a list&quot;
    , &quot;Item 2 of the same list&quot;
    ]
  ]
</code></pre>
</details>
<details>
  <summary>Solution 4</summary>
<pre><code class="language-hs">doc :: Document
doc =
  [ Header 1 &quot;Compiling programs with ghc&quot;
  , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot;
  , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot;
  , CodeBlock
    [ &quot;main = putStrLn \&quot;Hello, Haskell!\&quot;&quot;
    ]
  , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot;
  , CodeBlock
    [ &quot;➜ ghc hello.hs&quot;
    , &quot;[1 of 1] Compiling Main             ( hello.hs, hello.o )&quot;
    , &quot;Linking hello ...&quot;
    ]
  , Paragraph &quot;GHC created the following files:&quot;
  , UnorderedList
    [ &quot;hello.hi - Haskell interface file&quot;
    , &quot;hello.o - Object file, the output of the compiler before linking&quot;
    , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot;
    ]
  , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot;
  , OrderedList
    [ &quot;Defines the main function in the source file&quot;
    , &quot;Defines the module name to be Main, or does not have a module declaration&quot;
    ]
  , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot;
  ]
</code></pre>
</details>
<p>Add a new module named <code>Markup</code> and add the data type definition to it.
Note that in this case we <em>do</em> want to export the constructors of <code>Structure</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  )
where

type Document
  = [Structure]

data Structure
  = Header Int String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
</code></pre>
</details>
<hr />
<p>You might ask &quot;Why do we even need to represent the markup as a type?
Why don't we convert it into html as soon as we parse it
instead?&quot;. That's a good question and a valid strategy. The reason we
first represent it as a Haskell type is for flexibility and
modularity.</p>
<p>If the parsing code is coupled with html generation, we lose the
ability to preprocess the markup document. For example we might want
to take only a small part of the document (for summary) and present
it, or create a table of content from headers. Or maybe we'd like to
add other targets and not just html - maybe markdown format or a gui reader?</p>
<p>Parsing to an &quot;abstract data type&quot; (ADT) representation (one that does
not contain the details of the language, that for example that we use '#' for
ordered lists) gives us the freedom to do so much more than just
converting to html that it's usually worth it in my opinion unless you
really need to optimize the process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-markup-part-01-recursion"><a class="header" href="#parsing-markup-part-01-recursion">Parsing markup part 01 (Recursion)</a></h1>
<p>Let's have a look at how to parse a multi-lined string of markup text
written by a user and convert it to the <code>Document</code> type we defined
in the previous chapter.</p>
<p>Our strategy is to take the string of markup text, and:</p>
<ol>
<li>Split it to a list where each element is a separate line, and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>So the first thing we want to do is to process the string line by line.
We can do that by converting the string to a list of string.
Fortunately the Haskell
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>Prelude</code></a>
module from the Haskell standard library
<a href="https://hackage.haskell.org/package/base"><code>base</code></a> exposes the function
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>lines</code></a>
that does exactly what we want. The <code>Prelude</code> module is exposed in every
Haskell file by default so we don't need to import it.</p>
<p>For the line processing part, let's start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<p>A common solution in imperative programs would be to iterate over the lines
using some <em>loop</em> construct and accumulate lines that should be grouped together
into some intermediate mutable variable. When we reach an empty line, we insert
the content of that variable into another mutable variable that accumulates the
results.</p>
<p>Our approach in Haskell isn't so different, except that we do not use loops
or mutable variables. Instead, we use <strong>recursion</strong>.</p>
<h2 id="recursion-and-accumulating-information"><a class="header" href="#recursion-and-accumulating-information">Recursion and accumulating information</a></h2>
<p>Instead of loops, in Haskell we use recursion to model iteration.</p>
<p>Consider the following contrived example: let's say that
we want to write an algorithm for adding two natural numbers together,
and we don't have a standard operation to do that (+), but we do
have two operations we could do for each number: <code>increment</code>
and <code>decrement</code>.</p>
<p>A solution we could come up with is to slowly &quot;pass&quot; one number
to the other number iteratively, by incrementing one, and decrementing the other.
And we do that until the number we decrement reaches 0.</p>
<p>For example for <code>3</code> and <code>2</code>:</p>
<ul>
<li>We start with <code>3</code> and <code>2</code>, and we increment <code>3</code> and decrement <code>2</code></li>
<li>On the next step we now have <code>4</code> and <code>1</code>, we increment <code>4</code> and decrement <code>1</code></li>
<li>On the next step we now have <code>5</code> and <code>0</code>, since the second number is <code>0</code> we declare <code>5</code> as the result.</li>
</ul>
<p>This can be written imperatively using a loop:</p>
<pre><code class="language-js">function sum(n, m) {
    while (m /= 0) {
        n = increment(n);
        m = decrement(m);
    }
    return n;
}
</code></pre>
<p>We can write the same algorithm in Haskell without mutation using recursion:</p>
<pre><code class="language-hs">sum n m =
    if m /= 0
        then sum (increment n) (decrement m)
        else n
</code></pre>
<p><strong>In order to emulate iteration with mutable state, we call the function again
with the values we want the variables to have in the next iteration.</strong></p>
<h3 id="evaluation-of-recursion"><a class="header" href="#evaluation-of-recursion">Evaluation of recursion</a></h3>
<p>Recursion commonly has a bad reputation for being slow and possibly unsafe compared to loops.
This is because in imperative languages, calling a function often requires creating
a new call stack.</p>
<p>However, functional languages (and Haskell in particular) play by different
rules and implement a feature called tail call elimination - when the result of a function call
is the result of this function (this is called tail position), we can just drop the current function
stack frame and then allocate one for the function we call, so we don't require <code>N</code> stack frames
for <code>N</code> iterations.</p>
<p>This is of course only one way to do tail call elimination and other
strategies exists, such as translating code like our recursive <code>sum</code> above to the iteration version.</p>
<h4 id="laziness"><a class="header" href="#laziness">Laziness</a></h4>
<p>Haskell plays by slightly different rules because it uses a lazy evaluation strategy
instead of the much more common strict evaluation strategy. An evaluation strategy
refers to &quot;when do we evaluate a computation&quot;. In a strict language the answer is simple:
<em>we evaluate the arguments of a function before entering a function</em>.</p>
<p>So for example the evaluation of <code>sum (increment 3) (decrement 2)</code> using strict evaluation
will look like this:</p>
<ol>
<li>Evaluate <code>increment 3</code> to <code>4</code></li>
<li>Evaluate <code>decrement 2</code> to <code>1</code></li>
<li>Evaluate <code>sum 4 1</code></li>
</ol>
<p>Or, alternatively (depending on the language) we reverse (1) and (2) and evaluate the arguments
from right-to-left instead of left-to-right.</p>
<p>On the other hand, with lazy evaluation, we <em>only evaluate computation when we need it</em>, where
'<em>when do we need it?</em>' is when it is part of a computation that will have some effect on the
outside world, for example when writing a computation to standard output or sending it over the network.</p>
<p>So unless this computation is required, it won't be evaluated. For example:</p>
<pre><code class="language-hs">main =
    if sum (increment 2) (decrement 3) == 5
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p>In the case above, we need the result of <code>sum (increment 2) (decrement 3)</code>
in order to know which message to write,
so it will be evaluated. But:</p>
<pre><code class="language-hs">main =
    let
        five = sum (increment 2) (decrement 3)
    in
        putStrLn &quot;Not required&quot;
</code></pre>
<p>In the case above we don't actually need <code>five</code>, so we don't evaluate it!</p>
<p>But then if we know we need <code>sum (increment 2) (decrement 3)</code>,
do we use strict evaluation now? The answer is no - because we might not need
them to complete the computation. For example in this case:</p>
<pre><code class="language-hs">const a b = a

main =
    if const (increment 2) (decrement 3) == 3
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p><code>const</code> ignores the second argument and returns the first, so we don't actually need
to calculate <code>decrement 3</code> in order to provide an answer to the computation and in
turn output an answer to the screen.</p>
<p>So in lazy evaluation we will evaluate expressions when we need to (they are required
in order to do something for the user), and we evaluate from the outside in - first
we enter functions, and then we evaluate the arguments when we need to (usually when the thing
we want to evaluate appears in some control flow such as the condition of an <code>if</code> expression
or a pattern in pattern matching).</p>
<hr />
<p>I've written a more in-depth blog post about how this works in Haskell:
<a href="https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning">Substitution and Equational Reasoning</a>.</p>
<p>Please read it and try to evalute the following program by hand:</p>
<pre><code class="language-hs">import Prelude hiding (const, sum) -- feel free to ignore this line

increment n = n + 1

decrement n = n - 1

const a b = a

sum n m =
    if m /= 0
        then sum (increment n) (decrement m)
        else n

main =
    if const (sum 3 2) (decrement 3) == 5
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p>Remember that evaluation always begins from <code>main</code>.</p>
<details>
  <summary>Solution</summary>
<p>evaluating <code>main</code></p>
<pre><code class="language-hs">if const (sum 3 2) (decrement 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>const</code></p>
<pre><code class="language-hs">if sum 3 2 == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>sum</code></p>
<pre><code class="language-hs">if (if 2 /= 0 then sum (increment 3) (decrement 2) else 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>evaluating the control flow <code>2 /= 0</code></p>
<pre><code class="language-hs">if (if True then sum (increment 3) (decrement 2) else 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if (sum (increment 3) (decrement 2)) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>sum</code></p>
<pre><code class="language-hs">if
    ( if decrement 2 /= 0
        then sum
            (increment (increment 3))
            (decrement (decrement 2))
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating <code>decrement 2</code> in the control flow (notice how both places change!)</p>
<pre><code class="language-hs">if
    ( if 1 /= 0
        then sum
            (increment (increment 3))
            (decrement 1)
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating the control flow <code>1 /= 0</code></p>
<pre><code class="language-hs">if
    ( if True
        then sum
            (increment (increment 3))
            (decrement 1)
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if
    ( sum
        (increment (increment 3))
        (decrement 1)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Expanding <code>sum</code></p>
<pre><code class="language-hs">if
    ( if decrement 1 /= 0
        then sum
            (increment (increment (increment 3)))
            (decrement (decrement 1))
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>decrement 1</code></p>
<pre><code class="language-hs">if
    ( if 0 /= 0
        then sum
            (increment (increment (increment 3)))
            (decrement 0)
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>0 /= 0</code></p>
<pre><code class="language-hs">if
    ( if False
        then sum
            (increment (increment (increment 3)))
            (decrement 0)
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>else</code> branch</p>
<pre><code class="language-hs">if
    (increment (increment 3)) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate control flow <code>increment (increment 3)</code></p>
<pre><code class="language-hs">if
    (increment 3 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>increment 3</code></p>
<pre><code class="language-hs">if
    (3 + 1 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>3 + 1</code></p>
<pre><code class="language-hs">if
    (4 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>4 + 1</code></p>
<pre><code class="language-hs">if
    5 == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>5 == 5</code></p>
<pre><code class="language-hs">if
    True
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">putStrLn &quot;Yes.&quot;
</code></pre>
<p>Which when run will print <code>Yes.</code> to the screen.</p>
</details>
<hr />
<h3 id="general-recursion"><a class="header" href="#general-recursion">General recursion</a></h3>
<p>In general, when trying to solve problems recursively, it is useful to think
about the problem in three parts:</p>
<ol>
<li>Finding the <strong>base case</strong> (the most simple cases - the ones I already know how to answer)</li>
<li>Figuring out how to <strong>reduce</strong> the problem to something simpler (so it gets closer to the base case)</li>
<li><strong>Mitigating the difference</strong> between the reduced version and the solution I need to provide</li>
</ol>
<p>The reduce and mitigate steps together are usually called the recursive step.</p>
<p>Let's take a look at another example problem: generating a list of a particular size
with a specific value in place of every element.</p>
<p>In Haskell, this function would have the following signature:</p>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
</code></pre>
<p>Here are a few examples using in:</p>
<pre><code class="language-hs">ghci&gt; replicate 4 True
[True,True,True,True]
ghci&gt; replicate 0 True
[]
ghci&gt; replicate (-13) True
[]
</code></pre>
<p>How would we implement this function recursively? How would describe it in three steps above?</p>
<ol>
<li><strong>Base case</strong>: the cases I already know how to generate are the cases where the length
of the list is zero (or less) - we just return an empty list.</li>
<li><strong>Reduce</strong>: while I don't know how to generate a list of size <code>N</code> (where <code>N</code> is positive),
if I knew the solution for <code>N-1</code> I could:</li>
<li><strong>Mitigate</strong>: Add another element to the solution for <code>N-1</code> using the <code>:</code> (cons) operator.</li>
</ol>
<p>Try to write this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
replicate n x =
    if n &lt;= 0        -- recognizing the base case
        then
            []       -- the solution for the base case
        else
            x : replicate (n - 1) x
    --      --- -------------------
    --       ^           ^
    --       |           |
    --       |           +-------- reduction
    --       |
    --       +--- mitigation
</code></pre>
</details>
<h3 id="mutual-recursion"><a class="header" href="#mutual-recursion">Mutual recursion</a></h3>
<p>When solving functions recursively we usually call the same function again,
but that doesn't have to be the case. It is possible to reduce our problem
to something simpler that requires an answer from a different function.
If, in turn, that function will (or another function in that call chain)
call our function again, we have a <strong>mutual recursive</strong> solution.</p>
<p>For example, let's write two functions, one that checks whether a natural number
is even or not, and one that checks whether a number is odd or not
by only decrementing it.</p>
<pre><code class="language-hs">even :: Int -&gt; Bool

odd :: Int -&gt; Bool
</code></pre>
<p>Let's start with <code>even</code>, how should we solve this recursively?</p>
<ol>
<li><strong>Base case</strong>: I know the answer for <code>0</code> - it is <code>True</code>.</li>
<li><strong>Reduction</strong>: I don't know the answer for a general <code>N</code>, but I could check whether <code>N - 1</code> is odd,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is odd, then <code>N</code> is even! if it isn't odd, then <code>N</code> isn't even.</li>
</ol>
<p>What about <code>odd</code>?</p>
<ol>
<li><strong>Base case</strong>: I know the answer for <code>0</code> - it is <code>False</code>.</li>
<li><strong>Reduction</strong>: I don't know the answer for a general <code>N</code>, but I could check whether <code>N - 1</code> is even,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is even, then <code>N</code> is odd! if it isn't even, then <code>N</code> isn't odd.</li>
</ol>
<p>Try writing this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">even :: Int -&gt; Bool
even n =
    if n == 0
        then
            True
        else
            odd (n - 1)

odd :: Int -&gt; Bool
odd n =
    if n == 0
        then
            False
        else
            even (n - 1)

</code></pre>
</details>
<h2 id="partial-functions"><a class="header" href="#partial-functions">Partial functions</a></h2>
<p>because we didn't handle negative cases in the example above, our functions will loop forever
when a negative value is passed as input. A function that does not return a result for some value
(either by not terminating or by throwing an error) is called <strong>a partial function</strong>
(because it only returns a result of a part of the possible inputs).</p>
<p>partial functions are generally considered <strong>bad practice</strong> because they can have
unexpected behaviour at runtime, so we want to <strong>avoid using</strong> partial functions
as well as <strong>avoid writing</strong> partial functions.</p>
<p>The best way to avoid writing partial functions is by covering all inputs!
In the situation above, it is definitely possible to handle negative numbers
as well, so we should do that!</p>
<p>There are cases where we can't possibly cover all inputs, but it is sometimes
possible to mitigate that by restricting the inputs further using the type system.</p>
<p>For example, the <code>head :: [a] -&gt; a</code> function in <code>Prelude</code> promises
to return the first element (the head) of a list, but we know that lists
could possibly be empty, so how can this function deliver on its promise?</p>
<p>Unfortunately, it can't. But there exists a different function that can:
<code>head :: NonEmpty a -&gt; a</code> from the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List-NonEmpty.html"><code>Data.List.NonEmpty</code></a>
module! The trick here is that this other <code>head</code> does not take a general list
as input, it takes a different type entirely, one that promises to have
at least one element, and therefore can deliver on its promise!</p>
<p>We could also potentially use smart constructors with <code>newtype</code> and enforce some sort
of a restriction in the type system, as we saw in earlier chapters.
But this solution can sometimes be less ergonomic to use.</p>
<p>An alternative approach is to use <code>data</code> types to encode the absence of a proper result,
for example, using <code>Maybe</code>, as we'll see in a future chapter.</p>
<h2 id="parsing-markup"><a class="header" href="#parsing-markup">Parsing markup?</a></h2>
<p>Let's get back to the task at hand.</p>
<p>As stated previously, our strategy for parsing the markup text is:</p>
<ol>
<li>Split the string to a list where each element is a separate line (which we can do with <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>lines</code></a>), and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>Remember that we want to start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines -- (1)

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)
  in
    case txts of
      [] -&gt; [paragraph]
      currentLine : rest -&gt;
        if trim currentLine == &quot;&quot;
          then
            paragraph : parseLines [] rest -- (4)
          else
            parseLines (currentLine : currentParagraph) rest -- (5)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Things to note:</p>
<ol>
<li>We pass a list that contains the currently grouped paragraph (paragraphs are seperated by an empty line)</li>
<li>Because of laziness, <code>paragraph</code> is not computed until it's needed, so we don't have to worry about
the performance implications in the case the we are still grouping lines</li>
<li>Why do we reverse <code>currentParagraph</code>? (See point (5))</li>
<li>When we run into an empty line we add the accumulated paragraph to the resulting list (A <code>Document</code> is a list of structures) and start the function again with the rest of the input.</li>
<li>We pass the new lines to be grouped in a paragraph <strong>in reverse order</strong> because of
performance characteristics - because of the nature of singly-linked lists,
prepending an element is fast, and appending is slow. Prepending only requires
us to create a new cons (<code>:</code>) cell to hold a pointer to the value and a pointer to the list,
but appending requires us to traverse the list to its end and rebuild the cons cells -
the last one will contain the last value of the list and a pointer to the list to append,
the next will contain the value before the last value of the list and a pointer to the
list which contains the last element and the appended list, and so on.</li>
</ol>
<p>This code above will group together paragraphs in a structure, but how do we view our result?
In the next chapter will take a short detour and talk a bit about type classes, and how
they can help us in this scenario.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="displaying-the-parsing-results-typeclasses"><a class="header" href="#displaying-the-parsing-results-typeclasses">Displaying the parsing results (typeclasses)</a></h1>
<p>We want to be able to print a textual representation of values
of our <code>Document</code> type. There are a few ways to do that:</p>
<ol>
<li>Write our own function of type <code>Document -&gt; String</code> which we could then print, or</li>
<li>Have Haskell write one for us</li>
</ol>
<p>Haskell provides us with mechanism that can automatically generates the implementation of a
<em>typeclass</em> function called <code>show</code>, that will convert our type to <code>String</code>.</p>
<p>The type of the function <code>show</code> looks like this:</p>
<pre><code class="language-hs">show :: Show a =&gt; a -&gt; String
</code></pre>
<p>This is something new we haven't seen before. Between <code>::</code> and <code>=&gt;</code>
you see what is called a <strong>type class constraint</strong> on the type <code>a</code>. What
we say in this signature, is that the function <code>show</code> can work on any
type that is a member of the type class <code>Show</code>.</p>
<p>Type classes is a feature in Haskell that allows us to declare common
interface for different types. In our case, Haskell's standard library
defines the type class <code>Show</code> in the following (this is a simplified
version but good enough for our purposes):</p>
<pre><code class="language-hs">class Show a where
  show :: a -&gt; String
</code></pre>
<p>This means that we have now declared a common interface for Haskell
types that want it. Any time that wants to implement it needs to
define an <em>instance</em> for the type class. For example:</p>
<pre><code class="language-hs">instance Show Bool where
  show x =
    case x of
      True -&gt; &quot;True&quot;
      False -&gt; &quot;False&quot;
</code></pre>
<p>If all the types we use while defining our data type already implement
this, we can automatically derive it by adding <code>deriving Show</code> at the
end of the data definition.</p>
<pre><code class="language-hs">data Structure
  = Header Int String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving Show
</code></pre>
<p>Now we can use the function <code>show :: Show a =&gt; a -&gt; String</code> for any
type that implements an instance of the <code>Show</code> typeclass. For example, with print:</p>
<pre><code class="language-hs">print :: Show a =&gt; a -&gt; IO ()
print = putStrLn . show
</code></pre>
<p>We can first convert our type to <code>String</code> and then write it to the
standard output.</p>
<p>And because lists also implement <code>Show</code> for any element type that has
a <code>Show</code> instance, we can now print <code>Document</code>s, because they are just
aliases for <code>[Structure]</code>. Try it!</p>
<p>There are many type classes Haskellers use everyday. A couple more are
<code>Eq</code> for equality and <code>Ord</code> for ordering.</p>
<p>Typeclasses often come with &quot;rules&quot; or &quot;laws&quot; that instances should satisfy,
the purpose of these laws is to provide <em>predictable behaviour</em> across
instances, so that when we run into a new instance we can be confident
that it will behave in a certain expected way.</p>
<p>As an example, let's look at the <code>Semigroup</code> typeclass:</p>
<pre><code class="language-hs">class Semigroup a where
  (&lt;&gt;) :: a -&gt; a -&gt; a
</code></pre>
<p>This typeclass provides a common interface for types with an operation <code>&lt;&gt;</code>
that can combine two values into one in some way.</p>
<p>This typeclass also mentions that this <code>&lt;&gt;</code> operation should be associative,
meaning that these two sides should evaluate to the same result:</p>
<pre><code>x &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z
</code></pre>
<p>An example of a lawful instance of <code>Semigroup</code> is lists with the append operation (<code>++</code>):</p>
<pre><code class="language-hs">instance Semigroup [a] where
  (&lt;&gt;) = (++)
</code></pre>
<p>Unfortunately the Haskell type system cannot &quot;prove&quot; that instances
satisfy these laws, but as a community we often shun unlawful instances.</p>
<p>Many data types (together with their respective operations) can
form a <code>Semigroup</code> (or any other type class), and instances
don't even have to look similar or have a common analogy/metaphor.</p>
<p><strong>Type classes are often just <em>interfaces</em> with <em>laws</em></strong> (or expected behaviour if you will).
Approaching them with this mindset can be very liberating!</p>
<p>We have <a href="04-markup/02_04-safer_construction.html#appending-htmlstructure">previously</a>
created a function that looks like this for our <code>Html</code> EDSL!
We can add a <code>Semigroup</code> instance for our <code>HtmlStructure</code> data type
and have a nicer to use API!</p>
<p>Exercise: Please do this and remove the <code>append_</code> function from the API.</p>
<details>
  <summary>Solution</summary>
<p>Replace this:</p>
<pre><code class="language-hs">append_ :: HtmlStructure -&gt; HtmlStructure -&gt; HtmlStructure
append_ c1 c2 =
  HtmlStructure (getHtmlStructureString c1 &lt;&gt; getHtmlStructureString c2)
</code></pre>
<p>With this:</p>
<pre><code class="language-hs">instance Semigroup HtmlStructure where
  (&lt;&gt;) c1 c2 =
    HtmlStructure (getHtmlStructureString c1 &lt;&gt; getHtmlStructureString c2)
</code></pre>
<p>And remove the export of <code>append_</code> in <code>Html.hs</code>. You won't need to further export anything
as type class instances are exported automatically.</p>
<p>You will also need replace the usage of <code>append_</code> with <code>&lt;&gt;</code> in <code>hello.hs</code>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-markup-part-02-pattern-matching"><a class="header" href="#parsing-markup-part-02-pattern-matching">Parsing markup part 02 (Pattern matching)</a></h1>
<h2 id="maybe"><a class="header" href="#maybe">Maybe</a></h2>
<p>Previously, when we talked about partial functions, we mentioned that one way to avoid
writing partial functions is encode the absence of a result using <code>Maybe</code>:</p>
<pre><code class="language-hs">data Maybe a
    = Nothing
    | Just a
</code></pre>
<p><code>Maybe</code> is a data type from the standard library (named <a href="https://hackage.haskell.org/package/base">base</a>)
that is used to add an additional value to a type: the absence of a value.
For example, <code>Maybe Bool</code> has three values,
two with the <code>Just</code> constructor to represent regular boolean values
(<code>Just True</code> and <code>Just False</code>) and another value, <code>Nothing</code> to represent
the absence of a boolean value.</p>
<p>We can use this to encode the result of <code>head</code>, a function the promises to return
the first element of a list, without creating a partial function:</p>
<pre><code class="language-hs">head :: [a] -&gt; Maybe a
</code></pre>
<p>This way, when the list is empty, we can return <code>Nothing</code>, and when it has at least
one element, we can return <code>Just &lt;first element&gt;</code>. This function can be found in
the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Maybe.html">Data.Maybe</a>
module under the name
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Maybe.html#v:listToMaybe">listToMaybe</a>.</p>
<p>In order to consume values of type <code>Maybe &lt;something&gt;</code>, and other types created with
<code>data</code>, we can use pattern matching.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>We've already seen pattern matching a few times.
It is an incredibly versatile feature of Haskell, we can use it to do two things main things:</p>
<ol>
<li>Deconstruct complex values</li>
<li>Control flow</li>
</ol>
<p>As we've seen when discussing
<a href="https://soupi.github.io/learn-haskell-blog-generator/03-html/03_04-safer_construction.html#using-newtypes">newtypes</a>,
we can use <strong>case expressions</strong> and <strong>function definitions</strong> to deconstruct a <code>newtype</code>,
but we can do that for <code>data</code> types as well:</p>
<pre><code class="language-hs">-- | A data type representing colors
data Color
  = RGB Word8 Word8 Word8

getBluePart :: Color -&gt; Word8
getBluePart color =
  case color of
    RGB _ _ blue -&gt; blue
</code></pre>
<p>In <code>getBluePart</code> we deconstruct a composite value into it's part and extract the third component
representing the blue value in a color represented by red, green and blue components (RGB).</p>
<p>Note that <code>blue</code> is the name we give to the third component so it will be bound
to the right of the arrow that comes after the pattern. This is similar to
a function argument. Also note that <code>_</code> matches any value <em>without</em> binding it to a name.</p>
<p>We can also try to match a value with more than one pattern:</p>
<pre><code class="language-hs">data Brightness
  = Dark
  | Bright

data EightColor
  = Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White

data AnsiColor
  = AnsiColor Brightness EightColor

ansiColorToVGA :: AnsiColor -&gt; RGB
ansiColorToVGA ansicolor =
  case ansicolor of
    AnsiColor Dark Black -&gt;
      RGB 0 0 0
    AnsiColor Bright Black -&gt;
      RGB 85 85 85
    AnsiColor Dark Red -&gt;
      RGB 170 0 0
    AnsiColor Bright Red -&gt;
      RGB 255 85 85
    -- and so on
</code></pre>
<p>It's important to notice a few things here:</p>
<ol>
<li>Patterns can be nested, notice how we deconstructed <code>ansicolor</code> on multiple levels</li>
<li>We try to match patterns from the top down, it is possible for patterns to overlap with one another and the top one will win</li>
<li>If the value we try to match does not match any of the patterns listed, an error will be thrown at runtime</li>
</ol>
<p>We can ask GHC to notify when we accidentally written overlapping patterns,
or when we haven't listed enough patterns to match all possible values,
by passing the flag <code>-Wall</code> to <code>ghc</code> or <code>runghc</code>!</p>
<p><strong>My recommendation is to always use -Wall!</strong></p>
<p>As an aside, while it is possible to use pattern matching in function definitions by defining a function
multiple types, <a href="https://twitter.com/_gilmi/status/1257225601079029760">I personally don't like that feature very much</a>, but if you want to use it instead of case expressions, it is possible.</p>
<p>Exercises:</p>
<ol>
<li>Create a function <code>isBright :: AnsiColor -&gt; Bool</code> that checks whether a color is bright or not</li>
<li>Use <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit">this table</a> to write <code>ansiToUbuntu</code>.</li>
<li>Create a function <code>isEmpty :: [a] -&gt; Bool</code> that uses <code>listToMaybe</code> to check whether a list is empty or not</li>
<li>Create a function <code>isEmpty :: [a] -&gt; Bool</code> that <em>doesn't</em> use <code>listToMaybe</code> to check whether a list is empty or not</li>
</ol>
<h2 id="parsing-with-rich-context"><a class="header" href="#parsing-with-rich-context">Parsing with rich context</a></h2>
<p>Previously we wrote a parser that separates documents into different paragraphs.
With new features under our belt we can now remember the exact context we are in
(whether it is a text paragraph, a list, or a code block) and act accordingly!</p>
<p>Let's look again at the parsing code we wrote previously:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines -- (1)

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)
  in
    case txts of
      [] -&gt; [paragraph]
      currentLine : rest -&gt;
        if trim currentLine == &quot;&quot;
          then
            paragraph : parseLines [] rest -- (4)
          else
            parseLines (currentLine : currentParagraph) rest -- (5)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Previously our context, <code>currentParagraph</code>, was used to group adjacent lines in an accumulative list.</p>
<p>Next, instead of using a <code>[String]</code> type to denote adjacent lines, we can instead use a <code>Structure</code> to denote the context.</p>
<p>One issue we might have though with representing context with the <code>Structure</code> type,
is that when we start parsing we don't have any context.
But we learn of a way to represent the possibility of an absence of a value with <code>Maybe</code>! So our new context type can be <code>Maybe Structure</code> instead.</p>
<p>Let's rewrite our code above to use our new context type:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines Nothing . lines -- (1)

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    [] -&gt; maybeToList context   -- (2)
    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest) -- (3)
          else
            case context of
              Nothing -&gt;
                parseLines (Just (Paragraph line)) rest
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4), (5)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<ol>
<li>
<p>We can now pass <code>Nothing</code> when we don't have a context</p>
</li>
<li>
<p>Unsure what <code>maybeToList</code> does? <a href="https://hoogle.haskell.org">Hoogle</a> it!</p>
</li>
<li>
<p><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:maybe">maybe</a> is a function that works similarily to pattern matching on a <code>Maybe</code>.
Check out the types of <code>id</code>, <code>(:)</code> and <code>maybe id (:)</code> in ghci!</p>
</li>
<li>
<p>Hey! Didn't we say that appending <code>String</code>s/lists is slow (which is what <code>unwords</code> does)? Yes, it is.
Because in our <code>Structure</code> data type, a paragraph is defined as <code>Paragraph String</code> and not <code>Paragraph [String]</code>,
we can't use our trick of building a list of lines and the reverse it at the end.</p>
<p>So what do we do?
There are many ways to handle that, one simple way is to create a different type with the right shape:</p>
<pre><code class="language-hs">data Context
  = CtxHeader Int String
  | CtxParagraph [String]
  | CtxUnorderedList [String]
  | CtxOrderedList [String]
  | CtxCodeBlock [String]
</code></pre>
<p>Since creating new types in Haskell is cheap, this is a very viable solution.
With more complex type-level features we can even create a more general type that can be used in both place,
both as a <code>Structure</code> and as a <code>Context</code>, don't worry about it for now, really. (but if one day you really need to do this, search for &quot;Higher-Kinded Data&quot; (or HKD pattern)).</p>
<p>In this case I'm going with the approach of not worrying about it too much, because it's a very local code that can easily be fixed later if and when we see it is an issue.</p>
</li>
<li>
<p>Anyway, if you've used <code>-Wall</code> like I've suggested, you'd get a warning from GHC saying that the <em>&quot;pattern matches are non-exhaustive&quot;</em>. This is because we did not cover all cases. So let's cover more cases:</p>
</li>
</ol>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    -- done case
    [] -&gt; maybeToList context
   
    -- Header 1 case
    ('@' : ' ' : line) : rest -&gt;
      maybe id (:) context (Header 1 (trim line) : parseLines Nothing rest)
   
    -- Unordered list case
    ('-' : ' ' : line) : rest -&gt;
      case context of
        Just (UnorderedList list) -&gt;
          parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)
   
    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Nothing -&gt;
                parseLines (Just (Paragraph line)) rest
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Exercise: Add the <code>CodeBlock</code> and <code>OrderedList</code> cases.</p>
<hr />
<details>
  <summary>Final module</summary>
<pre><code class="language-hs">-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  , parse
  )
where

import Data.Maybe (maybeToList)

type Document
  = [Structure]

data Structure
  = Header Int String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving (Eq, Show)    -- (1)


parse :: String -&gt; Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    -- done case
    [] -&gt; maybeToList context
   
    -- Header 1 case
    ('*' : ' ' : line) : rest -&gt;
      maybe id (:) context (Header 1 (trim line) : parseLines Nothing rest)
   
    -- Unordered list case
    ('-' : ' ' : line) : rest -&gt;
      case context of
        Just (UnorderedList list) -&gt;
          parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)

    -- Ordered list case
    ('#' : ' ' : line) : rest -&gt;
      case context of
        Just (OrderedList list) -&gt;
          parseLines (Just (OrderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest)

    -- Code block case
    ('&gt;' : ' ' : line) : rest -&gt;
      case context of
        Just (CodeBlock code) -&gt;
          parseLines (Just (CodeBlock (code &lt;&gt; [line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (CodeBlock [line])) rest)

    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Nothing -&gt;
                parseLines (Just (Paragraph line)) rest
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest

trim :: String -&gt; String
trim = unwords . words
</code></pre>
</details>
<hr />
<h3 id="how-do-we-know-our-parser-works-correctly"><a class="header" href="#how-do-we-know-our-parser-works-correctly">How do we know our parser works correctly?</a></h3>
<p>At an earlier chapter, we parsed a few example of our markup language <a href="04-markup/01-data_type.html#exercises">by hand</a>.
Now, we can try to test our parser by comparing our solutions to our parser.
By adding the <code>Eq</code> constraint to our data type (as shown in (1)), we can add these to our module and
use the <code>==</code> (equals) operator to compare our solutions to the result our parser gives.</p>
<p>Try it in ghci! You can read a text file in ghci using the following syntax:</p>
<pre><code class="language-hs">ghci&gt; txt &lt;- readFile &quot;/tmp/sample.txt&quot;
</code></pre>
<p>And then compare with a hand written <code>doc</code> value from the solutions
(after adding it to the module and loading it in ghci):</p>
<pre><code class="language-hs">ghci&gt; parse txt == doc
</code></pre>
<p>In a later chapter, we'll discuss how to use a testing framework and
write automated tests for our parser. But first, I'd like to glue things together
so we'll be able to:</p>
<ol>
<li>Read markup text from a file</li>
<li>Parse the text</li>
<li>Convert the result to our html EDSL</li>
<li>Generate HTML code</li>
</ol>
<p>And also discuss how to work with IO in Haskell while we're at it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gluing-things-together"><a class="header" href="#gluing-things-together">Gluing things together</a></h1>
<p>In this chapter we are going to glue the pieces that we built together
and build an actual blog generator. We will:</p>
<ol>
<li>Read markup text from a file</li>
<li>Parse the text to a <code>Document</code></li>
<li>Convert the result to our <code>Html</code> EDSL</li>
<li>Generate HTML code</li>
<li>Write it to file</li>
</ol>
<p>While doing so, we will learn:</p>
<ul>
<li>How to work with IO</li>
<li>How to import external libraries to process whole directories and create a simple command-line interface</li>
<li>How to use a testing framework to write automated tests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-io"><a class="header" href="#working-with-io">Working with IO</a></h1>
<p>In previous chapters we were able to build a parser from a text
string to a Haskell representation of our markup language,
and we built an EDSL for easy writing of HTML code.
However, our program is still not useful to other users because
we did this functionality accessible to a user via some sort of
a user interface.</p>
<p>In our program, we'd like to learn from the user what they'd
like us to convert to HTML, and then convert that for them.
There are many ways to design this kind of interface, for example:</p>
<ul>
<li>Get text as input via the <em>standard input</em>, and output HTML
via the <em>standard output</em></li>
<li>Receive two file names as <em>command-line arguments</em>, read the contents
of the first one and write the output to the second one</li>
<li>Ask for some fancier command-line arguments parsing and prefix
the file with a flag saying what they are</li>
<li>Some fancy GUI interface</li>
<li>Combination of all of the above</li>
</ul>
<p>To make this interesting, we will start with the following interface:</p>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name which we will read, and the second one
will be the output file name to which we will write</li>
<li>If the output file already exists, we'll ask the user if they want
to override the file</li>
<li>On any other kind of input, we'll output a generic message explaining
the usage as we described above</li>
</ol>
<p>At a later chapter, we will add a little fancier argument parsing
using a library, and also read whole directories and not single files.</p>
<p>But first, we need to learn a bit about IO in Haskell, what makes
it special, and why it's a bit different from otherprogramming languages.</p>
<h2 id="purely-functional"><a class="header" href="#purely-functional">Purely functional</a></h2>
<p>Originally, Haskell was designed in order to become an <em>open standard</em>
functional programming language with <strong>non-strict semantics</strong>, to serve
as a unifying language for future research in functional language design.</p>
<p>In GHC Haskell, we use a <em>lazy evaluation strategy</em> to implement non-strict
semantics (We've talked about laziness
<a href="https://soupi.github.io/learn-haskell-blog-generator/04-markup/02-parsing_01.html#laziness">before</a>).</p>
<p>The requirement for non-strict semantics has raise an interesting challenge,
how do we design a language that can do more than just evaluate expressions,
how do we model interaction with the outside world? How do we do IO?</p>
<p>The challenge with doing IO operation in a language with a lazy evaluation strategy
is that as programs grow larger, the order of evaluation becomes less trivial to
figure out. Consider this hypothetical code example
(which won't actually typecheck in Haskell, we'll see why soon):</p>
<pre><code class="language-hs">addWithInput :: Int -&gt; Int
addWithInput n = readIntFromStdin + n

main =
  let
    result1 = addWithInput 1
    result2 = addWithInput 2
  in
    print (result2 - result1)
</code></pre>
<p>This hypothetical program will read 2 integers from the standard input,
and then will substract the second one (+2) from the first one (+1),
or so we would expect if this was a strict language. In a strict language
we expect the order of operations to to happen from the top-down.
But in a lazy language we don't actually evaluate an expression until
it is needed, and so neither <code>result1</code> nor <code>result2</code> are evaluted
until we wish to print the result of substracting one from the other,
and then when we try to evaluate <code>-</code>, it requires to evaluate the two arguments
in order from left to right, so we first evaluate <code>result2</code>.</p>
<p>Evaluating <code>result2</code>, with substitution, means to replace occurances of <code>n</code>
with the input <code>2</code>, and then evaluate the top level function (<code>+</code>), it is a
primitive function, we then evaluate it's arguments, <code>readIntFromStdin</code>
and then <code>n</code>, at this point <em>we are reading the first integer from the stdin</em>.</p>
<p>After calcuating the result, we can move to evaluate <code>result1</code>, in which,
during evaluation, <em>will read the second integer from stdin</em>, this is the
complete opposite of what we wanted!</p>
<p>Issues like these make lazy evaluation hard to work with in the presence of
<strong>side effects</strong> - when the evaluation of an expression <em>can affect or be affected
by the outside world</em>, this includes reading/writing from mutable memory
or performing I/O operations.</p>
<p>We call functions that has side-effects such as <code>addWithInput</code> <strong>impure functions</strong>.
And an unfortunate consequence of impure functions is that
<strong>they can return different results even when they takes the same input</strong>.</p>
<p>The presence of impure functions makes it harder for us to reason about lazy evaluation,
and also messes up our ability to use <em>equational reasoning</em> to understand programs.</p>
<p>Therefore, for Haskell, it was decided to only allow <strong>pure</strong> and expressions - ones that
have <em>no side effects</em> - pure functions will <em>always</em> return the same output (given the same input)
and <strong>evaluating pure expressions is deterministic</strong>.</p>
<p>But now, how can we do input/ouput operations? There are many possible solutions
for the design space, in Haskell it was chosen to design a first class interface
with an accompanied type called <code>IO</code>. <code>IO</code>'s interface will force a dinstiction
from non-IO expressions, and will also require that in order to combine
multiple <code>IO</code> operations, we will have to determine the order between them.</p>
<h2 id="io"><a class="header" href="#io">IO</a></h2>
<p><code>IO</code> is an opaque type, like our <code>Html</code> type in which we hid its internal
representation from the user behind an interface. But in this case <code>IO</code> is a
built-in type that is hidden by the Haskell language rather than a module.</p>
<p><code>IO</code> has a payload type like <code>Maybe</code> has which represents the
result of an <code>IO</code> operation/action/computation.
When there isn't a meaningful result, we use the unit type,
<code>()</code> (which only has one value: <code>()</code>) to represent that.</p>
<p>Here are a few functions that return <code>IO</code> operations:</p>
<pre><code class="language-hs">putStrLn :: String -&gt; IO ()

getLine :: IO String

getArgs :: IO [String]

lookupEnv :: String -&gt; IO (Maybe String)

writeFile :: FilePath -&gt; String -&gt; IO ()
</code></pre>
<!-- You can find more useful IO functions and operations in the
[System.IO](https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO.html) module.
which is shipped with `base`. -->
<p>Notice that each function returns an <code>IO &lt;something&gt;</code>, but what does that mean?</p>
<p>The meaning behind <code>IO a</code> is that it is a <em>description of a program (or subroutine)
that when executed will produce some value of type <code>a</code>, and may do some I/O effects
during execution</em>.</p>
<p>Executing an <code>IO a</code> is different from evaluating it.
Evaluating an <code>IO a</code> expression is pure - the <strong>evalution</strong> will always reduce to
the same <strong>description</strong> of a program. This helps us keep purity and equational reasoning!</p>
<p>The Haskell runtime will <em>execute</em> the entry point to the program
(the expression <code>main</code>, that must have the type <code>IO ()</code>) in order for our IO operation
to also run it has to be <em>combined into</em> the <code>main</code> expression - let's see what that means.</p>
<h2 id="combining-io-expressions"><a class="header" href="#combining-io-expressions">Combining IO expressions</a></h2>
<p>Just like our <code>Html</code> type, the IO interface provides <strong>combinators</strong> for composing
small <code>IO</code> operations into bigger ones, this interface also makes sure that the order
of operations is well defined!</p>
<p>Note that, just like with <code>&lt;&gt;</code> we've defined for <code>Html</code>, the combinators for <code>IO</code>
are implemented as <strong>type-class instances</strong> rather than specialized variants
(for example our <code>append_</code> function was a specialized version of <code>&lt;&gt;</code> tailored only
for <code>Html</code>).</p>
<p>In this section I will introduce specialized type signatures rather than generalized ones,
because I think it'll be easier to digest, but we'll talk about the generalized versions
later.</p>
<h3 id=""><a class="header" href="#">&gt;&gt;=</a></h3>
<p>Our first combinator is <code>&gt;&gt;=</code> (pronounced bind), and is the most useful of the bunch:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>This combinator takes two arguments, the first is an IO operation, and the second is
a function that <em>takes as input the result of the first IO operation</em> and returns
a new <code>IO b</code> which is the final result.</p>
<p>Here are a few examples using the functions we described above:</p>
<ol>
<li>
<p>Echo</p>
<pre><code>getLine &gt;&gt;= (\line -&gt; putStrLn line)
</code></pre>
<p>We are reading a line from the standard input pass on the left of <code>&gt;&gt;=</code>,
and receive the input to the left of <code>&gt;&gt;=</code>, and then write it to the
standard output. <code>&gt;&gt;=</code>'s role here is to <strong>pass the result of the IO operation
on the left to the function returning an IO operation on the right</strong>.</p>
<p>Notice how <code>&gt;&gt;=</code> <em>defines an order of operations - from left to right</em>.</p>
<p>The type of each sub expression here is:</p>
<pre><code class="language-hs">getLine :: IO String

putStrLn :: String -&gt; IO ()

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO ()) -&gt; IO ()

line :: String
</code></pre>
<ul>
<li>Question: what is the type of the whole expression? <details><summary>Answer</summary>IO ()</details></li>
</ul>
<p>Also note that this example above can be written in a more concise manner
in point free style <code>getLine &gt;&gt;= putStrLn</code>.</p>
</li>
<li>
<p>Appending two inputs</p>
<pre><code>getLine &gt;&gt;= (\honorific -&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)))
</code></pre>
<p>This subroutine combines multiple operations together, it reads two lines from
the standard input and prints a greeting.
Note that:</p>
<ul>
<li>Using <code>&gt;&gt;=</code> defines the order of operation from left to right</li>
<li>Because of the scoping rules in Haskell, <code>honorific</code> will still be in scope for the most inner function</li>
</ul>
<p>This is a bit hard to read, but we can remove the parens and add indentation to make it a bit easier to read:</p>
<pre><code>getLine &gt;&gt;= \honorific -&gt;
  getLine &gt;&gt;= \name -&gt;
    putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)
</code></pre>
</li>
</ol>
<p>Let's see a few more combinators!</p>
<h3 id="-and"><a class="header" href="#-and">*&gt; and &gt;&gt;</a></h3>
<pre><code class="language-hs">(*&gt;) :: IO a -&gt; IO b -&gt; IO b
(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b
</code></pre>
<p><code>*&gt;</code> and <code>&gt;&gt;</code> have the same type signature for <code>IO</code> and mean the same thing,
in fact, <code>*&gt;</code> is a slightly more generalized version of <code>&gt;&gt;</code> and can always
be used instead of <code>&gt;&gt;</code>, which only still exists to avoid breaking backwards
compatability.</p>
<p><code>*&gt;</code> for <code>IO</code> means run the first IO operation, discard the result
the run the second operation. It can be implemented using <code>&gt;&gt;=</code>:</p>
<pre><code class="language-hs">a *&gt; b = a &gt;&gt;= \_ -&gt; b
</code></pre>
<p>This combinator is useful when you want to run several IO operations one after
the other that might not return anything meaningful, such as <code>putStrLn</code>:</p>
<pre><code>putStrLn &quot;hello&quot; *&gt; putStrLn &quot;world&quot;
</code></pre>
<h3 id="pure-and-return"><a class="header" href="#pure-and-return">pure and return</a></h3>
<pre><code class="language-hs">pure :: a -&gt; IO a
</code></pre>
<p>like <code>*&gt;</code> and <code>&gt;&gt;</code>, <code>pure</code> is a more general version of <code>return</code> that also has the
advantage of not having a resemblence to unrelated keywords in other languages.</p>
<p>Remember that we said <code>IO a</code> is description of a program
that when executed will produce some value of type <code>a</code>, and may do some I/O effects
during execution?</p>
<p>With <code>pure</code>, we can build an <code>IO a</code> that does no I/O, and will produce a
specific value of type <code>a</code>, the one we supply to <code>pure</code>!</p>
<p>This function is useful when we want to do some computation that depends on <code>IO</code>.</p>
<p>For example:</p>
<pre><code class="language-hs">confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm
</code></pre>
<p>Trying to return just <code>True</code> or <code>False</code> here wouldn't work because of the
type of <code>&gt;&gt;=</code>:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>The right side of <code>&gt;&gt;=</code> in our code example (<code>\answer -&gt; case ...</code>) must
be of type <code>String -&gt; IO Bool</code> this is because:</p>
<ol>
<li><code>getLine :: IO String</code>, so the <code>a</code> in the type signature of <code>&gt;&gt;=</code>
should be the same as <code>String</code> in this instance, and</li>
<li><code>confirm :: IO Bool</code>, so <code>b</code> should be <code>Bool</code></li>
</ol>
<h3 id="fmap-and-"><a class="header" href="#fmap-and-">fmap and &lt;$&gt;</a></h3>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>&lt;$&gt;</code> is the infix version of <code>fmap</code>. Use it at your discretion.</p>
<p>What if we wanted to write a function that reads a line from stdin
and returns it with <code>!</code> at the end? We could write it using a combination
of <code>&gt;&gt;=</code> and <code>pure</code>:</p>
<pre><code>getLine &gt;&gt;= \line -&gt; pure (line ++ &quot;!&quot;)
</code></pre>
<p>With <code>fmap</code>, we can remove the <code>pure</code> part:</p>
<pre><code>fmap (\line -&gt; line ++ &quot;!&quot;) getLine
</code></pre>
<p>What <code>fmap</code> does is apply a function to the value to be returning
from the IO operation, also known as &quot;mapping&quot; over it.</p>
<p>By the way, <code>fmap</code> looks very similar to a different function we ran into:
<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>. It's not a coincidence. We'll talk about it later!</p>
<h3 id="summary-1"><a class="header" href="#summary-1">Summary</a></h3>
<p>Here's a list of <code>IO</code> combinators we ran into:</p>
<pre><code class="language-hs">-- chaining IO operations: passing the *result* of the left IO operation
-- as an argument to the function on the right.
-- Pronounced &quot;bind&quot;.
(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b

-- sequence two IO operations, discarding the payload of the first.
(*&gt;) :: IO a -&gt; IO b -&gt; IO b

-- &quot;lift&quot; a value into IO context, does not add any I/O effects.
pure :: a -&gt; IO a

-- &quot;map&quot; (or apply a function) over the payload value of an IO operation.
fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<h2 id="io-is-first-class"><a class="header" href="#io-is-first-class">IO is first class</a></h2>
<p>The beauty of <code>IO</code> is that it's a completely first-class construct in the language,
and is not really different from <code>Maybe</code> and <code>Either</code>. We can pass it to
functions, put it in a container, etc. Remember that it represents a description
of a program, and without being combine into <code>main</code> in some way won't actually
<em>do</em> anything.</p>
<p>Here's an example of a function that takes IO actions as input:</p>
<pre><code class="language-hs">whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
<p>And how it can be used:</p>
<pre><code class="language-hs">main :: IO ()
main =
  putStrLn &quot;This program will tell you a secret&quot; *&gt;
    whenIO confirm (putStrLn &quot;IO is actually pretty awesome&quot;) *&gt;
      putStrLn &quot;Bye&quot;
</code></pre>
<p>Notice how <code>putStrLn &quot;IO is actually pretty awesome&quot;</code> isn't executed
right away, but only if it is what <code>whenIO</code> returns, and in turn is <em>combined</em>
with <code>*&gt;</code> as part of the <code>main</code> expression.</p>
<h2 id="getting-out-of-io"><a class="header" href="#getting-out-of-io">Getting out of IO?</a></h2>
<p>What we've seen above has great concequences to the Haskell language,
in our <code>Html</code> type, we had a function <code>render :: Html -&gt; String</code>
that could turn an <code>Html</code> to a string value.</p>
<p>In Haskell, <strong>there is no way</strong> to implement a function such as <code>execute :: IO a -&gt; a</code>
in a way that preserves purity and equational reasoning!</p>
<p>Also, <code>IO</code> is <em>opaque</em>, it does not let us examine it. So we are really bound
to what the Haskell API for <code>IO</code> allows us to do.</p>
<p>This means that <strong>we need to think about using IO differently</strong>!</p>
<p>In Haskell, once we got into <code>IO</code>, there is no getting out.
The only thing we can do is build bigger IO computations by <em>combining</em>
it with more IO computations.</p>
<p>We also can't use <code>IO a</code> in place of an <code>a</code>, so for example,
we can't write <code>getLine ++ &quot;!&quot;</code> because <code>++</code> expects both
sides to be Strings, and <code>getLine</code>'s type is <code>IO String</code>. The types do not match!
We have to use <code>fmap</code> and the return type must be <code>IO String</code>, like we've seen before.</p>
<p>In Haskell we like to keep <code>IO</code> usage minimal, and we like to push it to the edges
of the program. This pattern is often called <em>Functional core, imperative shell</em>.</p>
<h2 id="functional-core-imperative-shell"><a class="header" href="#functional-core-imperative-shell">Functional core, imperative shell</a></h2>
<p>In our blog generator program, we want to read a file, parse it, and convert it to html,
and then print the result to the console.</p>
<p>In many programming languages, we might interleave reading from the file with parsing,
and writing to the file with the html conversion. But we don't mix these here.
Parsing operates on a <code>String</code> value rather than some file handle,
and <code>Html</code> is being convert to a <code>String</code> rather than being written to the screen directly.</p>
<p>This approach of separating <code>IO</code> and pushing it to the edge of the program gives us
a lot of flexibility. These functions without <code>IO</code> are easier to test and examine
(because they are guaranteed to have deterministic evaluation!),
and they are more modular can work in many contexts (reading from stdin,
reading from network socket, writing to an http connection, and more).</p>
<p>This pattern is often a good approach for building Haskell programs. Especially
batch programs.</p>
<h2 id="building-a-blog-generator"><a class="header" href="#building-a-blog-generator">Building a blog generator</a></h2>
<p>We'd like to start building a blog generator, and we want to have the following
interface:</p>
<blockquote>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name which we will read, and the second one
will be the output file name to which we will write</li>
<li>If the output file already exists, we'll ask the user if they want
to override the file</li>
<li>On any other kind of input, we'll output a generic message explaining
the usage as we described above</li>
</ol>
</blockquote>
<p>We are going to need a few functions:</p>
<pre><code class="language-hs">getArgs :: IO [String] -- get the program arguments

getContents :: IO String -- Read all of the content from stdin

readFile :: FilePath -&gt; IO String -- Read all of the content from a file

writeFile :: FilePath -&gt; String -&gt; IO () -- Write a string into a file

doesFileExist :: FilePath -&gt; IO Bool -- Checks whether a file exists
</code></pre>
<p>And the following imports:</p>
<pre><code class="language-hs">import System.Directory (doesFileExist)
import System.Environment (getArgs)
import System.IO (getContents, readFile, writeFile)
</code></pre>
<p>Since we haven't implemented a conversion function <code>Document -&gt; Html</code> yet,
for the sake of the exercise, we can <code>show</code> the <code>Document</code> instead of converting it.
In the next chapter we will implement the conversion function. But if you are feeling
adventurous, you can try and implement it yourselves. You should have already ran into
all of the features and building blocks you need to implement it.</p>
<hr />
<p>Try implementing the &quot;imperative shell&quot; for our blog generator program.
Start with <code>main</code>, pattern match on the result of <code>getArgs</code>, and decide what to
do. Look back at the examples above for inspiration. Use <code>error</code> to report an error.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- Main.hs

import Markup

import System.Directory (doesFileExist)
import System.Environment (getArgs)
import System.IO (getContents, readFile, writeFile)

main :: IO ()
main =
  getArgs &gt;&gt;= \args -&gt;
    case args of
      -- No program arguments: reading from stdin and writing to stdout
      [] -&gt;
        getContents &gt;&gt;= \content -&gt;
        putStrLn (show (parse content))

      -- With input and output file paths as program arguments
      [input, output] -&gt;
        readFile input &gt;&gt;= \content -&gt;
          doesFileExist input &gt;&gt;= \exists -&gt;
            let
              writeResult = writeFile output (show (parse content))
            in
              if exists
                then whenIO confirm writeResult
                else writeResult

      -- Any other kind of program arguments
      _ -&gt;
        putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
</details>
<hr />
<h2 id="do-notation"><a class="header" href="#do-notation">Do notation</a></h2>
<p>While using <code>&gt;&gt;=</code> to chain IO action is manageable, Haskell provides
an even more convenient syntactic sugar called <em>do notation</em>
which emulates imperative programming.</p>
<p>A <em>do block</em> starts with the <code>do</code> keyword, and continues with one or more
&quot;statements&quot; which can be one of the following:</p>
<ul>
<li>An expression of type <code>IO ()</code>, such as:
<ul>
<li><code>putStrLn &quot;Hello&quot;</code></li>
<li><code>if True then putStrLn &quot;Yes&quot; else putStrLn &quot;No&quot;</code></li>
</ul>
</li>
<li>A let block, such as
<ul>
<li><code>let x = 1</code></li>
<li>or multiple let declarations:
<pre><code class="language-hs">let
  x = 1
  y = 2
</code></pre>
Note that we do not write the <code>in</code> here.</li>
</ul>
</li>
<li>A binding <code>&lt;variable&gt; &lt;- &lt;expresion&gt;</code>, such as
<pre><code class="language-hs">line &lt;- getLine
</code></pre>
</li>
</ul>
<p>And the last &quot;statement&quot; must be an expression of type <code>IO &lt;something&gt;</code> -
this will be the result type of the do block.</p>
<p>These construct will be translated to <code>&lt;expression&gt; *&gt;</code>, <code>let ... in</code> and
<code>&lt;expression&gt; &gt;&gt;= \&lt;variable&gt;</code> respectively.</p>
<p>For example:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting = do
  putStrLn &quot;Tell me your name.&quot;
  let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
  name &lt;- getLine
  putStrLn (greet name)
</code></pre>
<p>Is just syntactic sugar for:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting =
  putStrLn &quot;Tell me your name.&quot; *&gt;
    let
      greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
    in
      getLine &gt;&gt;= \name -&gt;
        putStrLn (greet name)
</code></pre>
<p>It's important to note the difference between <code>let</code> and <code>&lt;-</code> (bind).
<code>let</code> is used to give a new name to an expression which will be in scope
for subsequent lines, and <code>&lt;-</code> is used to bind the result <code>a</code> in an <code>IO a</code>
action to a new name which will be in scope for subsequent lines.</p>
<table>
  <tr>
    <th>code</th>
    <th>operator</th>
    <th>type of the left side</th>
    <th>type of the right side</th>
    <th>comment</th>
  </tr>
  <tr>
    <td><pre><pre>let gretting = "hello"</pre></pre></td>
    <td><pre>=</pre></td>
    <td><pre>String</pre></td>
    <td><pre>String</pre></td>
    <td>Both sides are interchangeable</td>
  </tr>
  <tr>
    <td><pre>let mygetline = getLine</pre></td>
    <td><pre>=</pre></td>
    <td><pre>IO String</pre></td>
    <td><pre>IO String</pre></td>
    <td>We just create a new name for <code>getLine</code></td>
  </tr>
  <tr>
    <td><pre>name <- getLine</pre></td>
    <td><pre><-</pre></td>
    <td><pre>String</pre></td>
    <td><pre>IO String</pre></td>
    <td>Technically <code><-</code> is not an operator, but just a syntactic sugar for <code>>>=</code> + lambda, where we bind the result of the computation to a variable</td>
  </tr>
</table>
<p>Do notation is very very common and is often preferable to using <code>&gt;&gt;=</code> directly.</p>
<hr />
<ol>
<li>
<p>Exercise: Translate the examples in this chapter to <em>do notation</em>.</p>
</li>
<li>
<p>Exercise: Translate our glue code for the blog generator to <em>do notation</em>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">-- Main.hs

import Markup

import System.Directory (doesFileExist)
import System.Environment (getArgs)
import System.IO (getContents, readFile, writeFile)

main :: IO ()
main = do
  args &lt;- getArgs
  case args of
    -- No program arguments: reading from stdin and writing to stdout
    [] -&gt; do
      content &lt;- getContents
      putStrLn (show (parse content))

    -- With input and output file paths as program arguments
    [input, output] -&gt; do
      content &lt;- readFile input
      exists &lt;- doesFileExist input
      let
        writeResult = writeFile output (show (parse content))
      if exists
        then whenIO confirm writeResult
        else writeResult

    -- Any other kind of program arguments
    _ -&gt;
      putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

confirm :: IO Bool
confirm = do
  putStrLn &quot;Are you sure? (y/n)&quot;
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. use y or n&quot;
      confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
