<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Haskell by building a blog generator</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A step by step guide to learning Haskell by building a simple static blog generator">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-about.html"><strong aria-hidden="true">1.</strong> About this tutorial</a></li><li class="chapter-item expanded "><a href="02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible html content (functions)</a></li><li class="chapter-item expanded "><a href="03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="03-html/09-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="03-html/10-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (typeclasses)</a></li><li class="chapter-item expanded "><a href="04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="06-next.html"><strong aria-hidden="true">6.</strong> Where to go next?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Learning Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-tutorial"><a class="header" href="#about-this-tutorial">About this tutorial</a></h1>
<blockquote>
<p>Note: This is WIP and is still being written. If you find errors, <a href="https://github.com/soupi/learn-haskell-blog-generator/issues">please let me know</a>.</p>
</blockquote>
<p>In this tutorial we will implement a very simple static blog generator in Haskell,
converting documents written in our own custom markup language to html.</p>
<p>We will:</p>
<ol>
<li>Implement a tiny HTML printer library</li>
<li>Define and parse our custom markup language</li>
<li>Read files and glue things together</li>
<li>Add command line arguments parsing</li>
<li>Alternatively serve the blog over http</li>
</ol>
<p>In each chapter of the book we will focus on a particular task we wish to achieve,
and through the chapter we'll learn just enough Haskell to complete the task.</p>
<p>This book is an alternatively presentation of:
<a href="https://github.com/soupi/learn-haskell-blog-generator">soupi/learn-haskell-blog-generator</a>,
which presents the chapters one commit at a time.</p>
<p>You might be also interested in:</p>
<ul>
<li><a href="https://soupi.github.io/rfc/reading_simple_haskell/">Reading Simple Haskell</a></li>
<li><a href="https://github.com/soupi/haskell-study-plan/">Haskell Study Plan</a></li>
</ul>
<h2 id="why-read-this-book"><a class="header" href="#why-read-this-book">Why read this book?</a></h2>
<p>There are many Haskell tutorials, guides and books out there. Why read this one?</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<p>There are probably more, but here are a few possible pros:</p>
<ul>
<li>It's <strong>relatively short</strong> - most Haskell books out there are hundreds of pages long.
This book (when exported to pdf) is less than 100 pages long.</li>
<li>It's <strong>project oriented</strong>. Many Haskell books teach Haskell by teaching the underlying
concepts and features in a neat progression. In this book we try to build a thing,
and learn Haskell on the way.
There are other tutorials like this. The most notable ones are
<a href="https://www.apress.com/gp/book/9781430262510#otherversion=9781430262503">Beginning Haskell</a>
and <a href="https://haskell-via-sokoban.nomeata.de/">Haskell via Sokoban</a>.</li>
<li>It's <strong>free</strong>.</li>
<li>It's <strong>on the internet</strong>, which means corrections are easy to make.</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<p>There are probably more, but here are a few possible cons:</p>
<ul>
<li>It may <strong>lack depth</strong> - many, much longer Haskell tutorials are long because they go
deeper into the nuts and bolts of each feature.</li>
<li>It may <strong>not cover as many features or techniques</strong> as other tutorials -
we try to cover features as they pop up in our implementation, but we will
probably miss features that aren't as commonly used for our tasks,
while other resources may try to cover many different use cases.</li>
<li>It is <strong>very new</strong> and not &quot;battle-tested&quot;. Who knows if this is a good approach to
learning Haskell? Maybe you could help with that!</li>
<li>It <strong>doesn't have an technical editor</strong>, making the book not as good as it could've been.</li>
</ul>
<h3 id="other-learning-resources"><a class="header" href="#other-learning-resources">Other learning resources</a></h3>
<p>The <a href="https://www.haskell.org/documentation/">haskell.org/documentation</a> page lists
many tutorials, books, guides and courses. You can find a few alternatives that I can
recommend <a href="https://github.com/soupi/haskell-study-plan#about-this-guide">in this list</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h1>
<p>In this chapter we will create a simple html hello world.</p>
<p>A Haskell source file is composed of definitions.</p>
<p>The most common definition has the following form:</p>
<pre><code class="language-hs">&lt;name&gt; = &lt;expression&gt;
</code></pre>
<p>Note that:</p>
<ol>
<li>We cannot write expressions without binding them to a name</li>
<li>Names must start with a lowercase letter</li>
<li>We cannot use the same name more than once in a file</li>
</ol>
<p>A source file containing a definition of the name <code>main</code> can be treated as an executable,
and the expression <code>main</code> is bound to is the entry point to the program.</p>
<p>Let's create a new Haskell source file called <code>hello.hs</code>, and write the following line there:</p>
<pre><code class="language-hs">main = putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>We've defined a new name, <code>main</code>, and bound it to the expression <code>putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>.</p>
<p>the body of <code>main</code> means calling the function <code>putStrLn</code> with the string <code>&quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>.
<code>putStrLn</code> takes a single string as input and prints that string to the standard output.</p>
<p><strong>Note</strong>: we don't need parenthesis to pass arguments to functions in Haskell.</p>
<p>Running this program will result in the following text printed on the screen:</p>
<pre><code>&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>To run this little program, we can either compile it using the command line program <code>ghc</code>, like this: <code>ghc hello.hs</code> which will create a few files:</p>
<ol>
<li><code>hello.o</code> - Object file</li>
<li><code>hello.hi</code> - Haskell interface file</li>
<li><code>hello</code> - A native executable file</li>
</ol>
<p>and then run <code>hello</code>.</p>
<p>Or, alternatively, interpret the source file using the command line program <code>runghc</code>,
like this: <code>runghc hello.hs</code>. This will run the program without compiling it or creating any files.</p>
<pre><code class="language-sh">&gt; runghc hello.hs
&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>We can also redirect the output of the program to a file and then open it in firefox.</p>
<pre><code class="language-sh">&gt; runghc hello.hs &gt; hello.html
&gt; firefox hello.html
</code></pre>
<p>This command should open firefox and display a web page with <code>Hello, world!</code> written in it.</p>
<p>In this tutorial we'll use <code>runghc</code> regularily, because it saves us time to run the program without compiling it.</p>
<hr />
<p><strong>Note</strong>: If you've installed a ghc toolchain via stack and not ghcup, and the commands above do not work because <code>ghc</code> or <code>runghc</code> are missing, prefix the commands above with <code>stack exec -- </code>. Stack will locate the globally installed ghc and use it. So for example <code>runghc hello.hs</code> becomes <code>stack exec -- runghc hello.hs</code>. See the <a href="https://docs.haskellstack.org/en/stable/GUIDE/#exec">Stack user guide</a> for more details.</p>
<hr />
<blockquote>
<p>If you want to learn more about the core Haskell tools, <a href="https://gilmi.me/blog/post/2021/08/14/hs-core-tools">you can read this article</a>. But what's described above is enough for now.</p>
</blockquote>
<h2 id="more-bindings"><a class="header" href="#more-bindings">More bindings</a></h2>
<p>We can define the html string passed to <code>putStrLn</code> in a new name instead of passing
it directly to <code>putStrLn</code>. Change the content of file <code>hello.hs</code> we defined above to:</p>
<pre><code class="language-hs">main = putStrLn myhtml

myhtml = &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p><strong>Note</strong>: the order in which we declare the bindings does not matter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-an-html-printer-library"><a class="header" href="#building-an-html-printer-library">Building an HTML printer library</a></h1>
<p>In this part we'll explore a few basic building blocks in Haskell,
including functions, types and modules, while building a small HTML printer library
with which we will later construct HTML pages from our markup blog posts.</p>
<p>If you're not familiar with HTML and would like a quick tutorial before diving in, MDN's
<a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started">Getting started with HTML</a>
is a good overview on the subject.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flexible-html-content-functions"><a class="header" href="#flexible-html-content-functions">Flexible html content (functions)</a></h1>
<p>We'd like to be able to write different html pages without having to write the whole
structure of html and body tags over and over again. We can do that with functions.</p>
<p>To define a function, we create a definition like we saw previously and add the argument
names after the name and before the equals sign (<code>=</code>).
So a function definition has the following form:</p>
<pre><code class="language-hs">&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; = &lt;expression&gt;
</code></pre>
<p>The argument names will be available in scope on the right side of the equals sign
(in the <code>&lt;expression&gt;</code>), and the function name will be <code>&lt;name&gt;</code>.</p>
<p>We'll define a function that takes a string, which is the content of the page, and wraps it in
the relevant <code>html</code> and <code>body</code> tags by concatenating them before and after the content.
We use the operator <code>&lt;&gt;</code> to concatenate two strings.</p>
<pre><code class="language-hs">wrapHtml content = &quot;&lt;html&gt;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>This function, <code>wrapHtml</code>, takes one argument named <code>content</code> and returns a string
that prefixes <code>&lt;html&gt;&lt;body&gt;</code> before the content and appends <code>&lt;/body&gt;&lt;/html&gt;</code> after it.
Note that it is common to use camelCase in Haskell for names.</p>
<p>Now we can adjust our <code>myhtml</code> definition from the previous chapter:</p>
<pre><code class="language-hs">myhtml = wrapHtml &quot;Hello, world!&quot;
</code></pre>
<p>Again, notice that we don't need parenthesis when calling functions. Function calls have the form:</p>
<pre><code class="language-hs">&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt;
</code></pre>
<p>However, if we wanted to substitute <code>myhtml</code> with the expression <code>myhtml</code> is bound
to in <code>main = putStrLn myhtml</code>, we would have to wrap the expression in paranthesis:</p>
<pre><code class="language-hs">main = putStrLn (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<p>If we accidentally write this instead:</p>
<pre><code class="language-hs">main = putStrLn wrapHtml &quot;Hello, world!&quot;
</code></pre>
<p>we'll get an error from GHC stating that <code>putStrLn</code> is applied to two arguments,
but it only takes one. This is because the above is of the form <code>&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt;</code>
in which, as we defined earlier, <code>&lt;arg1&gt;</code> and <code>&lt;arg2&gt;</code> are arguments to <code>&lt;name&gt;</code>.</p>
<p>By using parenthesis we can group together the expressions in the right order.</p>
<hr />
<p>Exercises:</p>
<ol>
<li>
<p>Separate the functionality of <code>wrapHtml</code> to two functions:</p>
<ol>
<li>One that wraps content in <code>html</code> tag</li>
<li>one that wraps content in a <code>body</code> tag</li>
</ol>
<p>Name the new functions <code>html_</code> and <code>body_</code>.</p>
</li>
<li>
<p>Change <code>myhtml</code> to use these two functions.</p>
</li>
<li>
<p>Add another two similar functions for the tags <code>&lt;head&gt;</code> and <code>&lt;title&gt;</code>
and name them <code>head_</code> and <code>title_</code>.</p>
</li>
<li>
<p>Create a new function, <code>makeHtml</code>, which takes two strings as input:</p>
<ol>
<li>One string for the title</li>
<li>One string for the body content</li>
</ol>
<p>And construct an HTML string using the functions implemented in the previous exercises.</p>
<p>The output for:</p>
<pre><code class="language-hs">makeHtml &quot;My page title&quot; &quot;My page content&quot;
</code></pre>
<p>Should be:</p>
<pre><code class="language-html">&lt;html&gt;&lt;head&gt;&lt;title&gt;My page title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;My page content&lt;/body&gt;&lt;/html&gt;
</code></pre>
</li>
<li>
<p>Use <code>makeHtml</code> in <code>myhtml</code> instead of using <code>html_</code> and <code>body_</code> directly</p>
</li>
</ol>
<hr />
<p>Solutions:</p>
<details>
  <summary>Solution for exercise #1</summary>
<pre><code class="language-hs">html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #2</summary>
<pre><code class="language-hs">myhtml = html_ (body_ &quot;Hello, world!&quot;)
</code></pre>
</details>
<details>
  <summary>Solution for exercise #3</summary>
<pre><code class="language-hs">head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #4</summary>
<pre><code class="language-hs">makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)
</code></pre>
</details>
<details>
  <summary>Solution for exercise #5</summary>
<pre><code class="language-hs">myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;
</code></pre>
</details>
<details>
  <summary>Our final program</summary>
<pre><code class="language-hs">-- hello.hs

main = putStrLn myhtml

myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;

makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;

head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
<p>We can now run our <code>hello.hs</code> program, pipeline the output into a file,
and open it in our browser:</p>
<pre><code class="language-sh">runghc hello.hs &gt; hello.html
firefox hello.html
</code></pre>
<p>It should display <code>Hello, world!</code> on the page and <code>Hello title</code> on the page's title.</p>
</details>
<hr />
<h2 id="indentation"><a class="header" href="#indentation">Indentation</a></h2>
<p>You might ask how does Haskell know a definition is complete?
The answer is: Haskell uses indentation to know when things should be grouped together.</p>
<p>Indentation in Haskell can be a bit tricky, but in general: code which is supposed to be
part of another expression should be indented further than the beginning of that expression.</p>
<p>We know two definitions are separate because the second one is not indented further than the first one.</p>
<h3 id="indentation-tips"><a class="header" href="#indentation-tips">Indentation tips</a></h3>
<ol>
<li>Choose a specific amount of spaces for indentation (2 spaces, 4 spaces, etc) and stick to it.
Always use spaces over tabs.</li>
<li>Do not indent more than once in any given time.</li>
<li>When in doubt, drop line as needed and indent once.</li>
</ol>
<p>Here are a few examples:</p>
<pre><code class="language-hs">main =
    putStrLn &quot;Hello, world!&quot;
</code></pre>
<p>or:</p>
<pre><code class="language-hs">main =
    putStrLn
        (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<p><strong>Avoid the following styles</strong>, which use more than one indentation steps, or completely disregard
indentation steps:</p>
<pre><code class="language-hs">main = putStrLn
        (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<pre><code class="language-hs">main = putStrLn
                (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-type-signatures"><a class="header" href="#adding-type-signatures">Adding type signatures</a></h1>
<p>Haskell is a <strong>statically typed</strong> programming language. That means that every
expression has a type, and we check that the types are valid with
regards to each other before running the program. If we discover that
they are not valid, an error message will be printed and the program
will not run.</p>
<p>An example of a type error would be if we'd pass 3 arguments to a function
that takes only 2, or pass a number instead of a string.</p>
<p>Haskell is also <strong>type inferred</strong>, so we don't <em>need</em> to specify the type
of expressions - Haskell can <em>infer</em> from the context of the expression
what its type should be, and that's what we did up until now. However, <strong>specifying
types is useful</strong> - it adds a layer of documentation for you or others
that will look at the code later, and it helps verify to some degree
that what was intended (with the type signature) is what was
written (with the expression). It is generally recommended to annotate all <em>top-level</em>
definitions with type signatures.</p>
<p>We use double-colon (<code>::</code>) to specify the type of names. We usually
write it right above the definition of the name itself.</p>
<p>Here are a few examples of types we can write:</p>
<ul>
<li><code>Int</code> - The type of integer numbers</li>
<li><code>String</code> - The type of strings</li>
<li><code>Bool</code> - The type of booleans</li>
<li><code>()</code> - The type of the expression <code>()</code>, also called unit</li>
<li><code>a -&gt; b</code> - The type of a function from an expression of type <code>a</code> to an expression of type <code>b</code></li>
<li><code>IO ()</code> - The type of an expression that represents an IO subroutine that returns <code>()</code></li>
</ul>
<p>Let's specify the type of <code>title_</code>:</p>
<pre><code class="language-hs">title_ :: String -&gt; String
</code></pre>
<p>We can see in the code that the type of <code>title_</code> is a function that takes
a <code>String</code> and returns a <code>String</code>.</p>
<p>Let's also specify the type of <code>makeHtml</code>:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; String -&gt; String
</code></pre>
<p>Previously, we thought about <code>makeHtml</code> as a function that takes
two strings and returns a string.</p>
<p>But actually, all functions in Haskell take <strong>exactly one argument</strong> as input
and return <strong>exactly one value</strong> as output. It's just convenient to refer
to functions like <code>makeHtml</code> as functions with multiple inputs.</p>
<p>In our case, <code>makeHtml</code> is a function that takes <strong>one</strong> string argument,
and returns a <strong>function</strong>. <em>The function it returns</em> takes a string argument
as well and finally returns a string.</p>
<p>The magic here is that <code>-&gt;</code> is right associative. Which means that when we write:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; String -&gt; String
</code></pre>
<p>Haskell parses it as:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; (String -&gt; String)
</code></pre>
<p>Consecuently, the expression <code>makeHtml &quot;My title&quot;</code> is also a function!
One that will take a string (the content, the second argument of <code>makeHtml</code>)
and will return the expected html string with &quot;My title&quot; in the title.</p>
<p>This is called <strong>partial application</strong>.</p>
<p>To illustrate, let's define <code>html_</code> and <code>body_</code> in a different way by
defining a new function, <code>el</code>.</p>
<pre><code class="language-hs">el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>el is a function that takes a tag and content, and wraps the content
with the tag.</p>
<p>We can now implement <code>html_</code> and <code>body_</code> by partially applying <code>el</code> and
only provide the tag.</p>
<pre><code class="language-hs">html_ :: String -&gt; String
html_ = el &quot;html&quot;

body_ :: String -&gt; String
body_ = el &quot;body&quot;
</code></pre>
<p>Note that we didn't need to add the argument on the left side of
equals sign because Haskell functions are &quot;<strong>first class</strong>&quot; - they behave
exactly like normal expressions. You can define names to them like
regular values, put them in data structures, pass them to functions,
everything you can do with regular values like <code>Int</code> or <code>String</code>.</p>
<p>The way Haskell treats names is very similar to copy paste. anywhere
you see <code>html_</code> in the code, you can replace it with <code>el &quot;html&quot;</code>. They are
the same (this is what the equals signs say, right? That the two sides
are the same). This property, of behind able to <em>substitute</em> the two sides of the
equals sign with one another, is called <strong>referential transparency</strong>. And
it is pretty unique to Haskell (and a few language that are very
similar to it like PureScript and Elm)! We'll talk more about this in a later chapter.</p>
<h3 id="anonymouslambda-functions"><a class="header" href="#anonymouslambda-functions">Anonymous/lambda functions</a></h3>
<p>To further drive the point that Haskell functions are first class and
all functions take exactly one argument,
I'll mention that the syntax we've been using up until
now to define function is just syntactic sugar! We can also define
<strong>anonymous functions</strong> - functions without a name, anywhere we'd like.
anonymous functions are also known as <strong>lambda functions</strong>.
This is a tribute to the original, most primitive
functional programming language - the lambda calculus.</p>
<p>We can create an anonymous function anywhere we'd expect an expression
such as <code>&quot;hello&quot;</code> with the following syntax:</p>
<pre><code class="language-hs">\&lt;argument&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>This little <code>\</code> (which bears some resemblance to the lowercase greek letter lambda 'λ')
marks the head of the lambda function,
and the arrow (<code>-&gt;</code>) marks the beginning of the body of the function.
We can even chain lambda functions, making them &quot;multiple argument functions&quot; by
defining another lambda in the body of another, like this:</p>
<pre><code class="language-hs">three = (\num1 -&gt; \num2 -&gt; num1 + num2) 1 2
</code></pre>
<p>Just as before, we evaluate functions by substituting the function argument with
the applied value. In the example above we subtitute <code>num1</code> with <code>1</code>, and get
<code>(\num2 -&gt; 1 + num2) 2</code>. Then subtitute <code>num2</code> with <code>2</code> and get <code>1 + 2</code>.
We'll talk more about substitution later.</p>
<p>So, when we write:</p>
<pre><code class="language-hs">el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>Haskell actually translates this under the hood to:</p>
<pre><code class="language-hs">el :: String -&gt; (String -&gt; String)
el = \tag -&gt; \content -&gt;
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>Hopefully this form makes it a bit clearer why Haskell functions
always take one argument and return another, even when we have
syntactic sugar that might suggest otherwise.</p>
<p>I'll mention one more syntactic sugar for anonymous functions:
We don't actually have to write multiple argument anonymous functions
this way, we can just write: </p>
<pre><code class="language-hs">\&lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>to save us some trouble. For example:</p>
<pre><code class="language-hs">three = (\num1 num2 -&gt; num1 + num2) 1 2
</code></pre>
<p>But it's worth remembering what they are under the hood.</p>
<p>We won't be needing anonymous/lambda functions at this point,
but we'll talk more about them later and see where they can be useful.</p>
<hr />
<p>Exercises:</p>
<ol>
<li>
<p>Add types for all of the functions we created until now</p>
</li>
<li>
<p>Change the implementation of the html functions we built to use <code>el</code> instead</p>
</li>
<li>
<p>Add a couple more functions for defining paragraphs and headers:</p>
<ol>
<li><code>p_</code> which uses the tag <code>&lt;p&gt;</code> for paragraphs</li>
<li><code>h1_</code> which uses the tag <code>&lt;h1&gt;</code> for headers</li>
</ol>
</li>
<li>
<p>Replace our <code>Hello, world!</code> string with richer content, use <code>h1_</code> and <code>p_</code>.
We can append html strings created by <code>h1_</code> and <code>p_</code> using the append operator <code>&lt;&gt;</code>.</p>
</li>
</ol>
<hr />
<p>Solutions:</p>
<details>
  <summary>Solution for exercise #1</summary>
<pre><code class="language-hs">myhtml :: String
myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;

makeHtml :: String -&gt; String -&gt; String
makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ :: String -&gt; String
html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ :: String -&gt; String
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;

head_ :: String -&gt; String
head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ :: String -&gt; String
title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #2</summary>
<pre><code class="language-hs">html_ :: String -&gt; String
html_ = el &quot;html&quot;
   
body_ :: String -&gt; String
body_ = el &quot;body&quot;

head_ :: String -&gt; String
head_ = el &quot;head&quot;

title_ :: String -&gt; String
title_ = el &quot;title&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #3</summary>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;

h1_ :: String -&gt; String
h1_ = el &quot;h1&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #4</summary>
<pre><code class="language-hs">myhtml :: String
myhtml =
  makeHtml
    &quot;Hello title&quot;
    (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)
</code></pre>
</details>
<hr />
<details>
  <summary>Our final program</summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn myhtml

myhtml :: String
myhtml =
  makeHtml
    &quot;Hello title&quot;
    (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)


makeHtml :: String -&gt; String -&gt; String
makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ :: String -&gt; String
html_ = el &quot;html&quot;
   
body_ :: String -&gt; String
body_ = el &quot;body&quot;

head_ :: String -&gt; String
head_ = el &quot;head&quot;

title_ :: String -&gt; String
title_ = el &quot;title&quot;

p_ :: String -&gt; String
p_ = el &quot;p&quot;

h1_ :: String -&gt; String
h1_ = el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-domain-specific-languages"><a class="header" href="#embedded-domain-specific-languages">Embedded Domain Specific Languages</a></h1>
<p>Right out of the bat we run into a common pattern in Haskell: creating
Embedded Domain Specific Languages (EDSLs for short).</p>
<p>Domain specific languages (DSLs) are specialized programming languages that are
tailored to specific domains. In contrast of general purpose languages,
which try to work well in many domains.</p>
<p>A few examples of DSLs are:</p>
<ul>
<li>make - for defining build systems</li>
<li>DOT - for defining graphs</li>
<li>Sed - for defining text transformations</li>
<li>CSS - for defining styling</li>
<li>HTML - for defining web pages</li>
</ul>
<p>An <em>embedded</em> domain specific language is a little language which is
embedded inside another programming language, making a program written in
the EDSL a valid program in the language it was written in.</p>
<p>The little HTML library we've been writing can be considered an EDSL.
It is used specifically for building web pages (by returning html strings),
and is valid Haskell code!</p>
<p>In Haskell we frequently create and use EDSLs to express domains specific
logic. We have EDSLs for concurrency, command-line options parsing, JSON and HTML,
Creating build systems, writing tests, and many more.</p>
<p>Specialized languages are useful because they can solve specific problems in
a concise (and often safe) way, and embedding them in general purpose programming
languages provides us to use the full power of the language for our domain logic,
including syntax highlighting and various tools available for the language.</p>
<p>The drawback of embedding domain specific languages is that we have to adhere
the rules of the programming language we embed in, such as syntactic and semantic rules.</p>
<p>Some languages alleviate this drawback by providing meta-programming capabilities
in the form of macros or other features to extend the language.
And while Haskell does provide such capabilities as well, it is also expressive and concise
enough that many EDSLs do not need them.</p>
<p>Instead, many Haskell EDSLs use a pattern called <em>the combinator pattern</em>:
They define <em>primitives</em> and <em>combinators</em> -
primitives are basic building blocks of the language,
and combinators are functions that combine primitives to more complex structures.</p>
<p>In our HTML EDSL, our primitives are functions such as <code>html_</code> and <code>title_</code>
that can be used to create a single HTML node, and we pass other
constructed nodes as input to these functions, and combine them to a more complex
structure with the append function <code>&lt;&gt;</code>.</p>
<p>There are still a few tricks we can use to make our HTML EDSL better:</p>
<ol>
<li>
<p>We can use Haskell's type system to make sure we only construct <em>valid</em>
HTML (so for example we don't create a <code>&lt;title&gt;</code> node
without a <code>&lt;head&gt;</code> node, or have user content that 
can include unscaped special characters),
and throw a type error when the user tries to do something invalid.</p>
</li>
<li>
<p>We can improve the syntactic structure of the language so it
looks like it is rendered using lists.</p>
</li>
<li>
<p>Our HTML EDSL can move to its own module so it can be reused in multiple modules</p>
</li>
</ol>
<p>In the next few sections we'll take a look at how to define our own types and
how to work with modules to make it harder to make errors, and a little bit
about linked lists in Haskell.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safer-html-construction-with-types"><a class="header" href="#safer-html-construction-with-types">Safer HTML construction with types</a></h1>
<p>In this section we'll learn how to create our own distinguished types
for HTML, and how they can help us avoid invalid construction of HTML strings.</p>
<p>There are a few ways of defining new types in Haskell, in this section
we are going to meet two ways: <code>newtype</code> and <code>type</code>.</p>
<h2 id="newtype"><a class="header" href="#newtype"><code>newtype</code></a></h2>
<p><code>newtype</code> lets us give a new name to an already existing type in a
way that the two cannot mix together.</p>
<p>A <code>newtype</code> declaration looks like this:</p>
<pre><code class="language-hs">newtype &lt;type-name&gt; = &lt;constructor&gt; &lt;existing-type&gt;
</code></pre>
<p>For example in our case we can define a distinct type for <code>Html</code> like this:</p>
<pre><code class="language-hs">newtype Html = Html String
</code></pre>
<p>The first <code>Html</code>, to the left of the equals sign, lives in the <em>types</em>
namespace, meaning that you will only see that name to the right of a
double-colon sign (<code>::</code>).</p>
<p>The second <code>Html</code> lives in the <em>expressions</em> (or terms/values) namespace,
meaning that you will see it where you expect expressions (we'll touch where
exactly that can be in a moment).</p>
<p>The two names, <code>&lt;type-name&gt;</code> and <code>&lt;constructor&gt;</code>, do not have to be the
same, but they often are. And note that both have to start with a
capital letter.</p>
<p>The right-hand side of the newtype declaration describes how an
expression of that type looks like. In our case, we expect a value of
type <code>Html</code> to have the constructor <code>Html</code> and then an expression of
type string, for example: <code>Html &quot;hello&quot;</code> or <code>Html (&quot;hello &quot; &lt;&gt; &quot;world&quot;)</code>.</p>
<p>You can think of the constructor as a function that takes the argument
and returns something of our new type:</p>
<pre><code class="language-hs">Html :: String -&gt; Html
</code></pre>
<p><strong>Note</strong>: We cannot use an expression of type <code>Html</code> the same way we'd
use a <code>String</code>. so <code>&quot;hello &quot; &lt;&gt; Html &quot;world&quot;</code> would fail at type
checking.</p>
<p>This is useful when we want <em>encapsulation</em>. We can define and use
existing representation and functions for our underlying type, but not
mix them with other, unrelated (to our domain) types. Similar as
meters and feet can both be numbers, but we don't want to accidently
add feets to meters without any conversion.</p>
<p>To get this actually working well, we'll need a bit more than just
newtypes. In the next chapter we'll introduce modules and smart constructors.</p>
<p>For now, let's create a couple of types for our use case.
We want two separate types to represent:</p>
<ol>
<li>A complete Html document</li>
<li>A type for nodes that can go inside the <body> tag</li>
</ol>
<p>We want them to be distinct because we don't want to mix them together.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">newtype Html = Html String

newtype Structure = Structure String
</code></pre>
</details>
<h2 id="type"><a class="header" href="#type"><code>type</code></a></h2>
<p>A <code>type</code> definition looks really similar - the only difference is that
we have no constructor:</p>
<pre><code class="language-hs">type &lt;type-name&gt; = &lt;existing-type&gt;
</code></pre>
<p>For example in our case we can write:</p>
<pre><code class="language-hs">type Title = String
</code></pre>
<p><code>type</code>, on the other hand, is just a name alias. so <code>Title</code>
and <code>String</code> are interchangeable. We can use <code>type</code>s
to give a bit more clarity to our code.</p>
<h2 id="using-newtypes"><a class="header" href="#using-newtypes">Using <code>newtype</code>s</a></h2>
<p>Back to <code>newtype</code>s. So how can we use the underlying type? We first
need to extract it out of the type. We do this using pattern matching.</p>
<p>Pattern matching can be used in two ways, in case expressions and in
function definitions.</p>
<ol>
<li>case expressions are kinda beefed up switch expressions and look like this:</li>
</ol>
<pre><code class="language-hs">case &lt;expression&gt; of
  &lt;pattern&gt; -&gt; &lt;expression&gt;
  ...
  &lt;pattern&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>The <code>&lt;expression&gt;</code> is the thing we want to unpack, and the <code>pattern</code>
is it's concrete shape. For example:</p>
<pre><code class="language-hs">getStructureString :: Structure -&gt; String
getStructureString myhbc =
  case myhbc of
    Structure str -&gt; str
</code></pre>
<p>This way we can extract the String out of <code>Structure</code> and return
it.</p>
<p>In later commits we'll introduce <code>data</code> declarations (which are kind of
a struct + enum chimera), where we can define multiple constructors to
a type. Then the multiple patterns of a case expression will make more
sense.</p>
<ol start="2">
<li>Alternatively, when declaring a function, we can also use pattern matching on the
arguments:</li>
</ol>
<pre><code class="language-hs">func &lt;pattern&gt; = &lt;expression&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">getStructureString :: Structure -&gt; String
getStructureString (Structure str) = str
</code></pre>
<p>Using the types we created, we can change the html functions we defined before,
namely <code>html_</code>, <code>body_</code>, <code>p_</code>, etc, to operate on these types instead of <code>String</code>s.</p>
<p>But first let's meet another operator that will make our code more concise.</p>
<h2 id="chaining-functions"><a class="header" href="#chaining-functions">Chaining functions</a></h2>
<p>Another interesting and extremely common operator
(which is a regular library function in Haskell) is <code>.</code> (pronounced compose).
This operator was made to look like the composition operator
you may know from math (<code>∘</code>).</p>
<p>Let's look at its type and implementation:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(.) f g x = f (g x)
</code></pre>
<p>Compose takes 3 arguments: two functions (named <code>f</code> and <code>g</code> here) and
a third argument named <code>x</code>. It then passes the argument <code>x</code> to the second
function <code>g</code>, and calls the first function <code>f</code> with the result of <code>g x</code>.</p>
<p>Note that <code>g</code> takes as input something of the type
<code>a</code> and returns something of the type <code>b</code>, and <code>f</code> takes
something of the type <code>b</code>, and returns something of the type <code>c</code>.</p>
<p>Another important thing to note is that types which start with
a <em>lowercase letter</em> are <strong>type variables</strong>.
Think of them as similar to regular variables. Just like
<code>content</code> could be any string, like <code>&quot;hello&quot;</code> or <code>&quot;world&quot;</code>, a type variable
can be any type: <code>Bool</code>, <code>String</code>, <code>String -&gt; String</code>, etc.</p>
<p>The catch is that type variables must match in a signature, so if for
example we write a function with the type signature <code>a -&gt; a</code>, the
input type and the return type <strong>must</strong> match, but it could be
any type - we cannot know what it is. So the only way to implement a
function with that signature is:</p>
<pre><code class="language-hs">mysteryFunction :: a -&gt; a
mysteryFunction x = x
</code></pre>
<p>If we tried any other way, for example returning some made up value
like <code>&quot;hello&quot;</code>, or try to use <code>x</code> like a value of a type we know like
writing <code>x + x</code>, the type checker will complain.</p>
<p>Also, remember that <code>-&gt;</code> is right associative? This signature is equivalent to:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>Doesn't it look like a function that takes two functions and returns a
third function that is the composition of the two?</p>
<p>We can now use this operator to change or html functions. Let's start
with one example: <code>p_</code>.</p>
<p>Before, we had:</p>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;
</code></pre>
<p>And now, we can write:</p>
<pre><code class="language-hs">p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;
</code></pre>
<p>The function <code>p_</code> will take an arbitrary <code>String</code> which is the content
of the paragraph we wish to create, will wrap it in <code>&lt;p&gt;</code> tags,
and then wrap it in the <code>Structure</code> constructor - producing the
output type <code>Structure</code>.</p>
<p>Let's take a deeper look and see what are the types of the two
functions here are:</p>
<ul>
<li><code>Structure :: String -&gt; Structure</code></li>
<li><code>el &quot;p&quot; :: String -&gt; String</code></li>
<li><code>Structure . el &quot;p&quot; :: String -&gt; Structure</code></li>
<li><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></li>
</ul>
<p>When we try to figure out if an expression type check, we try to match
the types and see if they work. If they are the same type, all is
well. If one of them is a type variable and the other isn't we write
down that the type variable should now be the concrete type, and see
if everything still works.</p>
<p>So in our case we know from the type signature that the input type to
the function <code>String</code> and the output type is <code>Structure</code>, this
means:</p>
<ol>
<li><code>a</code> is equivalent to <code>String</code> (we write <code>~</code> to denote equivalence), and</li>
<li><code>c ~ Structure</code></li>
</ol>
<p>We also know that:</p>
<ol start="3">
<li><code>b ~ String</code> because we pass <code>Structure</code> to <code>.</code> as the first arguments, which means</li>
<li><code>String -&gt; Structure</code> must
match with the type of the first argument of <code>.</code> which is <code>b -&gt; c</code>, so</li>
<li><code>b ~ String</code> which fits with our previous knowledge from (3)</li>
<li><code>-&gt; ~ -&gt;</code></li>
<li><code>c ~ Structure</code> which also fits with (2)</li>
</ol>
<p>We keep doing this process until we come to the conclusion that there
aren't any types that don't match (we don't have two different
concrete types that are supposed to be equivalent).</p>
<h2 id="appending-structure"><a class="header" href="#appending-structure">Appending Structure</a></h2>
<p>Before when we wanted to create richer html content and appended
nodes to one another, we used the append (<code>&lt;&gt;</code>) operator.
Since we are now not using <code>String</code> anymore, we need another way
to do it.</p>
<p>While it is possible to overload <code>&lt;&gt;</code> using a feature in
Haskell called type classes, we will instead create a new function
and call it <code>append_</code>, and cover type classes later.</p>
<p><code>append_</code> should take two <code>Structure</code>s, and return a third <code>Structure</code>,
appending the inner <code>String</code> in the first <code>Structure</code> to the second and wrapping the result back in <code>Structure</code>.</p>
<p>Try implementing <code>append_</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">append_ :: Structure -&gt; Structure -&gt; Structure
append_ (Structure a) (Structure b) =
  Structure (a &lt;&gt; b)
</code></pre>
</details>
<h2 id="converting-back-an-html-to-string"><a class="header" href="#converting-back-an-html-to-string">Converting back an <code>Html</code> to <code>String</code></a></h2>
<p>After constructing a valid <code>Html</code> value, we want to be able to
print it to the output so we can display it in our browser.
For that, we need to write a function that takes an <code>Html</code> and converts it to a <code>String</code>, which we can then pass to <code>putStrLn</code>.</p>
<p>Implement the <code>render</code> function.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<h2 id="the-rest-of-the-owl"><a class="header" href="#the-rest-of-the-owl">The rest of the owl</a></h2>
<p>Try changing the code we wrote in previous chapters to use the new types we created.</p>
<p><strong>Tips</strong>: we can combine <code>makeHtml</code> and <code>html_</code>, and remove <code>body_</code> <code>head_</code> and <code>title_</code>
by calling <code>el</code> directly in <code>html_</code>, which can now have the type <code>Title -&gt; Structure -&gt; Html</code>. This will make our html EDSL less flexible but more compact.</p>
<p>We could, alternatively, create newtypes for <code>HtmlHead</code> and <code>HtmlBody</code> and
pass those to <code>html_</code>, and there is value in doing that, but I've chose
to keep the API a bit simple for now, we can always refactor later!</p>
<details>
  <summary> <b>Solution</b> </summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Header&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<p>All of this is nice and fun. And indeed now we can't write <code>&quot;Hello&quot;</code>
where we'd expect either a paragraph or a header, but we can still
write <code>Structure &quot;hello&quot;</code> and get something that isn't a
paragraph or a header. Next we'll see how we can make this illegal as
well using modules and smart constructors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preventing-incorrect-use-with-modules"><a class="header" href="#preventing-incorrect-use-with-modules">Preventing incorrect use with modules</a></h1>
<p>In this section we will move the Html generation library to its own module.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Each Haskell source file is a module. The module name should have the
same name as the source file and should start with a capital
letter. Sub-directories should also be part of the name and we use <code>.</code>
do denote a sub-directory. We'll see that in the next section.</p>
<p>The only exception to the rule are entry points to the program -
modules with the name 'Main' that define <code>main</code> in them. Their source
file names could have any name they want.</p>
<p>A module declaration looks like this:</p>
<pre><code class="language-hs">module &lt;module-name&gt;
  ( &lt;export-list&gt;
  )
where
</code></pre>
<p>The export list can be omitted if you want to export everything
defined in the module, but we don't. We will list exactly the
functions and type we want to export.</p>
<p>We will create a new source file named <code>Html.hs</code> and add the following
module declaration code at the top of the file:</p>
<pre><code class="language-hs">module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where
</code></pre>
<p>Note that we do not export:</p>
<ol>
<li>
<p>the constructors for our new types, only the types themselves.
If we wanted to export the constructors as well we would've written
<code>Html(Html)</code> or <code>Html(..)</code>. This way the user cannot create their own
<code>Structure</code> simply by writing <code>Structure &quot;Hello&quot;</code>.</p>
</li>
<li>
<p>Internal functions used by the library, such as <code>el</code> and <code>getStructureString</code>.</p>
</li>
</ol>
<p>And we will also move the html related functions from our <code>hello.hs</code> file
to this new <code>Html.hs</code> file:</p>
<pre><code class="language-hs">newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
<p>Now, anyone importing our module (using the <code>import</code> statement which
can be used below module declarations but above any other
declaration), will only be able to import what we export.</p>
<p>Add the following code at the top of the <code>hello.hs</code> file:</p>
<pre><code class="language-hs">import Html
</code></pre>
<p>The <code>hello.hs</code> file should now look like this:</p>
<pre><code class="language-hs">-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Header&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )
</code></pre>
<p>And the <code>Html.hs</code> file should look like this:</p>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escaping-characters"><a class="header" href="#escaping-characters">Escaping characters</a></h1>
<p>Now that <code>Html</code> has its own source file and module, and creating
html code can be done only via the functions we exported,
we can also handle user input that may contain characters we
that may conflict with our meta language html,
such as <code>&lt;</code> and <code>&gt;</code> which are used for creating HTML tags.</p>
<p>We can convert these characters into different strings that HTML can handle.</p>
<p>See <a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html">https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html</a>
for a list of characters we need to escape.</p>
<p>Let's create a new function called <code>escape</code>:</p>
<pre><code class="language-hs">escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
<p>In <code>escape</code> we see a few new things:</p>
<ol>
<li>let expressions - we can define local names using this syntax:</li>
</ol>
<pre><code class="language-hs">let
  &lt;name&gt; = &lt;expression&gt;
in
  &lt;expression&gt;
</code></pre>
<p>This will make <name> available as a variable in the second <expression>.</p>
<ol start="2">
<li>
<p>Pattern matching with multiple patterns - we match on different
characters and convert them to a string. Note that <code>_</code> is a &quot;catch
all&quot; pattern that will always succeed.</p>
</li>
<li>
<p>Two new functions: <code>map</code> and <code>concat</code>, we'll talk about these more in depth</p>
</li>
</ol>
<h2 id="linked-lists-briefly"><a class="header" href="#linked-lists-briefly">Linked lists briefly</a></h2>
<p>Linked lists are a very common data structure in Haskell, so common that
they have their own special syntax:</p>
<ol>
<li>The type for lists are denoted with brackets and inside them is the type of the element. For example:
<ul>
<li><code>[Int]</code> - a list of integers</li>
<li><code>[Char]</code> - a list of characters</li>
<li><code>[String]</code> - a list of strings</li>
<li><code>[[String]]</code> - a list of a list of strings</li>
</ul>
</li>
<li>An expression representing a empty list is written like this: <code>[]</code></li>
<li>Prepending an element to a list is done with the operator <code>:</code> (pronounced cons) which is right-associative (like <code>-&gt;</code>).
For example: <code>1 : []</code>, or <code>1 : 2 : 3 : []</code>.</li>
<li>The above lists can also be written like this: <code>[1]</code> and <code>[1, 2, 3]</code>.</li>
</ol>
<p>Also, Strings are linked lists of chararacters - String is defined as:
<code>type String = [Char]</code>, so we can use them the same way we use lists.</p>
<hr />
<p>Do note, however, that linked lists, despite their convenience, are often
not the right tool for the job. They are not particularily space efficient
and are slow for appending, random access and more. That also makes <code>String</code>
a lot less efficient than it could be. And I generally recommend using a
different string type, <code>Text</code>, instead, which is available in an external package.
We will talk about lists, <code>Text</code>, and other data structures in the future!</p>
<hr />
<p>We can implement our own operations on lists by using pattern matching and recursion.
And we'll touch on this subject later when talking about ADTs.</p>
<p>For now, we will use the various functions found in the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html">Data.List</a> module. Specifically, <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:map">map</a> and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:concat">concat</a>.</p>
<p><code>map</code> applying a function to each of the elements in a list. Its type signature is:</p>
<pre><code class="language-hs">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">map not [False, True, False] == [True, False, True]
</code></pre>
<p>Or as can be seen in our <code>escape</code> function, this can help us escape each character:</p>
<pre><code class="language-hs">map escapeChar ['&lt;','h','1','&gt;'] == [&quot;&amp;lt;&quot;,&quot;h&quot;,&quot;1&quot;,&quot;&amp;gt;&quot;]
</code></pre>
<p>However, note that the <code>escapeChar</code> has the type <code>Char -&gt; String</code>,
so the result type of <code>map escapeChar ['&lt;','h','1','&gt;']</code> is <code>[String]</code>,
and what we really want is a <code>String</code> and not <code>[String]</code>.</p>
<p>This is where <code>concat</code> enters the picture. <code>concat</code> has the type</p>
<pre><code class="language-hs">concat :: [[a]] -&gt; [a]
</code></pre>
<p>It flattens a list of list of something into a list of something.
In our case in will flatten <code>[String]</code> into <code>String</code>, remember that this works
because <code>String</code> is a <strong>type alias</strong> for <code>[Char]</code>, so we actually have
<code>[[Char]] -&gt; [Char]</code>.</p>
<hr />
<h2 id="escaping"><a class="header" href="#escaping">Escaping</a></h2>
<p>The user of our library can currently only supply strings in a few places:</p>
<ol>
<li>Page title</li>
<li>Paragraphs</li>
<li>Headers</li>
</ol>
<p>We can apply our escape function at these places before doing anything else with it.
That way all html constructions are safe.</p>
<p>Try adding the escaping function in those places.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape
</code></pre>
</details>
<hr />
<details>
  <summary><b>Our revised Html.hs</b></summary>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
</details>
<p>Trying constructing an invalid html in <code>hello.hs</code> to see if this works or not!</p>
<p>Now we can use our tiny html library safely. But what if the user
wants to use our library with something we didn't think about, for
example adding unordered lists? We are completely blocking them from
extending our library. We'll talk about this next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exposing-internal-functionality-internal-modules"><a class="header" href="#exposing-internal-functionality-internal-modules">Exposing internal functionality (Internal modules)</a></h1>
<p>When a user runs into trouble with using a library the best course of
actions usually are to open an issue in the repository or submit a pull
request, but sometimes the user needs things to work <em>now</em>.</p>
<p>We admit that we are not perfect and can't think of all use cases for our
library. Sometimes the restrictions we add are too great and may limit
the usage of advanced users that know how things work under the hood and
need certain functionality to present in our library.</p>
<p>For that we can expose internal modules to provide some flexibility for
advanced users. Internal modules are not a language concept but
rather a (fairly common) design pattern in Haskell.</p>
<p>Internal modules are simply modules named <code>Internal</code>.
These modules are considered risky to use by convention.
Internal modules will export all of the functionality in a
module, and we will add another module without the <code>Internal</code> suffix
which will import from our internal module and only export the api
we'd like to export.</p>
<p>Internal modules should be considered unstable and risky to use. If
you end up using one, make sure to open a ticket in the library after
the storm has passed!</p>
<p>We will create a new directory named <code>Html</code> and inside it a new file
named <code>Internal.hs</code>. The name of this module should be <code>Html.Internal</code>.</p>
<p>This module will contain all of the code that was previously in the <code>Html</code>
module, but <strong>we will change the module declaration in <code>Html.Internal</code>
and <em>omit</em> the export list</strong>:</p>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

...
</code></pre>
<p>And now in <code>Html.hs</code>, we will remove the code that we moved to <code>Html/Internal.hs</code>
and in its stead we'll import the internal module:</p>
<pre><code class="language-hs">-- Hello.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where
</code></pre>
<p>Now, users of our library can still import <code>Html</code> and safely use our library,
but if they run into trouble and have a dire need to implement unordered lists
to work with our library, they could always work with <code>Html.Internal</code> instead.</p>
<details>
  <summary><b>Our revised Html.hs and Html/Internal.hs</b></summary>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
where

import Html.Internal
</code></pre>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>We need a few more features for our html library to be useful for
our blog software. Add the following features to our <code>Html.Internal</code> module
and expose them from <code>Html</code>.</p>
<h2 id="1-unordered-lists"><a class="header" href="#1-unordered-lists">1. Unordered lists</a></h2>
<p>These lists have the form:</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>We want in our library a new function:</p>
<pre><code class="language-hs">ul_ :: [Structure] -&gt; Structure
</code></pre>
<p>So that users can write this:</p>
<pre><code class="language-hs">ul_
  [ p_ &quot;item 1&quot;
  , p_ &quot;item 2&quot;
  , p_ &quot;item 3&quot;
  ]
</code></pre>
<p>and get this:</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;item 1&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;item 2&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;item 3&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h2 id="2-ordered-lists"><a class="header" href="#2-ordered-lists">2. Ordered lists</a></h2>
<p>Very similar to unordered lists, but instead of <code>&lt;ul&gt;</code> we use <code>&lt;ol&gt;</code></p>
<h2 id="3-code-blocks"><a class="header" href="#3-code-blocks">3. Code blocks</a></h2>
<p>Very similar to <code>&lt;p&gt;</code>, but use the <code>&lt;pre&gt;</code> tag. Call this function <code>code_</code>.</p>
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<details>
  <summary>Unordered lists</summary>
<pre><code class="language-hs">ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)
</code></pre>
</details>
<details>
  <summary>Ordered lists</summary>
<pre><code class="language-hs">ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)
</code></pre>
<p>Note: the two functions above could be unified.</p>
</details>
<details>
  <summary>Code blocks</summary>
<pre><code class="language-hs">code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>In this chapter we built a very minimal HTML EDSL.
We will later use this library to convert our custom markup formatted text to HTML.</p>
<p>We've also learned about:</p>
<ul>
<li>Defining and using functions</li>
<li>Types and type signatures</li>
<li>Embedded domain specific languages</li>
<li>Chaining functions using the <code>.</code> operator</li>
<li>Preventing incorrect use with <code>newtype</code>s</li>
<li>Defining modules and the <code>Internal</code> module pattern</li>
<li>Encapsulation using <code>newtype</code>s and modules</li>
</ul>
<p>Here's our complete program up to this point:</p>
<pre><code class="language-hs">-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Header&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )
</code></pre>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , h1_
  , p_
  , ul_
  , ol_
  , code_
  , append_
  , render
  )
where

import Html.Internal
</code></pre>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)

ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)

code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-markup-language"><a class="header" href="#custom-markup-language">Custom markup language</a></h1>
<p>In this chapter we will define our own simple markup language
and parse documents written in this language into Haskell data structures.</p>
<p>Our simple markup language will contain the following features:</p>
<ul>
<li>Headers - prefix by a number of <code>*</code> characters</li>
<li>Paragraphs - a group of lines without empty lines in between</li>
<li>Unordered lists - a group of lines each prefixed with <code>- </code></li>
<li>Unordered lists - a group of lines each prefixed with <code># </code></li>
<li>Code blocks - a group of lines each prefixed with <code>&gt; </code></li>
</ul>
<p>Here's a sample document which we will use as an example:</p>
<pre><code class="language-org">* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; ➜ ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main, or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
</code></pre>
<p>Which we will, eventually, want to convert into this (modulo formatting) html:</p>
<pre><code class="language-html">&lt;h1&gt;Compiling programs with ghc&lt;/h1&gt;

&lt;p&gt;Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.
&lt;/p&gt;

&lt;p&gt;Create a new Haskell source file named hello.hs, and write
the following code in it:
&lt;/p&gt;

&lt;pre&gt;main = putStrLn &quot;Hello, Haskell!&quot;
&lt;/pre&gt;

&lt;p&gt;Now, we can compile the program by invoking ghc with the file name:&lt;/p&gt;

&lt;pre&gt;
➜ ghc hello.hs
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...
&lt;/pre&gt;

&lt;p&gt;GHC created the following files:
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hello.hi - Haskell interface file&lt;/li&gt;
  &lt;li&gt;hello.o - Object file, the output of the compiler before linking&lt;/li&gt;
  &lt;li&gt;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GHC will produce an executable when the source file satisfies both conditions:
&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Defines the main function in the source file&lt;/li&gt;
  &lt;li&gt;Defines the module name to be Main, or does not have a module declaration&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Otherwise, it will only produce the .o and .hi files.
&lt;/p&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="representing-the-markup-language-as-a-haskell-data-type"><a class="header" href="#representing-the-markup-language-as-a-haskell-data-type">Representing the markup language as a Haskell data type</a></h1>
<p>One of the clear differentiators between Haskell and other ML-family of languages
from most mainstream languages is the ability to represent data precisely and succinctly.</p>
<p>So how do we represent our markup language using Haskell?</p>
<p>Previously, in our HTML builder library, we used <code>newtype</code>s to differentiate
between html documents, structures and titles, but we didn't really need to
differentiate between different kinds of structures such as paragraphs and headers,
not without parsing the data at least.</p>
<p>In this case, we have a list of structures, and each structure could be
one of a few specific options (a paragraph, a header, a list, etc),
and we want to be able to know which structure is which so we can easily
convert it into the equivalent HTML representation.</p>
<p>For that, we have <code>data</code> definitions. <code>data</code> gives us the ability to
create custom types by grouping multiple types together and having
alternative structures. Think of them as combination of both structs and enums.</p>
<p><code>data</code> declarations look like this:</p>
<pre><code class="language-hs">data &lt;Type-name&gt; &lt;type-args&gt;
  = &lt;Data-constructor1&gt; &lt;types&gt;
  | &lt;Data-constructor2&gt; &lt;types&gt;
  | ...
</code></pre>
<p>It looks really similar to <code>newtype</code>, but there are two important
differences:</p>
<ol>
<li>In the <types> part we can write many types (Like <code>Int</code>, <code>String</code>, or <code>Bool</code>).
For <code>newtype</code>s we can only write one.</li>
<li>We can have alternative structures using <code>|</code>, <code>newtype</code>s have no
alternatives.</li>
</ol>
<p>This is because <code>newtype</code>s is used to provide a type safe <strong>alias</strong>,  and <code>data</code>
is used to build a new <strong>composite</strong> type that can potentially have <em>alternatives</em>.</p>
<p>Let's see a couple of examples of data types:</p>
<ol>
<li>
<p>Bool</p>
<pre><code class="language-hs">data Bool
  = True
  | False
</code></pre>
<p>We created a new data type named <code>Bool</code> with the possible values <code>True</code> or <code>False</code>.
In this case we only have <em>constructor</em> alternatives and none of the alternatives
carriers additional values, this is similar to enums in other languages.</p>
</li>
<li>
<p>Person</p>
<pre><code class="language-hs">data Person
  = Person String Int -- where the first is the name and the second is
                      -- the age
</code></pre>
<p>We created a new data type named <code>Person</code>. Values of the type <code>Person</code>
look like this:</p>
<pre><code>Person &lt;some-string&gt; &lt;some-int&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">Person &quot;Gil&quot; 32
</code></pre>
<p>In this case we create a <em>composite</em> of multiple types, without alternatives.
This is similar to structs in other language, but structs give each field
a name, and here we distinguish them by position.</p>
<p>Alternatively, Haskell has <em>syntactic sugar</em> for naming fields called <strong>records</strong>.
The above definition can also be written like this:</p>
<pre><code class="language-hs">data Person
  = Person
    { name :: String
    , age :: Int
    }
</code></pre>
<p>Values of this type can be written exactly as before,</p>
<pre><code class="language-hs">Person &quot;Gil&quot; 32
</code></pre>
<p>Or with this syntax:</p>
<pre><code class="language-hs">Person { name = &quot;Gil&quot;, age = 32 }
</code></pre>
<p>Haskell will also generate functions that can be used to extract the fields from the composite type:</p>
<pre><code class="language-hs">name :: Person -&gt; String
age :: Person -&gt; Int
</code></pre>
<p>Which can be used like this:</p>
<pre><code class="language-hs">ghci&gt; age (Person { name = &quot;Gil&quot;, age = 32 })
32
</code></pre>
<p>Unfortunately, this also means that if we defined a different data type with the field
<code>age</code>, the functions which GHC needs to generate will clash.</p>
<p>The easiest way to solve this is to give fields unique names, for example
by adding a prefix:</p>
<pre><code class="language-hs">data Person
  = Person
    { pName :: String
    , pAge :: Int
    }
</code></pre>
<p>Another way is by using extensions to the Haskell language, which we will cover
in later chapters.</p>
</li>
<li>
<p>Tuple</p>
<pre><code class="language-hs">data Tuple a b
  = Tuple a b
</code></pre>
<p>This is pretty similar to <code>Person</code>, but we can plug any type we want
for this definition. For example:</p>
<pre><code class="language-hs">Tuple &quot;Clicked&quot; True :: Tuple String Bool

Tuple 'a' 'z' :: Tuple Char Char
</code></pre>
<p>This type has special syntax in Haskell:</p>
<pre><code class="language-hs">(&quot;Clicked&quot;, True) :: (String, Bool)

('a', 'z') :: (Char, Char)
</code></pre>
<p>This <code>Tuple</code> definition is polymorphic, we define the structure but are able to
plug different types into the structure to get concerete types. This about <code>Tuple</code>
as just a <em>template</em> for a data type waiting to be filled, or as a <strong>function</strong> waiting
for types as input in order to return a data type. We can even take a look at the &quot;type&quot;
signature of <code>Tuple</code> in <code>ghci</code> using the <code>:kind</code> command.</p>
<pre><code class="language-hs">ghci&gt; data Tuple a b = Tuple a b
ghci&gt; :kind Tuple
Tuple :: * -&gt; * -&gt; *
</code></pre>
<hr />
<h4 id="quick-detour-kinds"><a class="header" href="#quick-detour-kinds">Quick detour: Kinds</a></h4>
<p>The <code>:kind</code> command is called as such because the &quot;type&quot; of a type is called a <strong>kind</strong>.
Kinds can be one of two things, either a <code>*</code> which means a saturated (or concrete) type,
such as <code>Int</code> or <code>Person</code>, or an <code>-&gt;</code> of two kinds, which is, as you might have guessed,
a type function, taking kind and returning a kind.</p>
<p>Note that only types that have the kind <code>*</code> can have values. So for example while <code>Tuple Int</code>
is a valid Haskell concept that has the <em>kind</em> <code>* -&gt; *</code>, and we can write code that will
work &quot;generically&quot; for all types that have a certain kind (e.g. <code>* -&gt; *</code>), we cannot
construct a value that will have the kind <code>* -&gt; *</code>. All values have types, and all
such types that have values has the kind <code>*</code>.</p>
<p>We will talk about kinds later, for now let's focus on types!</p>
<hr />
</li>
<li>
<p>Either</p>
<pre><code class="language-hs">data Either a b
  = Left a
  | Right b
</code></pre>
<p>Similar to Tuple but instead of having only one constructor, we have
two. This means that we can choose which side we want. Here are a
couple of Values of type <code>Either String Int</code>:</p>
<pre><code class="language-hs">Left &quot;Hello&quot;

Right 17
</code></pre>
<p>This type is useful for modeling errors. Either we succeeded and got
what we wanted (The <code>Right</code> constructor with the value), or we didn't
and got an error instead (The <code>Left</code> constructor with a string or a
custom error type).</p>
</li>
</ol>
<p>Here we use it to model the different kinds of content types we have
in our markup language. We tag each structure using the data constructor
and provide the rest of the information (the paragraph text, the list items, etc)
in the <code>&lt;types&gt;</code> section of the data declaration for each constructor:</p>
<pre><code class="language-hs">type Document
  = [Structure]

data Structure
  = Header Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
</code></pre>
<p>Note: <code>Natural</code> is defined in the <code>base</code> package but not exported from <code>Prelude</code>.
Find out which module to import <code>Natural</code> from using <a href="https://hoogle.haskell.org">hoogle</a>.</p>
<hr />
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<p>Represent the following markup documents as value of <code>Document</code>:</p>
<ol>
<li>
<pre><code class="language-org">Hello, world!
</code></pre>
</li>
<li>
<pre><code class="language-org">* Welcome

To this tutorial about Haskell.
</code></pre>
</li>
<li>
<pre><code class="language-org">Remember that multiple lines with no separation
are grouped together to a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
</code></pre>
</li>
<li>
<pre><code class="language-org">* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; ➜ ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main, or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
</code></pre>
</li>
</ol>
<p>Solutions:</p>
<details>
  <summary>Solution 1</summary>
<pre><code class="language-hs">doc :: Document
doc =
  [ Paragraph &quot;Hello, world!&quot;
  ]
</code></pre>
</details>
<details>
  <summary>Solution 2</summary>
<pre><code class="language-hs">doc :: Document
doc =
  [ Header 1 &quot;Welcome&quot;
  , Paragraph &quot;To this tutorial about Haskell.&quot;
  ]
</code></pre>
</details>
<details>
  <summary>Solution 3</summary>
<pre><code class="language-hs">doc :: Document
doc =
  [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot;
  , OrderedList
    [ &quot;Item 1 of a list&quot;
    , &quot;Item 2 of the same list&quot;
    ]
  ]
</code></pre>
</details>
<details>
  <summary>Solution 4</summary>
<pre><code class="language-hs">doc :: Document
doc =
  [ Header 1 &quot;Compiling programs with ghc&quot;
  , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot;
  , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot;
  , CodeBlock
    [ &quot;main = putStrLn \&quot;Hello, Haskell!\&quot;&quot;
    ]
  , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot;
  , CodeBlock
    [ &quot;➜ ghc hello.hs&quot;
    , &quot;[1 of 1] Compiling Main             ( hello.hs, hello.o )&quot;
    , &quot;Linking hello ...&quot;
    ]
  , Paragraph &quot;GHC created the following files:&quot;
  , UnorderedList
    [ &quot;hello.hi - Haskell interface file&quot;
    , &quot;hello.o - Object file, the output of the compiler before linking&quot;
    , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot;
    ]
  , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot;
  , OrderedList
    [ &quot;Defines the main function in the source file&quot;
    , &quot;Defines the module name to be Main, or does not have a module declaration&quot;
    ]
  , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot;
  ]
</code></pre>
</details>
<p>Add a new module named <code>Markup</code> and add the data type definition to it.
Note that in this case we <em>do</em> want to export the constructors of <code>Structure</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  )
where

import Numeric.Natural

type Document
  = [Structure]

data Structure
  = Header Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
</code></pre>
</details>
<hr />
<p>You might ask &quot;Why do we even need to represent the markup as a type?
Why don't we convert it into html as soon as we parse it
instead?&quot;. That's a good question and a valid strategy. The reason we
first represent it as a Haskell type is for flexibility and
modularity.</p>
<p>If the parsing code is coupled with html generation, we lose the
ability to preprocess the markup document. For example we might want
to take only a small part of the document (for summary) and present
it, or create a table of content from headers. Or maybe we'd like to
add other targets and not just html - maybe markdown format or a gui reader?</p>
<p>Parsing to an &quot;abstract data type&quot; (ADT) representation (one that does
not contain the details of the language, that for example that we use '#' for
ordered lists) gives us the freedom to do so much more than just
converting to html that it's usually worth it in my opinion unless you
really need to optimize the process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-markup-part-01-recursion"><a class="header" href="#parsing-markup-part-01-recursion">Parsing markup part 01 (Recursion)</a></h1>
<p>Let's have a look at how to parse a multi-lined string of markup text
written by a user and convert it to the <code>Document</code> type we defined
in the previous chapter.</p>
<p>Our strategy is to take the string of markup text, and:</p>
<ol>
<li>Split it to a list where each element is a separate line, and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>So the first thing we want to do is to process the string line by line.
We can do that by converting the string to a list of string.
Fortunately the Haskell
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>Prelude</code></a>
module from the Haskell standard library
<a href="https://hackage.haskell.org/package/base"><code>base</code></a> exposes the function
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>lines</code></a>
that does exactly what we want. The <code>Prelude</code> module is exposed in every
Haskell file by default so we don't need to import it.</p>
<p>For the line processing part, let's start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<p>A common solution in imperative programs would be to iterate over the lines
using some <em>loop</em> construct and accumulate lines that should be grouped together
into some intermediate mutable variable. When we reach an empty line, we insert
the content of that variable into another mutable variable that accumulates the
results.</p>
<p>Our approach in Haskell isn't so different, except that we do not use loops
or mutable variables. Instead, we use <strong>recursion</strong>.</p>
<h2 id="recursion-and-accumulating-information"><a class="header" href="#recursion-and-accumulating-information">Recursion and accumulating information</a></h2>
<p>Instead of loops, in Haskell we use recursion to model iteration.</p>
<p>Consider the following contrived example: let's say that
we want to write an algorithm for adding two natural numbers together,
and we don't have a standard operation to do that (+), but we do
have two operations we could do for each number: <code>increment</code>
and <code>decrement</code>.</p>
<p>A solution we could come up with is to slowly &quot;pass&quot; one number
to the other number iteratively, by incrementing one, and decrementing the other.
And we do that until the number we decrement reaches 0.</p>
<p>For example for <code>3</code> and <code>2</code>:</p>
<ul>
<li>We start with <code>3</code> and <code>2</code>, and we increment <code>3</code> and decrement <code>2</code></li>
<li>On the next step we now have <code>4</code> and <code>1</code>, we increment <code>4</code> and decrement <code>1</code></li>
<li>On the next step we now have <code>5</code> and <code>0</code>, since the second number is <code>0</code> we declare <code>5</code> as the result.</li>
</ul>
<p>This can be written imperatively using a loop:</p>
<pre><code class="language-js">function sum(n, m) {
    while (m /= 0) {
        n = increment(n);
        m = decrement(m);
    }
    return n;
}
</code></pre>
<p>We can write the same algorithm in Haskell without mutation using recursion:</p>
<pre><code class="language-hs">sum n m =
    if m /= 0
        then sum (increment n) (decrement m)
        else n
</code></pre>
<p><strong>In order to emulate iteration with mutable state, we call the function again
with the values we want the variables to have in the next iteration.</strong></p>
<h3 id="evaluation-of-recursion"><a class="header" href="#evaluation-of-recursion">Evaluation of recursion</a></h3>
<p>Recursion commonly has a bad reputation for being slow and possibly unsafe compared to loops.
This is because in imperative languages, calling a function often requires creating
a new call stack.</p>
<p>However, functional languages (and Haskell in particular) play by different
rules and implement a feature called tail call elimination - when the result of a function call
is the result of this function (this is called tail position), we can just drop the current function
stack frame and then allocate one for the function we call, so we don't require <code>N</code> stack frames
for <code>N</code> iterations.</p>
<p>This is of course only one way to do tail call elimination and other
strategies exists, such as translating code like our recursive <code>sum</code> above to the iteration version.</p>
<h4 id="laziness"><a class="header" href="#laziness">Laziness</a></h4>
<p>Haskell plays by slightly different rules because it uses a lazy evaluation strategy
instead of the much more common strict evaluation strategy. An evaluation strategy
refers to &quot;when do we evaluate a computation&quot;. In a strict language the answer is simple:
<em>we evaluate the arguments of a function before entering a function</em>.</p>
<p>So for example the evaluation of <code>sum (increment 3) (decrement 2)</code> using strict evaluation
will look like this:</p>
<ol>
<li>Evaluate <code>increment 3</code> to <code>4</code></li>
<li>Evaluate <code>decrement 2</code> to <code>1</code></li>
<li>Evaluate <code>sum 4 1</code></li>
</ol>
<p>Or, alternatively (depending on the language) we reverse (1) and (2) and evaluate the arguments
from right-to-left instead of left-to-right.</p>
<p>On the other hand, with lazy evaluation, we <em>only evaluate computation when we need it</em>, where
'<em>when do we need it?</em>' is when it is part of a computation that will have some effect on the
outside world, for example when writing a computation to standard output or sending it over the network.</p>
<p>So unless this computation is required, it won't be evaluated. For example:</p>
<pre><code class="language-hs">main =
    if sum (increment 2) (decrement 3) == 5
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p>In the case above, we need the result of <code>sum (increment 2) (decrement 3)</code>
in order to know which message to write,
so it will be evaluated. But:</p>
<pre><code class="language-hs">main =
    let
        five = sum (increment 2) (decrement 3)
    in
        putStrLn &quot;Not required&quot;
</code></pre>
<p>In the case above we don't actually need <code>five</code>, so we don't evaluate it!</p>
<p>But then if we know we need <code>sum (increment 2) (decrement 3)</code>,
do we use strict evaluation now? The answer is no - because we might not need
them to complete the computation. For example in this case:</p>
<pre><code class="language-hs">const a b = a

main =
    if const (increment 2) (decrement 3) == 3
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p><code>const</code> ignores the second argument and returns the first, so we don't actually need
to calculate <code>decrement 3</code> in order to provide an answer to the computation and in
turn output an answer to the screen.</p>
<p>So in lazy evaluation we will evaluate expressions when we need to (they are required
in order to do something for the user), and we evaluate from the outside in - first
we enter functions, and then we evaluate the arguments when we need to (usually when the thing
we want to evaluate appears in some control flow such as the condition of an <code>if</code> expression
or a pattern in pattern matching).</p>
<hr />
<p>I've written a more in-depth blog post about how this works in Haskell:
<a href="https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning">Substitution and Equational Reasoning</a>.</p>
<p>Please read it and try to evalute the following program by hand:</p>
<pre><code class="language-hs">import Prelude hiding (const, sum) -- feel free to ignore this line

increment n = n + 1

decrement n = n - 1

const a b = a

sum n m =
    if m /= 0
        then sum (increment n) (decrement m)
        else n

main =
    if const (sum 3 2) (decrement 3) == 5
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p>Remember that evaluation always begins from <code>main</code>.</p>
<details>
  <summary>Solution</summary>
<p>evaluating <code>main</code></p>
<pre><code class="language-hs">if const (sum 3 2) (decrement 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>const</code></p>
<pre><code class="language-hs">if sum 3 2 == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>sum</code></p>
<pre><code class="language-hs">if (if 2 /= 0 then sum (increment 3) (decrement 2) else 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>evaluating the control flow <code>2 /= 0</code></p>
<pre><code class="language-hs">if (if True then sum (increment 3) (decrement 2) else 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if (sum (increment 3) (decrement 2)) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>sum</code></p>
<pre><code class="language-hs">if
    ( if decrement 2 /= 0
        then sum
            (increment (increment 3))
            (decrement (decrement 2))
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating <code>decrement 2</code> in the control flow (notice how both places change!)</p>
<pre><code class="language-hs">if
    ( if 1 /= 0
        then sum
            (increment (increment 3))
            (decrement 1)
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating the control flow <code>1 /= 0</code></p>
<pre><code class="language-hs">if
    ( if True
        then sum
            (increment (increment 3))
            (decrement 1)
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if
    ( sum
        (increment (increment 3))
        (decrement 1)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Expanding <code>sum</code></p>
<pre><code class="language-hs">if
    ( if decrement 1 /= 0
        then sum
            (increment (increment (increment 3)))
            (decrement (decrement 1))
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>decrement 1</code></p>
<pre><code class="language-hs">if
    ( if 0 /= 0
        then sum
            (increment (increment (increment 3)))
            (decrement 0)
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>0 /= 0</code></p>
<pre><code class="language-hs">if
    ( if False
        then sum
            (increment (increment (increment 3)))
            (decrement 0)
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>else</code> branch</p>
<pre><code class="language-hs">if
    (increment (increment 3)) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate control flow <code>increment (increment 3)</code></p>
<pre><code class="language-hs">if
    (increment 3 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>increment 3</code></p>
<pre><code class="language-hs">if
    (3 + 1 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>3 + 1</code></p>
<pre><code class="language-hs">if
    (4 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>4 + 1</code></p>
<pre><code class="language-hs">if
    5 == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>5 == 5</code></p>
<pre><code class="language-hs">if
    True
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">putStrLn &quot;Yes.&quot;
</code></pre>
<p>Which when run will print <code>Yes.</code> to the screen.</p>
</details>
<hr />
<h3 id="general-recursion"><a class="header" href="#general-recursion">General recursion</a></h3>
<p>In general, when trying to solve problems recursively, it is useful to think
about the problem in three parts:</p>
<ol>
<li>Finding the <strong>base case</strong> (the most simple cases - the ones I already know how to answer)</li>
<li>Figuring out how to <strong>reduce</strong> the problem to something simpler (so it gets closer to the base case)</li>
<li><strong>Mitigating the difference</strong> between the reduced version and the solution I need to provide</li>
</ol>
<p>The reduce and mitigate steps together are usually called the recursive step.</p>
<p>Let's take a look at another example problem: generating a list of a particular size
with a specific value in place of every element.</p>
<p>In Haskell, this function would have the following signature:</p>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
</code></pre>
<p>Here are a few examples using in:</p>
<pre><code class="language-hs">ghci&gt; replicate 4 True
[True,True,True,True]
ghci&gt; replicate 0 True
[]
ghci&gt; replicate (-13) True
[]
</code></pre>
<p>How would we implement this function recursively? How would describe it in three steps above?</p>
<ol>
<li><strong>Base case</strong>: the cases I already know how to generate are the cases where the length
of the list is zero (or less) - we just return an empty list.</li>
<li><strong>Reduce</strong>: while I don't know how to generate a list of size <code>N</code> (where <code>N</code> is positive),
if I knew the solution for <code>N-1</code> I could:</li>
<li><strong>Mitigate</strong>: Add another element to the solution for <code>N-1</code> using the <code>:</code> (cons) operator.</li>
</ol>
<p>Try to write this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
replicate n x =
    if n &lt;= 0        -- recognizing the base case
        then
            []       -- the solution for the base case
        else
            x : replicate (n - 1) x
    --      --- -------------------
    --       ^           ^
    --       |           |
    --       |           +-------- reduction
    --       |
    --       +--- mitigation
</code></pre>
</details>
<h3 id="mutual-recursion"><a class="header" href="#mutual-recursion">Mutual recursion</a></h3>
<p>When solving functions recursively we usually call the same function again,
but that doesn't have to be the case. It is possible to reduce our problem
to something simpler that requires an answer from a different function.
If, in turn, that function will (or another function in that call chain)
call our function again, we have a <strong>mutual recursive</strong> solution.</p>
<p>For example, let's write two functions, one that checks whether a natural number
is even or not, and one that checks whether a number is odd or not
by only decrementing it.</p>
<pre><code class="language-hs">even :: Int -&gt; Bool

odd :: Int -&gt; Bool
</code></pre>
<p>Let's start with <code>even</code>, how should we solve this recursively?</p>
<ol>
<li><strong>Base case</strong>: I know the answer for <code>0</code> - it is <code>True</code>.</li>
<li><strong>Reduction</strong>: I don't know the answer for a general <code>N</code>, but I could check whether <code>N - 1</code> is odd,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is odd, then <code>N</code> is even! if it isn't odd, then <code>N</code> isn't even.</li>
</ol>
<p>What about <code>odd</code>?</p>
<ol>
<li><strong>Base case</strong>: I know the answer for <code>0</code> - it is <code>False</code>.</li>
<li><strong>Reduction</strong>: I don't know the answer for a general <code>N</code>, but I could check whether <code>N - 1</code> is even,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is even, then <code>N</code> is odd! if it isn't even, then <code>N</code> isn't odd.</li>
</ol>
<p>Try writing this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">even :: Int -&gt; Bool
even n =
    if n == 0
        then
            True
        else
            odd (n - 1)

odd :: Int -&gt; Bool
odd n =
    if n == 0
        then
            False
        else
            even (n - 1)

</code></pre>
</details>
<h2 id="partial-functions"><a class="header" href="#partial-functions">Partial functions</a></h2>
<p>because we didn't handle negative cases in the example above, our functions will loop forever
when a negative value is passed as input. A function that does not return a result for some value
(either by not terminating or by throwing an error) is called <strong>a partial function</strong>
(because it only returns a result of a part of the possible inputs).</p>
<p>partial functions are generally considered <strong>bad practice</strong> because they can have
unexpected behaviour at runtime, so we want to <strong>avoid using</strong> partial functions
as well as <strong>avoid writing</strong> partial functions.</p>
<p>The best way to avoid writing partial functions is by covering all inputs!
In the situation above, it is definitely possible to handle negative numbers
as well, so we should do that!</p>
<p>There are cases where we can't possibly cover all inputs, but it is sometimes
possible to mitigate that by restricting the inputs further using the type system.</p>
<p>For example, the <code>head :: [a] -&gt; a</code> function in <code>Prelude</code> promises
to return the first element (the head) of a list, but we know that lists
could possibly be empty, so how can this function deliver on its promise?</p>
<p>Unfortunately, it can't. But there exists a different function that can:
<code>head :: NonEmpty a -&gt; a</code> from the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List-NonEmpty.html"><code>Data.List.NonEmpty</code></a>
module! The trick here is that this other <code>head</code> does not take a general list
as input, it takes a different type entirely, one that promises to have
at least one element, and therefore can deliver on its promise!</p>
<p>We could also potentially use smart constructors with <code>newtype</code> and enforce some sort
of a restriction in the type system, as we saw in earlier chapters.
But this solution can sometimes be less ergonomic to use.</p>
<p>An alternative approach is to use <code>data</code> types to encode the absence of a proper result,
for example, using <code>Maybe</code>, as we'll see in a future chapter.</p>
<h2 id="parsing-markup"><a class="header" href="#parsing-markup">Parsing markup?</a></h2>
<p>Let's get back to the task at hand.</p>
<p>As stated previously, our strategy for parsing the markup text is:</p>
<ol>
<li>Split the string to a list where each element is a separate line (which we can do with <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>lines</code></a>), and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>Remember that we want to start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines -- (1)

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)
  in
    case txts of
      [] -&gt; [paragraph]
      currentLine : rest -&gt;
        if trim currentLine == &quot;&quot;
          then
            paragraph : parseLines [] rest -- (4)
          else
            parseLines (currentLine : currentParagraph) rest -- (5)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Things to note:</p>
<ol>
<li>We pass a list that contains the currently grouped paragraph (paragraphs are seperated by an empty line)</li>
<li>Because of laziness, <code>paragraph</code> is not computed until it's needed, so we don't have to worry about
the performance implications in the case the we are still grouping lines</li>
<li>Why do we reverse <code>currentParagraph</code>? (See point (5))</li>
<li>When we run into an empty line we add the accumulated paragraph to the resulting list (A <code>Document</code> is a list of structures) and start the function again with the rest of the input.</li>
<li>We pass the new lines to be grouped in a paragraph <strong>in reverse order</strong> because of
performance characteristics - because of the nature of singly-linked lists,
prepending an element is fast, and appending is slow. Prepending only requires
us to create a new cons (<code>:</code>) cell to hold a pointer to the value and a pointer to the list,
but appending requires us to traverse the list to its end and rebuild the cons cells -
the last one will contain the last value of the list and a pointer to the list to append,
the next will contain the value before the last value of the list and a pointer to the
list which contains the last element and the appended list, and so on.</li>
</ol>
<p>This code above will group together paragraphs in a structure, but how do we view our result?
In the next chapter will take a short detour and talk a bit about type classes, and how
they can help us in this scenario.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="displaying-the-parsing-results-typeclasses"><a class="header" href="#displaying-the-parsing-results-typeclasses">Displaying the parsing results (typeclasses)</a></h1>
<p>We want to be able to print a textual representation of values
of our <code>Document</code> type. There are a few ways to do that:</p>
<ol>
<li>Write our own function of type <code>Document -&gt; String</code> which we could then print, or</li>
<li>Have Haskell write one for us</li>
</ol>
<p>Haskell provides us with mechanism that can automatically generates the implementation of a
<em>typeclass</em> function called <code>show</code>, that will convert our type to <code>String</code>.</p>
<p>The type of the function <code>show</code> looks like this:</p>
<pre><code class="language-hs">show :: Show a =&gt; a -&gt; String
</code></pre>
<p>This is something new we haven't seen before. Between <code>::</code> and <code>=&gt;</code>
you see what is called a <strong>type class constraint</strong> on the type <code>a</code>. What
we say in this signature, is that the function <code>show</code> can work on any
type that is a member of the type class <code>Show</code>.</p>
<p>Type classes is a feature in Haskell that allows us to declare common
interface for different types. In our case, Haskell's standard library
defines the type class <code>Show</code> in the following (this is a simplified
version but good enough for our purposes):</p>
<pre><code class="language-hs">class Show a where
  show :: a -&gt; String
</code></pre>
<p>This means that we have now declared a common interface for Haskell
types that want it. Any time that wants to implement it needs to
define an <em>instance</em> for the type class. For example:</p>
<pre><code class="language-hs">instance Show Bool where
  show x =
    case x of
      True -&gt; &quot;True&quot;
      False -&gt; &quot;False&quot;
</code></pre>
<p>If all the types we use while defining our data type already implement
this, we can automatically derive it by adding <code>deriving Show</code> at the
end of the data definition.</p>
<pre><code class="language-hs">data Structure
  = Header Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving Show
</code></pre>
<p>Now we can use the function <code>show :: Show a =&gt; a -&gt; String</code> for any
type that implements an instance of the <code>Show</code> typeclass. For example, with print:</p>
<pre><code class="language-hs">print :: Show a =&gt; a -&gt; IO ()
print = putStrLn . show
</code></pre>
<p>We can first convert our type to <code>String</code> and then write it to the
standard output.</p>
<p>And because lists also implement <code>Show</code> for any element type that has
a <code>Show</code> instance, we can now print <code>Document</code>s, because they are just
aliases for <code>[Structure]</code>. Try it!</p>
<p>There are many type classes Haskellers use everyday. A couple more are
<code>Eq</code> for equality and <code>Ord</code> for ordering.</p>
<p>Typeclasses often come with &quot;rules&quot; or &quot;laws&quot; that instances should satisfy,
the purpose of these laws is to provide <em>predictable behaviour</em> across
instances, so that when we run into a new instance we can be confident
that it will behave in a certain expected way.</p>
<p>As an example, let's look at the <code>Semigroup</code> typeclass:</p>
<pre><code class="language-hs">class Semigroup a where
  (&lt;&gt;) :: a -&gt; a -&gt; a
</code></pre>
<p>This typeclass provides a common interface for types with an operation <code>&lt;&gt;</code>
that can combine two values into one in some way.</p>
<p>This typeclass also mentions that this <code>&lt;&gt;</code> operation should be associative,
meaning that these two sides should evaluate to the same result:</p>
<pre><code>x &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z
</code></pre>
<p>An example of a lawful instance of <code>Semigroup</code> is lists with the append operation (<code>++</code>):</p>
<pre><code class="language-hs">instance Semigroup [a] where
  (&lt;&gt;) = (++)
</code></pre>
<p>Unfortunately the Haskell type system cannot &quot;prove&quot; that instances
satisfy these laws, but as a community we often shun unlawful instances.</p>
<p>Many data types (together with their respective operations) can
form a <code>Semigroup</code> (or any other type class), and instances
don't even have to look similar or have a common analogy/metaphor.</p>
<p><strong>Type classes are often just <em>interfaces</em> with <em>laws</em></strong> (or expected behaviour if you will).
Approaching them with this mindset can be very liberating!</p>
<p>To put it in a differently, <strong>type classes can be used to create abstractions</strong> -
interfaces with laws/expected behaviour where we don't actually care about the
concrete details of the underlying type, just that it <em>implements a certain
api and behaves as expected</em>.</p>
<p>We have <a href="04-markup/02_04-safer_construction.html#appending-htmlstructure">previously</a>
created a function that looks like this for our <code>Html</code> EDSL!
We can add a <code>Semigroup</code> instance for our <code>Structure</code> data type
and have a nicer to use API!</p>
<p>Exercise: Please do this and remove the <code>append_</code> function from the API.</p>
<details>
  <summary>Solution</summary>
<p>Replace this:</p>
<pre><code class="language-hs">append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)
</code></pre>
<p>With this:</p>
<pre><code class="language-hs">instance Semigroup Structure where
  (&lt;&gt;) c1 c2 =
    Structure (getStructureString c1 &lt;&gt; getStructureString c2)
</code></pre>
<p>And remove the export of <code>append_</code> in <code>Html.hs</code>. You won't need to further export anything
as type class instances are exported automatically.</p>
<p>You will also need replace the usage of <code>append_</code> with <code>&lt;&gt;</code> in <code>hello.hs</code>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-markup-part-02-pattern-matching"><a class="header" href="#parsing-markup-part-02-pattern-matching">Parsing markup part 02 (Pattern matching)</a></h1>
<h2 id="maybe"><a class="header" href="#maybe">Maybe</a></h2>
<p>Previously, when we talked about partial functions, we mentioned that one way to avoid
writing partial functions is encode the absence of a result using <code>Maybe</code>:</p>
<pre><code class="language-hs">data Maybe a
    = Nothing
    | Just a
</code></pre>
<p><code>Maybe</code> is a data type from the standard library (named <a href="https://hackage.haskell.org/package/base">base</a>)
that is used to add an additional value to a type: the absence of a value.
For example, <code>Maybe Bool</code> has three values,
two with the <code>Just</code> constructor to represent regular boolean values
(<code>Just True</code> and <code>Just False</code>) and another value, <code>Nothing</code> to represent
the absence of a boolean value.</p>
<p>We can use this to encode the result of <code>head</code>, a function the promises to return
the first element of a list, without creating a partial function:</p>
<pre><code class="language-hs">head :: [a] -&gt; Maybe a
</code></pre>
<p>This way, when the list is empty, we can return <code>Nothing</code>, and when it has at least
one element, we can return <code>Just &lt;first element&gt;</code>. This function can be found in
the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Maybe.html">Data.Maybe</a>
module under the name
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Maybe.html#v:listToMaybe">listToMaybe</a>.</p>
<p>In order to consume values of type <code>Maybe &lt;something&gt;</code>, and other types created with
<code>data</code>, we can use pattern matching.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>We've already seen pattern matching a few times.
It is an incredibly versatile feature of Haskell, we can use it to do two things main things:</p>
<ol>
<li>Deconstruct complex values</li>
<li>Control flow</li>
</ol>
<p>As we've seen when discussing
<a href="https://soupi.github.io/learn-haskell-blog-generator/03-html/03_04-safer_construction.html#using-newtypes">newtypes</a>,
we can use <strong>case expressions</strong> and <strong>function definitions</strong> to deconstruct a <code>newtype</code>,
but we can do that for <code>data</code> types as well:</p>
<pre><code class="language-hs">-- | A data type representing colors
data Color
  = RGB Word8 Word8 Word8

getBluePart :: Color -&gt; Word8
getBluePart color =
  case color of
    RGB _ _ blue -&gt; blue
</code></pre>
<p>In <code>getBluePart</code> we deconstruct a composite value into it's part and extract the third component
representing the blue value in a color represented by red, green and blue components (RGB).</p>
<p>Note that <code>blue</code> is the name we give to the third component so it will be bound
to the right of the arrow that comes after the pattern. This is similar to
a function argument. Also note that <code>_</code> matches any value <em>without</em> binding it to a name.</p>
<p>We can also try to match a value with more than one pattern:</p>
<pre><code class="language-hs">data Brightness
  = Dark
  | Bright

data EightColor
  = Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White

data AnsiColor
  = AnsiColor Brightness EightColor

ansiColorToVGA :: AnsiColor -&gt; RGB
ansiColorToVGA ansicolor =
  case ansicolor of
    AnsiColor Dark Black -&gt;
      RGB 0 0 0
    AnsiColor Bright Black -&gt;
      RGB 85 85 85
    AnsiColor Dark Red -&gt;
      RGB 170 0 0
    AnsiColor Bright Red -&gt;
      RGB 255 85 85
    -- and so on
</code></pre>
<p>It's important to notice a few things here:</p>
<ol>
<li>Patterns can be nested, notice how we deconstructed <code>ansicolor</code> on multiple levels</li>
<li>We try to match patterns from the top down, it is possible for patterns to overlap with one another and the top one will win</li>
<li>If the value we try to match does not match any of the patterns listed, an error will be thrown at runtime</li>
</ol>
<p>We can ask GHC to notify when we accidentally written overlapping patterns,
or when we haven't listed enough patterns to match all possible values,
by passing the flag <code>-Wall</code> to <code>ghc</code> or <code>runghc</code>!</p>
<p><strong>My recommendation is to always use -Wall!</strong></p>
<p>As an aside, while it is possible to use pattern matching in function definitions by defining a function
multiple types, <a href="https://twitter.com/_gilmi/status/1257225601079029760">I personally don't like that feature very much</a>, but if you want to use it instead of case expressions, it is possible.</p>
<p>Exercises:</p>
<ol>
<li>Create a function <code>isBright :: AnsiColor -&gt; Bool</code> that checks whether a color is bright or not</li>
<li>Use <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit">this table</a> to write <code>ansiToUbuntu</code>.</li>
<li>Create a function <code>isEmpty :: [a] -&gt; Bool</code> that uses <code>listToMaybe</code> to check whether a list is empty or not</li>
<li>Create a function <code>isEmpty :: [a] -&gt; Bool</code> that <em>doesn't</em> use <code>listToMaybe</code> to check whether a list is empty or not</li>
</ol>
<h2 id="parsing-with-rich-context"><a class="header" href="#parsing-with-rich-context">Parsing with rich context</a></h2>
<p>Previously we wrote a parser that separates documents into different paragraphs.
With new features under our belt we can now remember the exact context we are in
(whether it is a text paragraph, a list, or a code block) and act accordingly!</p>
<p>Let's look again at the parsing code we wrote previously:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines -- (1)

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)
  in
    case txts of
      [] -&gt; [paragraph]
      currentLine : rest -&gt;
        if trim currentLine == &quot;&quot;
          then
            paragraph : parseLines [] rest -- (4)
          else
            parseLines (currentLine : currentParagraph) rest -- (5)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Previously our context, <code>currentParagraph</code>, was used to group adjacent lines in an accumulative list.</p>
<p>Next, instead of using a <code>[String]</code> type to denote adjacent lines, we can instead use a <code>Structure</code> to denote the context.</p>
<p>One issue we might have though with representing context with the <code>Structure</code> type,
is that when we start parsing we don't have any context.
But we learn of a way to represent the possibility of an absence of a value with <code>Maybe</code>! So our new context type can be <code>Maybe Structure</code> instead.</p>
<p>Let's rewrite our code above to use our new context type:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines Nothing . lines -- (1)

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    [] -&gt; maybeToList context   -- (2)
    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest) -- (3)
          else
            case context of
              Nothing -&gt;
                parseLines (Just (Paragraph line)) rest
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4), (5)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<ol>
<li>
<p>We can now pass <code>Nothing</code> when we don't have a context</p>
</li>
<li>
<p>Unsure what <code>maybeToList</code> does? <a href="https://hoogle.haskell.org">Hoogle</a> it!</p>
</li>
<li>
<p><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:maybe">maybe</a> is a function that works similarily to pattern matching on a <code>Maybe</code>.
Check out the types of <code>id</code>, <code>(:)</code> and <code>maybe id (:)</code> in ghci!</p>
</li>
<li>
<p>Hey! Didn't we say that appending <code>String</code>s/lists is slow (which is what <code>unwords</code> does)? Yes, it is.
Because in our <code>Structure</code> data type, a paragraph is defined as <code>Paragraph String</code> and not <code>Paragraph [String]</code>,
we can't use our trick of building a list of lines and the reverse it at the end.</p>
<p>So what do we do?
There are many ways to handle that, one simple way is to create a different type with the right shape:</p>
<pre><code class="language-hs">data Context
  = CtxHeader Natural String
  | CtxParagraph [String]
  | CtxUnorderedList [String]
  | CtxOrderedList [String]
  | CtxCodeBlock [String]
</code></pre>
<p>Since creating new types in Haskell is cheap, this is a very viable solution.
With more complex type-level features we can even create a more general type that can be used in both place,
both as a <code>Structure</code> and as a <code>Context</code>, don't worry about it for now, really. (but if one day you really need to do this, search for &quot;Higher-Kinded Data&quot; (or HKD pattern)).</p>
<p>In this case I'm going with the approach of not worrying about it too much, because it's a very local code that can easily be fixed later if and when we see it is an issue.</p>
</li>
<li>
<p>Anyway, if you've used <code>-Wall</code> like I've suggested, you'd get a warning from GHC saying that the <em>&quot;pattern matches are non-exhaustive&quot;</em>. This is because we did not cover all cases. So let's cover more cases:</p>
</li>
</ol>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    -- done case
    [] -&gt; maybeToList context
   
    -- Header 1 case
    ('@' : ' ' : line) : rest -&gt;
      maybe id (:) context (Header 1 (trim line) : parseLines Nothing rest)
   
    -- Unordered list case
    ('-' : ' ' : line) : rest -&gt;
      case context of
        Just (UnorderedList list) -&gt;
          parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)
   
    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Nothing -&gt;
                parseLines (Just (Paragraph line)) rest
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Exercise: Add the <code>CodeBlock</code> and <code>OrderedList</code> cases.</p>
<hr />
<details>
  <summary>Final module</summary>
<pre><code class="language-hs">-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  , parse
  )
where

import Numeric.Natural
import Data.Maybe (maybeToList)

type Document
  = [Structure]

data Structure
  = Header Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving (Eq, Show)    -- (1)


parse :: String -&gt; Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    -- done case
    [] -&gt; maybeToList context
   
    -- Header 1 case
    ('*' : ' ' : line) : rest -&gt;
      maybe id (:) context (Header 1 (trim line) : parseLines Nothing rest)
   
    -- Unordered list case
    ('-' : ' ' : line) : rest -&gt;
      case context of
        Just (UnorderedList list) -&gt;
          parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)

    -- Ordered list case
    ('#' : ' ' : line) : rest -&gt;
      case context of
        Just (OrderedList list) -&gt;
          parseLines (Just (OrderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest)

    -- Code block case
    ('&gt;' : ' ' : line) : rest -&gt;
      case context of
        Just (CodeBlock code) -&gt;
          parseLines (Just (CodeBlock (code &lt;&gt; [line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (CodeBlock [line])) rest)

    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Nothing -&gt;
                parseLines (Just (Paragraph line)) rest
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest

trim :: String -&gt; String
trim = unwords . words
</code></pre>
</details>
<hr />
<h3 id="how-do-we-know-our-parser-works-correctly"><a class="header" href="#how-do-we-know-our-parser-works-correctly">How do we know our parser works correctly?</a></h3>
<p>At an earlier chapter, we parsed a few example of our markup language <a href="04-markup/01-data_type.html#exercises">by hand</a>.
Now, we can try to test our parser by comparing our solutions to our parser.
By adding the <code>Eq</code> constraint to our data type (as shown in (1)), we can add these to our module and
use the <code>==</code> (equals) operator to compare our solutions to the result our parser gives.</p>
<p>Try it in ghci! You can read a text file in ghci using the following syntax:</p>
<pre><code class="language-hs">ghci&gt; txt &lt;- readFile &quot;/tmp/sample.txt&quot;
</code></pre>
<p>And then compare with a hand written <code>doc</code> value from the solutions
(after adding it to the module and loading it in ghci):</p>
<pre><code class="language-hs">ghci&gt; parse txt == doc
</code></pre>
<p>In a later chapter, we'll discuss how to use a testing framework and
write automated tests for our parser. But first, I'd like to glue things together
so we'll be able to:</p>
<ol>
<li>Read markup text from a file</li>
<li>Parse the text</li>
<li>Convert the result to our html EDSL</li>
<li>Generate HTML code</li>
</ol>
<p>And also discuss how to work with IO in Haskell while we're at it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gluing-things-together"><a class="header" href="#gluing-things-together">Gluing things together</a></h1>
<p>In this chapter we are going to glue the pieces that we built together
and build an actual blog generator. We will:</p>
<ol>
<li>Read markup text from a file</li>
<li>Parse the text to a <code>Document</code></li>
<li>Convert the result to our <code>Html</code> EDSL</li>
<li>Generate HTML code</li>
<li>Write it to file</li>
</ol>
<p>While doing so, we will learn:</p>
<ul>
<li>How to work with IO</li>
<li>How to import external libraries to process whole directories and create a simple command-line interface</li>
<li>How to use a testing framework to write automated tests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-markup-to-html"><a class="header" href="#converting-markup-to-html">Converting Markup to HTML</a></h1>
<p>One key part is missing before we can do glue everything together, and that is
to convert our <code>Markup</code> data types to <code>Html</code>.</p>
<p>We'll start by creating a new module and import both the <code>Markup</code> and the <code>Html</code> modules.</p>
<pre><code class="language-hs">module Convert where

import qualified Markup
import qualified Html
</code></pre>
<h2 id="qualified-imports"><a class="header" href="#qualified-imports">Qualified Imports</a></h2>
<p>This time, we've imported the modules qualified. Qualified imports means that
instead of exposing the names that we've defined in the imported module to
the general module namespace, they now have to be prefixed with the module name.</p>
<p>For example, <code>parse</code> becomes <code>Markup.parse</code>.
If we would've imported <code>Html.Internal</code> qualified, we'd have to write
<code>Html.Internal.el</code> which is a bit long.</p>
<p>We can also give a new name to the module to be used instead with the <code>as</code>
keyword:</p>
<pre><code class="language-hs">import qualified Html.Internal as HI
</code></pre>
<p>And now write <code>HI.el</code> instead.</p>
<p>I like using qualified imports because readers do not have to guess where a
name came from. Some modules are even designed to be imported qualified.
For example, many container APIs such as maps, sets and vectors have very similar
API. If we want to multiple containers in a single module we pretty much have
to use qualified imports so that when we write a function such as <code>singleton</code>,
which creates a container with a single value, GHC will know to which <code>singleton</code>
function from which module we are refering.</p>
<p>Some people prefer to use import lists instead of qualified imports as well,
because qualified names can be a bit verbose and noisy. I usually prefer them,
but up to you. For more information about imports,
see this <a href="https://wiki.haskell.org/Import">wiki article</a>.</p>
<p>In this case we don't <em>have</em> to you qualified imports, but I think they make
the code a bit clearer.</p>
<h2 id="converting-markupstructure-to-htmlstructure"><a class="header" href="#converting-markupstructure-to-htmlstructure">Converting Markup.Structure to Html.Structure</a></h2>
<p>Converting a markup structure to an Html structure is mostly straightforward
at this point, we need to pattern match on the markup structure and use
the relevant Html API.</p>
<pre><code class="language-hs">convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Header 1 txt -&gt;
      Html.h1_ txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
<p>Notice that running this code with <code>-Wall</code> will reveal that the pattern matching
is <em>non-exhaustive</em>. This is because we don't currently have a way to build
headers that are not <code>h1</code>. There are a few ways to handle this:</p>
<ul>
<li>Ignore the warning - this will like fail at runtime one day and the user will be sad</li>
<li>Pattern match other cases and add a nice error with the <code>error</code> function, has
the same disadvantage above, but will also not notify that there's a possible issue
here at compile time.</li>
<li>Pattern match and do the wrong thing - user is still sad</li>
<li>Encode errors in the type system using <code>Either</code>, we'll see how to do this in later
chapters</li>
<li>Restrict the input - change <code>Markup.Header</code> to not include a number but rather
specific supported headers. This is a reasonable approach.</li>
<li>Implement an Html function supporting arbitrary headers. Should be straightforward
to do.</li>
</ul>
<hr />
<p>Exercise: Implement <code>h_ :: Natural -&gt; String -&gt; Structure</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">import Numeric.Natural

h_ :: Natural -&gt; String -&gt; Structure
h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . escape
</code></pre>
<p>Don't forget to export it from <code>Html.hs</code>!</p>
</details>
<p>Exercise: Fix <code>convertStructure</code> using <code>h_</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Header n txt -&gt;
      Html.h_ n txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
</details>
<hr />
<h2 id="document---html"><a class="header" href="#document---html">Document -&gt; Html</a></h2>
<p>In order to create an <code>Html</code> document, we need to use the <code>html_</code> function.
This function expects two things: a <code>Title</code>, and a <code>Structure</code>.</p>
<p>For a title we just could supply it from outside using the file name.</p>
<p>In order to convert our markup <code>Document</code> (which is a list of markup <code>Structure</code>)
to an html <code>Structure</code>, we need to convert each markup <code>Structure</code> and then
concatenate them together.</p>
<p>We already know how to convert each markup <code>Structure</code>, we can use the
<code>convertStructure</code> function we wrote and <code>map</code>. This will provide
us with the following function:</p>
<pre><code>map convertStructure :: Markup.Document -&gt; [Html.Structure]
</code></pre>
<p>To concatenate all of the <code>Html.Structure</code>, we could write a recursive
function that tries to do that. However we will quickly run to an issue
with the base case, what to do when the list is empty?</p>
<p>We could just provide dummy <code>Html.Structure</code> that represents an empty
html structure.</p>
<p>Let's add this to <code>Html.Internal</code>:</p>
<pre><code class="language-hs">empty_ :: Structure
empty_ = Structure &quot;&quot;
</code></pre>
<p>Now we can write our recursive function. Try it!</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">concatStructure :: [Structure] -&gt; Structure
concatStructure list =
  case list of
    [] -&gt; empty_
    x : xs -&gt; x &lt;&gt; concatStructure list
</code></pre>
</details>
<p>Remember the <code>&lt;&gt;</code> function we implemented as an instance of the <code>Semigroup</code>
type class? We said that <code>Semigroup</code> is an <strong>abstraction</strong> for things
that implements <code>(&lt;&gt;) :: a -&gt; a -&gt; a</code>, where  <code>&lt;&gt;</code> is associative
(<code>a &lt;&gt; (b &lt;&gt; c) = (a &lt;&gt; b) &lt;&gt; c</code>).</p>
<p>It turns out that things that have an &quot;empty&quot; value and are also
an instance of <code>Semigroup</code> is quite a common thing. For example a string.
And this is actually a well known <strong>abstraction</strong>. This abstraction
is called a <strong>monoid</strong>.</p>
<h2 id="monoids"><a class="header" href="#monoids">Monoids</a></h2>
<p>Actually, maybe &quot;empty&quot; isn't a very good description of what we want,
and isn't very useful as an abstraction. Instead, we can describe it as
what is often called an &quot;identity&quot; element.
An identity element is one that satisfy the following laws:</p>
<ul>
<li><code>x &lt;&gt; &lt;identity&gt; = x</code></li>
<li><code>&lt;identity&gt; &lt;&gt; x = x</code></li>
</ul>
<p>In other words, if we try to use this &quot;empty&quot; - this identity value,
as one argument to <code>&lt;&gt;</code>, we will always get the other argument back.</p>
<p>For <code>String</code>, the empty string, <code>&quot;&quot;</code>, satisfies this:</p>
<pre><code class="language-hs">&quot;&quot; &lt;&gt; &quot;world&quot; = &quot;world&quot;
&quot;hello&quot; &lt;&gt; &quot;&quot; = &quot;hello&quot;
</code></pre>
<p>This is of course true for any value we'd write and not just &quot;world&quot; and &quot;hello&quot;.</p>
<p>Actually, if we move out of the Haskell world for a second, even integers
with <code>+</code> as the associative binary operations <code>+</code> (in place of <code>&lt;&gt;</code>)
and <code>0</code> in place of the identity member form a monoid:</p>
<pre><code class="language-hs">17 + 0 = 17
0 + 99 = 99
</code></pre>
<p>So integers together with the <code>+</code> operation form a semigroup, and
together with <code>0</code> form a monoid.</p>
<p>We learn new things from this:</p>
<ol>
<li>A monoid is a more specific abstraction over semigroup, it builds on it
by adding a new condition (the existence of an identity member)</li>
<li>This abstraction can we useful! We can write a general <code>concatStructure</code>
that could work for any monoid</li>
</ol>
<p>And indeed, there exists a type class in <code>base</code> called <code>Monoid</code> which has
<code>Semigroup</code> as a <strong>superclass</strong>.</p>
<pre><code class="language-hs">class Semigroup a =&gt; Monoid a where
  mempty :: a
</code></pre>
<p>(Note: this is actually a simplified version. The
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#t:Monoid">actual</a>
is a bit more complicated because of backwards compatability and performance reasons.
<code>Semigroup</code> was actually introduced in Haskell after <code>Monoid</code>!)</p>
<p>We could add an instance of <code>Monoid</code> for our markup <code>Structure</code> data type:</p>
<pre><code class="language-hs">instance Monoid a where
  mempty = empty_
</code></pre>
<p>And now, instead of using our own <code>concatStructure</code>, we can use the library function</p>
<pre><code class="language-hs">mconcat :: Monoid a =&gt; [a] -&gt; a
</code></pre>
<p>Which could theoretically be implemented as:</p>
<pre><code class="language-hs">mconcat :: Monoid a =&gt; [a] -&gt; a
mconcat list =
  case list of
    [] -&gt; mempty
    x : xs -&gt; x &lt;&gt; mconcat list
</code></pre>
<p>Pretty much the same way as our <code>concatStructure</code>, but it works for any <code>Monoid</code>!
Abstractions are useful and help us reuse code!</p>
<p>Side note: integers with <code>+</code> and <code>0</code> aren't actually an instance of <code>Monoid</code> in Haskell.
This is because integers can also form a monoid with <code>*</code> and <code>1</code>! But <strong>there can only
be one instance per type</strong>. Instead, two other <code>newtype</code>s exist that provide that
functionality, <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Monoid.html#t:Sum">Sum</a>
and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Monoid.html#t:Product">Product</a>.
See how they can be used in <code>ghci</code>:</p>
<pre><code class="language-hs">ghci&gt; import Data.Monoid
ghci&gt; Product 2 &lt;&gt; Product 3 -- note, Product is a data constructor
Product {getProduct = 6}
ghci&gt; getProduct (Product 2 &lt;&gt; Product 3)
6
ghci&gt; getProduct $ mconcat $ map Product [1..5]
120
</code></pre>
<h2 id="another-abstraction"><a class="header" href="#another-abstraction">Another abstraction?</a></h2>
<p>We've used <code>map</code> and then <code>mconcat</code> twice now. Surely there has to be a function
that unifies this pattern. And indeed, it is called
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Foldable.html#v:foldMap"><code>foldMap</code></a>,
and it works not only for lists, it will work for any data structure that can be &quot;folded&quot;,
or &quot;reduced&quot;, into a summary value. This abstraction and type class is called <strong>Foldable</strong>.</p>
<p>For a simpler understanding of <code>Foldable</code>, we can look at <code>fold</code>:</p>
<pre><code class="language-hs">fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m

-- compare with
mconcat :: Monoid m            =&gt; [m] -&gt; m
</code></pre>
<p><code>mconcat</code> is just a specialized version of <code>fold</code> for lists.
And <code>fold</code> can be a used for any pair of data structure that implements
<code>Foldable</code> and a payload type that implements <code>Monoid</code>. This
could be <code>[]</code> with <code>Structure</code>, or <code>Maybe</code> with <code>Product Int</code>, or
your new shiny binary tree with <code>String</code> as the payload type. But note that
the <code>Foldable</code> type must be of <em>kind</em> <code>* -&gt; *</code>. So for example <code>Html</code>
cannot be a <code>Foldable</code>.</p>
<p><code>foldMap</code> is a function that allows us to apply a function to the
payload type of the <code>Foldable</code> type right before appending (<code>&lt;&gt;</code>) them.</p>
<pre><code class="language-hs">foldMap :: (Foldable t, Monoid m) -&gt; (a -&gt; m) -&gt; t a -&gt; m

-- compare to a specialized version with:
-- - t ~ []
-- - m ~ Html.Structure
-- - a ~ Markup.Structure
foldMap
  :: (Markup.Structure -&gt; Html.Structure)
  -&gt; [Html.Structure]
  -&gt; Html.Structure
</code></pre>
<p>True to its name, it really &quot;maps&quot; before it &quot;folds&quot;. You might pause here
and think &quot;this 'map' we are talking about isn't specific for lists, maybe
that's another abstraction?&quot;, yes. It is actually a very important and
fundamental abstraction called <code>Functor</code>.
But I think we had enough abstractions for today.
We'll cover it in a later chapter!</p>
<h2 id="finishing-our-conversion-module"><a class="header" href="#finishing-our-conversion-module">Finishing our conversion module</a></h2>
<p>Let's finish our code by writing <code>convert</code>:</p>
<pre><code class="language-hs">convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure
</code></pre>
<p>Now we have a full implementation and are able to convert markup documents
to html:</p>
<pre><code class="language-hs">-- Convert.hs
module Convert where

import qualified Markup
import qualified Html

convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure

convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Header n txt -&gt;
      Html.h_ n txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>We learned about:</p>
<ul>
<li>Qualified imports</li>
<li>Ways to handle errors</li>
<li>The <code>Monoid</code> type class and abstraction</li>
</ul>
<p>Next, we are going to glue our functionality together and learn about
I/O in Haskell!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-io"><a class="header" href="#working-with-io">Working with IO</a></h1>
<p>In previous chapters we were able to build a parser from a text
string to a Haskell representation of our markup language,
and we built an EDSL for easy writing of HTML code.
However, our program is still not useful to other users because
we did this functionality accessible to a user via some sort of
a user interface.</p>
<p>In our program, we'd like to learn from the user what they'd
like us to convert to HTML, and then convert that for them.
There are many ways to design this kind of interface, for example:</p>
<ul>
<li>Get text as input via the <em>standard input</em>, and output HTML
via the <em>standard output</em></li>
<li>Receive two file names as <em>command-line arguments</em>, read the contents
of the first one and write the output to the second one</li>
<li>Ask for some fancier command-line arguments parsing and prefix
the file with a flag saying what they are</li>
<li>Some fancy GUI interface</li>
<li>Combination of all of the above</li>
</ul>
<p>To make this interesting, we will start with the following interface:</p>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name which we will read, and the second one
will be the output file name to which we will write</li>
<li>If the output file already exists, we'll ask the user if they want
to override the file</li>
<li>On any other kind of input, we'll output a generic message explaining
the usage as we described above</li>
</ol>
<p>At a later chapter, we will add a little fancier argument parsing
using a library, and also read whole directories and not single files.</p>
<p>But first, we need to learn a bit about IO in Haskell, what makes
it special, and why it's a bit different from otherprogramming languages.</p>
<h2 id="purely-functional"><a class="header" href="#purely-functional">Purely functional</a></h2>
<p>Originally, Haskell was designed in order to become an <em>open standard</em>
functional programming language with <strong>non-strict semantics</strong>, to serve
as a unifying language for future research in functional language design.</p>
<p>In GHC Haskell, we use a <em>lazy evaluation strategy</em> to implement non-strict
semantics (We've talked about laziness
<a href="https://soupi.github.io/learn-haskell-blog-generator/04-markup/02-parsing_01.html#laziness">before</a>).</p>
<p>The requirement for non-strict semantics has raise an interesting challenge,
how do we design a language that can do more than just evaluate expressions,
how do we model interaction with the outside world? How do we do IO?</p>
<p>The challenge with doing IO operation in a language with a lazy evaluation strategy
is that as programs grow larger, the order of evaluation becomes less trivial to
figure out. Consider this hypothetical code example
(which won't actually typecheck in Haskell, we'll see why soon):</p>
<pre><code class="language-hs">addWithInput :: Int -&gt; Int
addWithInput n = readIntFromStdin + n

main =
  let
    result1 = addWithInput 1
    result2 = addWithInput 2
  in
    print (result2 - result1)
</code></pre>
<p>This hypothetical program will read 2 integers from the standard input,
and then will substract the second one (+2) from the first one (+1),
or so we would expect if this was a strict language. In a strict language
we expect the order of operations to to happen from the top-down.
But in a lazy language we don't actually evaluate an expression until
it is needed, and so neither <code>result1</code> nor <code>result2</code> are evaluted
until we wish to print the result of substracting one from the other,
and then when we try to evaluate <code>-</code>, it requires to evaluate the two arguments
in order from left to right, so we first evaluate <code>result2</code>.</p>
<p>Evaluating <code>result2</code>, with substitution, means to replace occurances of <code>n</code>
with the input <code>2</code>, and then evaluate the top level function (<code>+</code>), it is a
primitive function, we then evaluate it's arguments, <code>readIntFromStdin</code>
and then <code>n</code>, at this point <em>we are reading the first integer from the stdin</em>.</p>
<p>After calcuating the result, we can move to evaluate <code>result1</code>, in which,
during evaluation, <em>will read the second integer from stdin</em>, this is the
complete opposite of what we wanted!</p>
<p>Issues like these make lazy evaluation hard to work with in the presence of
<strong>side effects</strong> - when the evaluation of an expression <em>can affect or be affected
by the outside world</em>, this includes reading/writing from mutable memory
or performing I/O operations.</p>
<p>We call functions that has side-effects such as <code>addWithInput</code> <strong>impure functions</strong>.
And an unfortunate consequence of impure functions is that
<strong>they can return different results even when they takes the same input</strong>.</p>
<p>The presence of impure functions makes it harder for us to reason about lazy evaluation,
and also messes up our ability to use <em>equational reasoning</em> to understand programs.</p>
<p>Therefore, for Haskell, it was decided to only allow <strong>pure</strong> and expressions - ones that
have <em>no side effects</em> - pure functions will <em>always</em> return the same output (given the same input)
and <strong>evaluating pure expressions is deterministic</strong>.</p>
<p>But now, how can we do input/ouput operations? There are many possible solutions
for the design space, in Haskell it was chosen to design a first class interface
with an accompanied type called <code>IO</code>. <code>IO</code>'s interface will force a dinstiction
from non-IO expressions, and will also require that in order to combine
multiple <code>IO</code> operations, we will have to determine the order between them.</p>
<h2 id="io"><a class="header" href="#io">IO</a></h2>
<p><code>IO</code> is an opaque type, like our <code>Html</code> type in which we hid its internal
representation from the user behind an interface. But in this case <code>IO</code> is a
built-in type that is hidden by the Haskell language rather than a module.</p>
<p><code>IO</code> has a payload type like <code>Maybe</code> has which represents the
result of an <code>IO</code> operation/action/computation.
When there isn't a meaningful result, we use the unit type,
<code>()</code> (which only has one value: <code>()</code>) to represent that.</p>
<p>Here are a few functions that return <code>IO</code> operations:</p>
<pre><code class="language-hs">putStrLn :: String -&gt; IO ()

getLine :: IO String

getArgs :: IO [String]

lookupEnv :: String -&gt; IO (Maybe String)

writeFile :: FilePath -&gt; String -&gt; IO ()
</code></pre>
<!-- You can find more useful IO functions and operations in the
[System.IO](https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO.html) module.
which is shipped with `base`. -->
<p>Notice that each function returns an <code>IO &lt;something&gt;</code>, but what does that mean?</p>
<p>The meaning behind <code>IO a</code> is that it is a <em>description of a program (or subroutine)
that when executed will produce some value of type <code>a</code>, and may do some I/O effects
during execution</em>.</p>
<p>Executing an <code>IO a</code> is different from evaluating it.
Evaluating an <code>IO a</code> expression is pure - the <strong>evalution</strong> will always reduce to
the same <strong>description</strong> of a program. This helps us keep purity and equational reasoning!</p>
<p>The Haskell runtime will <em>execute</em> the entry point to the program
(the expression <code>main</code>, that must have the type <code>IO ()</code>) in order for our IO operation
to also run it has to be <em>combined into</em> the <code>main</code> expression - let's see what that means.</p>
<h2 id="combining-io-expressions"><a class="header" href="#combining-io-expressions">Combining IO expressions</a></h2>
<p>Just like our <code>Html</code> type, the IO interface provides <strong>combinators</strong> for composing
small <code>IO</code> operations into bigger ones. This interface also makes sure that the order
of operations is well defined!</p>
<p>Note that, just like with <code>&lt;&gt;</code> we've defined for <code>Html</code>, the combinators for <code>IO</code>
are implemented as <strong>type-class instances</strong> rather than specialized variants
(for example our <code>append_</code> function was a specialized version of <code>&lt;&gt;</code> tailored only
for <code>Html</code>).</p>
<p>In this section I will introduce specialized type signatures rather than generalized ones,
because I think it'll be easier to digest, but we'll talk about the generalized versions
later.</p>
<h3 id=""><a class="header" href="#">&gt;&gt;=</a></h3>
<p>Our first combinator is <code>&gt;&gt;=</code> (pronounced bind), and is the most useful of the bunch:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>This combinator takes two arguments, the first is an IO operation, and the second is
a function that <em>takes as input the result of the first IO operation</em> and returns
a new <code>IO b</code> which is the final result.</p>
<p>Here are a few examples using the functions we described above:</p>
<ol>
<li>
<p>Echo</p>
<pre><code>getLine &gt;&gt;= (\line -&gt; putStrLn line)
</code></pre>
<p>We are reading a line from the standard input pass on the left of <code>&gt;&gt;=</code>,
and receive the input to the left of <code>&gt;&gt;=</code>, and then write it to the
standard output. <code>&gt;&gt;=</code>'s role here is to <strong>pass the result of the IO operation
on the left to the function returning an IO operation on the right</strong>.</p>
<p>Notice how <code>&gt;&gt;=</code> <em>defines an order of operations - from left to right</em>.</p>
<p>The type of each sub expression here is:</p>
<pre><code class="language-hs">getLine :: IO String

putStrLn :: String -&gt; IO ()

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO ()) -&gt; IO ()

line :: String
</code></pre>
<ul>
<li>Question: what is the type of the whole expression? <details><summary>Answer</summary>IO ()</details></li>
</ul>
<p>Also note that this example above can be written in a more concise manner
in point free style <code>getLine &gt;&gt;= putStrLn</code>.</p>
</li>
<li>
<p>Appending two inputs</p>
<pre><code>getLine &gt;&gt;= (\honorific -&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)))
</code></pre>
<p>This subroutine combines multiple operations together, it reads two lines from
the standard input and prints a greeting.
Note that:</p>
<ul>
<li>Using <code>&gt;&gt;=</code> defines the order of operation from left to right</li>
<li>Because of the scoping rules in Haskell, <code>honorific</code> will still be in scope for the most inner function</li>
</ul>
<p>This is a bit hard to read, but we can remove the parens and add indentation to make it a bit easier to read:</p>
<pre><code>getLine &gt;&gt;= \honorific -&gt;
  getLine &gt;&gt;= \name -&gt;
    putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)
</code></pre>
</li>
</ol>
<p>Let's see a few more combinators!</p>
<h3 id="-and"><a class="header" href="#-and">*&gt; and &gt;&gt;</a></h3>
<pre><code class="language-hs">(*&gt;) :: IO a -&gt; IO b -&gt; IO b
(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b
</code></pre>
<p><code>*&gt;</code> and <code>&gt;&gt;</code> have the same type signature for <code>IO</code> and mean the same thing,
in fact, <code>*&gt;</code> is a slightly more generalized version of <code>&gt;&gt;</code> and can always
be used instead of <code>&gt;&gt;</code>, which only still exists to avoid breaking backwards
compatability.</p>
<p><code>*&gt;</code> for <code>IO</code> means run the first IO operation, discard the result
the run the second operation. It can be implemented using <code>&gt;&gt;=</code>:</p>
<pre><code class="language-hs">a *&gt; b = a &gt;&gt;= \_ -&gt; b
</code></pre>
<p>This combinator is useful when you want to run several IO operations one after
the other that might not return anything meaningful, such as <code>putStrLn</code>:</p>
<pre><code>putStrLn &quot;hello&quot; *&gt; putStrLn &quot;world&quot;
</code></pre>
<h3 id="pure-and-return"><a class="header" href="#pure-and-return">pure and return</a></h3>
<pre><code class="language-hs">pure :: a -&gt; IO a
</code></pre>
<p>like <code>*&gt;</code> and <code>&gt;&gt;</code>, <code>pure</code> is a more general version of <code>return</code> that also has the
advantage of not having a resemblence to unrelated keywords in other languages.</p>
<p>Remember that we said <code>IO a</code> is description of a program
that when executed will produce some value of type <code>a</code>, and may do some I/O effects
during execution?</p>
<p>With <code>pure</code>, we can build an <code>IO a</code> that does no I/O, and will produce a
specific value of type <code>a</code>, the one we supply to <code>pure</code>!</p>
<p>This function is useful when we want to do some computation that depends on <code>IO</code>.</p>
<p>For example:</p>
<pre><code class="language-hs">confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm
</code></pre>
<p>Trying to return just <code>True</code> or <code>False</code> here wouldn't work because of the
type of <code>&gt;&gt;=</code>:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>The right side of <code>&gt;&gt;=</code> in our code example (<code>\answer -&gt; case ...</code>) must
be of type <code>String -&gt; IO Bool</code> this is because:</p>
<ol>
<li><code>getLine :: IO String</code>, so the <code>a</code> in the type signature of <code>&gt;&gt;=</code>
should be the same as <code>String</code> in this instance, and</li>
<li><code>confirm :: IO Bool</code>, so <code>b</code> should be <code>Bool</code></li>
</ol>
<h3 id="fmap-and-"><a class="header" href="#fmap-and-">fmap and &lt;$&gt;</a></h3>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>&lt;$&gt;</code> is the infix version of <code>fmap</code>. Use it at your discretion.</p>
<p>What if we wanted to write a function that reads a line from stdin
and returns it with <code>!</code> at the end? We could write it using a combination
of <code>&gt;&gt;=</code> and <code>pure</code>:</p>
<pre><code>getLine &gt;&gt;= \line -&gt; pure (line ++ &quot;!&quot;)
</code></pre>
<p>With <code>fmap</code>, we can remove the <code>pure</code> part:</p>
<pre><code>fmap (\line -&gt; line ++ &quot;!&quot;) getLine
</code></pre>
<p>What <code>fmap</code> does is apply a function to the value to be returning
from the IO operation, also known as &quot;mapping&quot; over it.</p>
<p>(Btw, Have you noticed the similarities between <code>fmap</code> and <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>?)</p>
<h3 id="summary-2"><a class="header" href="#summary-2">Summary</a></h3>
<p>Here's a list of <code>IO</code> combinators we ran into:</p>
<pre><code class="language-hs">-- chaining IO operations: passing the *result* of the left IO operation
-- as an argument to the function on the right.
-- Pronounced &quot;bind&quot;.
(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b

-- sequence two IO operations, discarding the payload of the first.
(*&gt;) :: IO a -&gt; IO b -&gt; IO b

-- &quot;lift&quot; a value into IO context, does not add any I/O effects.
pure :: a -&gt; IO a

-- &quot;map&quot; (or apply a function) over the payload value of an IO operation.
fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<h2 id="io-is-first-class"><a class="header" href="#io-is-first-class">IO is first class</a></h2>
<p>The beauty of <code>IO</code> is that it's a completely first-class construct in the language,
and is not really different from <code>Maybe</code> and <code>Either</code>. We can pass it to
functions, put it in a container, etc. Remember that it represents a description
of a program, and without being combine into <code>main</code> in some way won't actually
<em>do</em> anything.</p>
<p>Here's an example of a function that takes IO actions as input:</p>
<pre><code class="language-hs">whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
<p>And how it can be used:</p>
<pre><code class="language-hs">main :: IO ()
main =
  putStrLn &quot;This program will tell you a secret&quot; *&gt;
    whenIO confirm (putStrLn &quot;IO is actually pretty awesome&quot;) *&gt;
      putStrLn &quot;Bye&quot;
</code></pre>
<p>Notice how <code>putStrLn &quot;IO is actually pretty awesome&quot;</code> isn't executed
right away, but only if it is what <code>whenIO</code> returns, and in turn is <em>combined</em>
with <code>*&gt;</code> as part of the <code>main</code> expression.</p>
<h2 id="getting-out-of-io"><a class="header" href="#getting-out-of-io">Getting out of IO?</a></h2>
<p>What we've seen above has great concequences to the Haskell language,
in our <code>Html</code> type, we had a function <code>render :: Html -&gt; String</code>
that could turn an <code>Html</code> to a string value.</p>
<p>In Haskell, <strong>there is no way</strong> to implement a function such as <code>execute :: IO a -&gt; a</code>
in a way that preserves purity and equational reasoning!</p>
<p>Also, <code>IO</code> is <em>opaque</em>, it does not let us examine it. So we are really bound
to what the Haskell API for <code>IO</code> allows us to do.</p>
<p>This means that <strong>we need to think about using IO differently</strong>!</p>
<p>In Haskell, once we got into <code>IO</code>, there is no getting out.
The only thing we can do is build bigger IO computations by <em>combining</em>
it with more IO computations.</p>
<p>We also can't use <code>IO a</code> in place of an <code>a</code>, so for example,
we can't write <code>getLine ++ &quot;!&quot;</code> because <code>++</code> expects both
sides to be Strings, and <code>getLine</code>'s type is <code>IO String</code>. The types do not match!
We have to use <code>fmap</code> and the return type must be <code>IO String</code>, like we've seen before.</p>
<p>In Haskell we like to keep <code>IO</code> usage minimal, and we like to push it to the edges
of the program. This pattern is often called <em>Functional core, imperative shell</em>.</p>
<h2 id="functional-core-imperative-shell"><a class="header" href="#functional-core-imperative-shell">Functional core, imperative shell</a></h2>
<p>In our blog generator program, we want to read a file, parse it, and convert it to html,
and then print the result to the console.</p>
<p>In many programming languages, we might interleave reading from the file with parsing,
and writing to the file with the html conversion. But we don't mix these here.
Parsing operates on a <code>String</code> value rather than some file handle,
and <code>Html</code> is being convert to a <code>String</code> rather than being written to the screen directly.</p>
<p>This approach of separating <code>IO</code> and pushing it to the edge of the program gives us
a lot of flexibility. These functions without <code>IO</code> are easier to test and examine
(because they are guaranteed to have deterministic evaluation!),
and they are more modular can work in many contexts (reading from stdin,
reading from network socket, writing to an http connection, and more).</p>
<p>This pattern is often a good approach for building Haskell programs. Especially
batch programs.</p>
<h2 id="building-a-blog-generator"><a class="header" href="#building-a-blog-generator">Building a blog generator</a></h2>
<p>We'd like to start building a blog generator, and we want to have the following
interface:</p>
<blockquote>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name which we will read, and the second one
will be the output file name to which we will write</li>
<li>If the output file already exists, we'll ask the user if they want
to override the file</li>
<li>On any other kind of input, we'll output a generic message explaining
the usage as we described above</li>
</ol>
</blockquote>
<p>We are going to need a few functions:</p>
<pre><code class="language-hs">getArgs :: IO [String] -- get the program arguments

getContents :: IO String -- Read all of the content from stdin

readFile :: FilePath -&gt; IO String -- Read all of the content from a file

writeFile :: FilePath -&gt; String -&gt; IO () -- Write a string into a file

doesFileExist :: FilePath -&gt; IO Bool -- Checks whether a file exists
</code></pre>
<p>And the following imports:</p>
<pre><code class="language-hs">import System.Directory (doesFileExist)
import System.Environment (getArgs)
</code></pre>
<p>We don't need to add the following import because <code>Prelude</code> already imports
these functions for us:</p>
<pre><code class="language-hs">-- imported by Prelude
import System.IO (getContents, readFile, writeFile)
</code></pre>
<hr />
<ol>
<li>
<p>Implement a function <code>process :: Title -&gt; String -&gt; String</code> which will parse
a document to markup, convert it to html and then render the html to a string.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse
</code></pre>
</details>
</li>
<li>
<p>Try implementing the &quot;imperative shell&quot; for our blog generator program.
Start with <code>main</code>, pattern match on the result of <code>getArgs</code>, and decide what to
do. Look back at the examples above for inspiration. Use <code>error</code> to report an error.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main =
  getArgs &gt;&gt;= \args -&gt;
    case args of
      -- No program arguments: reading from stdin and writing to stdout
      [] -&gt;
        getContents &gt;&gt;= \content -&gt;
        putStrLn (process &quot;Empty title&quot; content)

      -- With input and output file paths as program arguments
      [input, output] -&gt;
        readFile input &gt;&gt;= \content -&gt;
          doesFileExist input &gt;&gt;= \exists -&gt;
            let
              writeResult = writeFile output (process input content)
            in
              if exists
                then whenIO confirm writeResult
                else writeResult

      -- Any other kind of program arguments
      _ -&gt;
        putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />
<h2 id="do-notation"><a class="header" href="#do-notation">Do notation</a></h2>
<p>While using <code>&gt;&gt;=</code> to chain IO action is manageable, Haskell provides
an even more convenient syntactic sugar called <em>do notation</em>
which emulates imperative programming.</p>
<p>A <em>do block</em> starts with the <code>do</code> keyword, and continues with one or more
&quot;statements&quot; which can be one of the following:</p>
<ul>
<li>An expression of type <code>IO ()</code>, such as:
<ul>
<li><code>putStrLn &quot;Hello&quot;</code></li>
<li><code>if True then putStrLn &quot;Yes&quot; else putStrLn &quot;No&quot;</code></li>
</ul>
</li>
<li>A let block, such as
<ul>
<li><code>let x = 1</code></li>
<li>or multiple let declarations:
<pre><code class="language-hs">let
  x = 1
  y = 2
</code></pre>
Note that we do not write the <code>in</code> here.</li>
</ul>
</li>
<li>A binding <code>&lt;variable&gt; &lt;- &lt;expresion&gt;</code>, such as
<pre><code class="language-hs">line &lt;- getLine
</code></pre>
</li>
</ul>
<p>And the last &quot;statement&quot; must be an expression of type <code>IO &lt;something&gt;</code> -
this will be the result type of the do block.</p>
<p>These construct will be translated to <code>&lt;expression&gt; *&gt;</code>, <code>let ... in</code> and
<code>&lt;expression&gt; &gt;&gt;= \&lt;variable&gt;</code> respectively.</p>
<p>For example:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting = do
  putStrLn &quot;Tell me your name.&quot;
  let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
  name &lt;- getLine
  putStrLn (greet name)
</code></pre>
<p>Is just syntactic sugar for:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting =
  putStrLn &quot;Tell me your name.&quot; *&gt;
    let
      greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
    in
      getLine &gt;&gt;= \name -&gt;
        putStrLn (greet name)
</code></pre>
<p>It's important to note the difference between <code>let</code> and <code>&lt;-</code> (bind).
<code>let</code> is used to give a new name to an expression which will be in scope
for subsequent lines, and <code>&lt;-</code> is used to bind the result <code>a</code> in an <code>IO a</code>
action to a new name which will be in scope for subsequent lines.</p>
<table>
  <tr>
    <th>code</th>
    <th>operator</th>
    <th>type of the left side</th>
    <th>type of the right side</th>
    <th>comment</th>
  </tr>
  <tr>
    <td><pre><pre>let gretting = "hello"</pre></pre></td>
    <td><pre>=</pre></td>
    <td><pre>String</pre></td>
    <td><pre>String</pre></td>
    <td>Both sides are interchangeable</td>
  </tr>
  <tr>
    <td><pre>let mygetline = getLine</pre></td>
    <td><pre>=</pre></td>
    <td><pre>IO String</pre></td>
    <td><pre>IO String</pre></td>
    <td>We just create a new name for <code>getLine</code></td>
  </tr>
  <tr>
    <td><pre>name <- getLine</pre></td>
    <td><pre><-</pre></td>
    <td><pre>String</pre></td>
    <td><pre>IO String</pre></td>
    <td>Technically <code><-</code> is not an operator, but just a syntactic sugar for <code>>>=</code> + lambda, where we bind the result of the computation to a variable</td>
  </tr>
</table>
<p>Do notation is very very common and is often preferable to using <code>&gt;&gt;=</code> directly.</p>
<hr />
<ol>
<li>
<p>Exercise: Translate the examples in this chapter to <em>do notation</em>.</p>
</li>
<li>
<p>Exercise: Translate our glue code for the blog generator to <em>do notation</em>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main = do
  args &lt;- getArgs
  case args of
    -- No program arguments: reading from stdin and writing to stdout
    [] -&gt; do
      content &lt;- getContents
      putStrLn (process &quot;Empty title&quot; content)

    -- With input and output file paths as program arguments
    [input, output] -&gt; do
      content &lt;- readFile input
      exists &lt;- doesFileExist input
      let
        writeResult = writeFile output (process input content)
      if exists
        then whenIO confirm writeResult
        else writeResult

    -- Any other kind of program arguments
    _ -&gt;
      putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm = do
  putStrLn &quot;Are you sure? (y/n)&quot;
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. use y or n&quot;
      confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>In this chapter we discussed what &quot;Purely functional&quot; means,
where the initial motivation for being purely functional came from,
and how Haskell's IO interface allows us to create descriptions of program
without breaking purity.</p>
<p>We have also achieved a major milestone. With this chapter, we implemented
enough pieces that we can finally run our program on a single document
and get an html rendered result!</p>
<p>However, our command-line interface is still sub-par. We want to render a blog
with multiple articles, create a landing page, and more. We still have more to do
to be able to call our program a blog generator.</p>
<p>Let's keep going!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-project-description"><a class="header" href="#defining-a-project-description">Defining a project description</a></h1>
<p>Up until now we've only used <code>base</code> and the libraries
<a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/9.0.1-notes.html#included-libraries">included</a>
with GHC. Because of that we didn't really need to do anything more fancy
than <code>runghc</code> to run our program. However, we want to start using
external libraries which are not included with GHC in our programs.</p>
<p>External packages can be downloaded from <a href="https://hackage.haskell.org/">Hackage</a>,
Haskell's central package archive, <a href="https://www.stackage.org/">Stackage</a>,
a subset of Hackage packages that are known to work together, or even
from remote git repositories. Usually Haskellers uses a <strong>package manager</strong> to
download and manage packages for different projects. The most popular package
managers for Haskell are <a href="https://cabal.readthedocs.io">cabal</a> and
<a href="https://haskellstack.org">stack</a>.</p>
<p>The main difference between the two tools is their philosophy.
<code>cabal</code> tries to be a more minimalist tool that handles building Haskell projects
and package management using the whole of Hackage and uses complicated algorithms
to make sure packages work together.
<code>stack</code> tries to be a more maximal tool that handles installing the right GHC
for each project, provide integration with external tools like hoogle,
and lets the user choose which 'set' of packages (including their versions) they want to use.</p>
<p>If you've installed Haskell using ghcup, you most likely have <code>cabal</code> installed.
If you've installed Haskell using stack, well, you have <code>stack</code> installed.
Check the <a href="https://www.haskell.org/downloads/">haskell.org downloads page</a> if that's not the case.</p>
<h2 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h2>
<p>Using external packages can be done in multiple ways.
For quick experimentation, we can just
<a href="https://gilmi.me/blog/post/2021/08/14/hs-core-tools#using-external-packages-in-ghci">ask stack or cabal</a>
to build or even run our program with external packages.
But as programs gets larger, use more dependencies, and require more functionality,
it is better to just <strong>create a project description</strong> for our programs and even libraries.</p>
<p>Describing packages is done in a <strong>cabal file</strong>. We can ask cabal or stack
to generate one for use using <code>cabal init --libandexe</code> or <code>stack new</code>,
along with many other files, but we will likely need to edit the file by hand
later so let's just paste some sort of an initial example and then edit it.</p>
<pre><code class="language-cabal">cabal-version:       2.4

name:                name should match with &lt;name&gt;.cabal
version:             version should use PvP
synopsis:            Synopsis will appear in the hackage package listing and search
description:         The description will appear at the top of a library
homepage:            Homepage url
bug-reports:         issue-tracker url
license:             License name
license-file:        License file
author:              Author name
maintainer:          Maintainer email
category:            Hackage categories, separated by commas
extra-doc-files:
  README.md

common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall

library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:

executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , &lt;package-name&gt;
  ghc-options:
    -O
</code></pre>
<p>Let's break it down to a few parts, the <strong>package metadata</strong>, <strong>common settings</strong>,
<strong>library</strong> and <strong>executable</strong>.</p>
<h3 id="package-metadata"><a class="header" href="#package-metadata">Package metadata</a></h3>
<p>The first part should be fairly straightforward from the comments, maybe except for:</p>
<ul>
<li><code>cabal-version</code>: Defines which cabal versions can build this project. We've specified 2.4 and above.
<a href="https://cabal.readthedocs.io/en/3.4/file-format-changelog.html?highlight=cabal-version">More info on different versions</a>.</li>
<li><code>name</code>: The name of your library and package. Must match with the .cabal filename. Usually starts with a lowercase. <a href="https://hackage.haskell.org/packages/search?terms=name">Check if your package name is already taken on hackage</a>.</li>
<li><code>version</code>: Some Haskell packages use <a href="https://semver.org/">semver</a>, most use <a href="https://pvp.haskell.org/">PvP</a>.</li>
<li><code>license</code>: Most Haskell packages use <a href="https://choosealicense.com/licenses/bsd-3-clause/">BSD-3-Clause</a>. <a href="https://neilmitchell.blogspot.com/2018/08/licensing-my-haskell-packages.html">Neil Mitchell blogged about this</a>. The license we chose is because this is a book learning material.</li>
<li><code>extra-doc-files</code>: Include extra doc files here, such as <code>README</code> or <code>CHANGELOG</code>.</li>
</ul>
<p>Let's fill this with the metadata of our project:</p>
<pre><code class="language-cabal">cabal-version:       2.4

name:                hs-blog
version:             0.1.0.0
synopsis:            A custom blog generator from markup files
description:         This package provides a static blog generator
                     from a custom markup format to HTML.
                     It defines a parsing for this custom markup format
                     as well as an html pretty printer EDSL.

                     It is used as the example project in the online book
                     'Learn Haskell Blog Generator'. See the README for
                     more details.
homepage:            https://github.com/soupi/learn-haskell-blog-generator
bug-reports:         https://github.com/soupi/learn-haskell-blog-generator/issues
license:             CC0-1.0
license-file:        LICENSE.txt
author:              Gil Mizrahi
maintainer:          gilmi@posteo.net
category:            Learning, Web
extra-doc-files:
  README.md
</code></pre>
<h3 id="common-settings"><a class="header" href="#common-settings">Common settings</a></h3>
<p>Cabal package descriptions can include multiple &quot;targets&quot;: libraries, executables,
and test suites. Since Cabal 2.2, we can use
<a href="https://cabal.readthedocs.io/en/3.4/cabal-package.html?highlight=common#common-stanzas">common stanzas</a>
to group settings to be shared between different targets, so we don't have to repeat them for each target.</p>
<p>In our case we've created a new common stanza (or block) called <code>common-settings</code> and
defined the default language (Haskell has two standards, 98 and 2010),
and instructed ghc to compile with <code>-Wall</code>.</p>
<pre><code class="language-cabal">common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall
</code></pre>
<p>Later, in our targets descriptions, we can add <code>import: common-settings</code> ,
and all of these settings will be automatically added.</p>
<!--

> #### Aside: language extensions
>
> Haskell is a standardized language. However, GHC provides *extensions* to the language -
> additional features that aren't covered in the 98 or 2010 standards of Haskell.
> Features such as syntactic extensions, extensions to the type checker, and more.
> These extensions can be added by adding `{-# language <extension-name> #-}`
> to the top of a Haskell source file, or they can be set by *default* in the `.cabal file`.
> 
> As an example, we've enabled
> [NumericUnderscores](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/numeric_underscores.html),
> which allows us to add arbitrary underscores (`_`) in numeric literals for ease of reading.
> For example, instead of writing `1000000` we can write `1_000_000`. We don't actually
> need this at the moment, but it's nice to know about it.
> 
> The list of language extensions can be found in the
> [GHC manual](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts.html), but don't worry
> about it just yet, we will cover more extensions later.

-->
<h3 id="library"><a class="header" href="#library">Library</a></h3>
<p>In a <code>library</code> target, we define:</p>
<ul>
<li>The settings with which to build the library (in this case we just import <code>common-settings</code>)</li>
<li>The directory in which the source files can be found</li>
<li>The packages we require to build the library</li>
<li>The modules exposed from the library and can be used by others</li>
<li>The modules <em>not</em> exposed from the library and which <em>cannot</em> be used by others,
these could be any module you don't wish to export, such as an internal utility
functions module.
In our case we don't have anything like this, so we commented out the <code>other-modules</code>
label.</li>
</ul>
<p>Note that it is common to specify <strong>version bounds</strong> for packages.
Version bounds specify <em>with which packages version this library works with</em>.
These can also be generated using cabal with the <code>cabal gen-bounds</code> command.</p>
<pre><code class="language-cabal">library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:
</code></pre>
<p>Also note that we've added an additional <em>hierarchy</em> for our modules and defined
a different source directory. This means we will need to move the files around
a bit and change the <code>module</code> name in each file and the <code>import</code> statements. This is to avoid
conflict with other packages that a user might import.</p>
<p>Do this now!</p>
<details><summary>Solution</summary>
<ol>
<li>
<p><code>Main.hs</code> -&gt; <code>src/HsBlog.hs</code></p>
<pre><code class="language-hs">module HsBlog
  ( main
  , process
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert)
</code></pre>
</li>
<li>
<p><code>Convert.hs</code> -&gt; <code>src/HsBlog/Convert.hs</code></p>
<pre><code class="language-hs">module HsBlog.Convert where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
</code></pre>
</li>
<li>
<p><code>Html.hs</code> -&gt; <code>src/HsBlog/Html.hs</code></p>
<pre><code class="language-hs">module HsBlog.Html
...

import HsBlog.Html.Internal
</code></pre>
</li>
<li>
<p><code>Html/Internal.hs</code> -&gt; <code>src/HsBlog/Html/Internal.hs</code></p>
<pre><code class="language-hs">module HsBlog.Html.Internal where
</code></pre>
</li>
<li>
<p><code>Markup.hs</code> -&gt; <code>src/HsBlog/Markup.hs</code></p>
<pre><code class="language-hs">module HsBlog.Markup
</code></pre>
</li>
</ol>
</details>
<h3 id="executable"><a class="header" href="#executable">Executable</a></h3>
<p>We have separated our code to two sections: a library and an executable, why?</p>
<p>First, libraries can be used by others. if we publish our code and someone wants to
use it and build upon it, they can. Executables can't be imported to other projects.
Second, we can write unit tests for libraries, which we will do soon. It is usually
benefitical to write most, if not all, of our logic as a library, and provide
a thin executable over it.</p>
<p>Executables' descriptions are very similar to libraries, here we define:</p>
<ul>
<li>The name of the executable</li>
<li>Where the source directory for this application is</li>
<li>Which file is the 'Main' file</li>
<li>Import our library, which is named <code>hs-blog</code></li>
<li>Add additional flag for GHC: <code>-O</code> to compile with optimizations</li>
</ul>
<pre><code class="language-cabal">executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , hs-blog
  ghc-options:
    -O
</code></pre>
<p>We can write many executables descriptions. In this case we only need one.</p>
<p><strong>Exercise</strong>: Add a new file: <code>app/Main.hs</code> which imports <code>HsBlog</code> and runs <code>main</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">-- app/Main.hs

module Main where

import qualified HsBlog

main :: IO ()
main = HsBlog.main
</code></pre>
</details>
<h3 id="test-suites"><a class="header" href="#test-suites">Test-suites</a></h3>
<p><code>test-suite</code> defines a target for running package tests. We will get back to it
in a later chapter.</p>
<h2 id="our-complete-cabal-file"><a class="header" href="#our-complete-cabal-file">Our complete .cabal file</a></h2>
<pre><code class="language-cabal">cabal-version:       2.4

name:                hs-blog
version:             0.1.0.0
synopsis:            A custom blog generator from markup files
description:         This package provides a static blog generator
                     from a custom markup format to HTML.
                     It defines a parsing for this custom markup format
                     as well as an html pretty printer EDSL.

                     It is used as the example project in the online book
                     'Learn Haskell Blog Generator'. See the README for
                     more details.
homepage:            https://github.com/soupi/learn-haskell-blog-generator
bug-reports:         https://github.com/soupi/learn-haskell-blog-generator/issues
license:             CC0-1.0
license-file:        LICENSE.txt
author:              Gil Mizrahi
maintainer:          gilmi@posteo.net
category:            Learning, Web
extra-doc-files:
  README.md

common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall

library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:

executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , hs-blog
  ghc-options:
    -O
</code></pre>
<p>We'll also add a <code>README.md</code> file and a <code>LICENSE.txt</code> file:</p>
<details><summary>README.md</summary>
<p>Just write whatever you want here:</p>
<pre><code class="language-md"># hs-blog

One day it will be a static blog generator.

[Read the book](https://soupi.github.io/learn-haskell-blog-generator).
</code></pre>
</details>
<details><summary>LICENSE.txt</summary>
<p>This is CC0-1.0 Universal</p>
<pre><code>Creative Commons Legal Code

CC0 1.0 Universal

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN &quot;AS-IS&quot; BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
    HEREUNDER.

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator
and subsequent owner(s) (each and all, an &quot;owner&quot;) of an original work of
authorship and/or a database (each, a &quot;Work&quot;).

Certain owners wish to permanently relinquish those rights to a Work for
the purpose of contributing to a commons of creative, cultural and
scientific works (&quot;Commons&quot;) that the public can reliably and without fear
of later claims of infringement build upon, modify, incorporate in other
works, reuse and redistribute as freely as possible in any form whatsoever
and for any purposes, including without limitation commercial purposes.
These owners may contribute to the Commons to promote the ideal of a free
culture and the further production of creative, cultural and scientific
works, or to gain reputation or greater distribution for their Work in
part through the use and efforts of others.

For these and/or other purposes and motivations, and without any
expectation of additional consideration or compensation, the person
associating CC0 with a Work (the &quot;Affirmer&quot;), to the extent that he or she
is an owner of Copyright and Related Rights in the Work, voluntarily
elects to apply CC0 to the Work and publicly distribute the Work under its
terms, with knowledge of his or her Copyright and Related Rights in the
Work and the meaning and intended legal effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights (&quot;Copyright and
Related Rights&quot;). Copyright and Related Rights include, but are not
limited to, the following:

  i. the right to reproduce, adapt, distribute, perform, display,
     communicate, and translate a Work;
 ii. moral rights retained by the original author(s) and/or performer(s);
iii. publicity and privacy rights pertaining to a person's image or
     likeness depicted in a Work;
 iv. rights protecting against unfair competition in regards to a Work,
     subject to the limitations in paragraph 4(a), below;
  v. rights protecting the extraction, dissemination, use and reuse of data
     in a Work;
 vi. database rights (such as those arising under Directive 96/9/EC of the
     European Parliament and of the Council of 11 March 1996 on the legal
     protection of databases, and under any national implementation
     thereof, including any amended or successor version of such
     directive); and
vii. other similar, equivalent or corresponding rights throughout the
     world based on applicable law or treaty, and any national
     implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention
of, applicable law, Affirmer hereby overtly, fully, permanently,
irrevocably and unconditionally waives, abandons, and surrenders all of
Affirmer's Copyright and Related Rights and associated claims and causes
of action, whether now known or unknown (including existing as well as
future claims and causes of action), in the Work (i) in all territories
worldwide, (ii) for the maximum duration provided by applicable law or
treaty (including future time extensions), (iii) in any current or future
medium and for any number of copies, and (iv) for any purpose whatsoever,
including without limitation commercial, advertising or promotional
purposes (the &quot;Waiver&quot;). Affirmer makes the Waiver for the benefit of each
member of the public at large and to the detriment of Affirmer's heirs and
successors, fully intending that such Waiver shall not be subject to
revocation, rescission, cancellation, termination, or any other legal or
equitable action to disrupt the quiet enjoyment of the Work by the public
as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason
be judged legally invalid or ineffective under applicable law, then the
Waiver shall be preserved to the maximum extent permitted taking into
account Affirmer's express Statement of Purpose. In addition, to the
extent the Waiver is so judged Affirmer hereby grants to each affected
person a royalty-free, non transferable, non sublicensable, non exclusive,
irrevocable and unconditional license to exercise Affirmer's Copyright and
Related Rights in the Work (i) in all territories worldwide, (ii) for the
maximum duration provided by applicable law or treaty (including future
time extensions), (iii) in any current or future medium and for any number
of copies, and (iv) for any purpose whatsoever, including without
limitation commercial, advertising or promotional purposes (the
&quot;License&quot;). The License shall be deemed effective as of the date CC0 was
applied by Affirmer to the Work. Should any part of the License for any
reason be judged legally invalid or ineffective under applicable law, such
partial invalidity or ineffectiveness shall not invalidate the remainder
of the License, and in such case Affirmer hereby affirms that he or she
will not (i) exercise any of his or her remaining Copyright and Related
Rights in the Work or (ii) assert any associated claims and causes of
action with respect to the Work, in either case contrary to Affirmer's
express Statement of Purpose.

4. Limitations and Disclaimers.

 a. No trademark or patent rights held by Affirmer are waived, abandoned,
    surrendered, licensed or otherwise affected by this document.
 b. Affirmer offers the Work as-is and makes no representations or
    warranties of any kind concerning the Work, express, implied,
    statutory or otherwise, including without limitation warranties of
    title, merchantability, fitness for a particular purpose, non
    infringement, or the absence of latent or other defects, accuracy, or
    the present or absence of errors, whether or not discoverable, all to
    the greatest extent permissible under applicable law.
 c. Affirmer disclaims responsibility for clearing rights of other persons
    that may apply to the Work or any use thereof, including without
    limitation any person's Copyright and Related Rights in the Work.
    Further, Affirmer disclaims responsibility for obtaining any necessary
    consents, permissions or other rights required for any use of the
    Work.
 d. Affirmer understands and acknowledges that Creative Commons is not a
    party to this document and has no duty or obligation with respect to
    this CC0 or use of the Work.
</code></pre>
</details>
<h2 id="cabalproject-and-stackyaml"><a class="header" href="#cabalproject-and-stackyaml"><code>cabal.project</code> and <code>stack.yaml</code></a></h2>
<p>The <a href="https://cabal.readthedocs.io/en/3.4/cabal-project.html">cabal.project</a> and
<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#project-specific-config">stack.yaml</a>
files are used by <code>cabal</code> and <code>stack</code> respectively to add additional information on <em>how
to build the package</em>. While <code>cabal.project</code> isn't necessary to use <code>cabal</code>, <code>stack.yaml</code>
is necessary in order to use <code>stack</code>. So we will cover it briefly.</p>
<p>There are two important fields a <code>stack.yaml</code> file must have:</p>
<ul>
<li><code>resolver</code>: Describes which snapshot to use for packages and ghc version.
We will choose the latest (at time of writing) on the <code>lts</code> branch: <code>lts-18.9</code>.
Visit <a href="https://www.stackage.org/lts-18.9">this link</a> to find which packages this
snapshot includes, what are their version, and for which GHC version is set
for the snapshot.</li>
<li><code>packages</code>: Describes the location of packages we plan to build. In our case
we have only one, in the current directory.</li>
</ul>
<p>We'll add <code>stack.yaml</code> to our project directory:</p>
<pre><code class="language-yaml">resolver: lts-18.9

packages:
- .
</code></pre>
<p>For additional options and configurations, please consult the relevant user guides.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Now, instead of manually running <code>runghc Main.hs</code>, we will now use either <code>stack</code>
or <code>cabal</code> to build and run our program and package (I mostly use stack, but up to you).</p>
<h3 id="for-cabal"><a class="header" href="#for-cabal">For cabal:</a></h3>
<p>Building the project - on the first run, cabal will download the package dependencies
and use the GHC on PATH to build the project.</p>
<p>cabal caches packages between projects, so if a new project uses the same packages
with the same versions (and the same flag settings) they will not need to be reinstalled.</p>
<pre><code class="language-sh">cabal v2-build
</code></pre>
<p>Running the project: <code>stack exec</code> will run the executable.</p>
<pre><code class="language-sh">cabal v2-run hs-blog-gen -- &lt;program options&gt;
</code></pre>
<p>We can also run <code>ghci</code> with our project loaded:</p>
<pre><code class="language-sh">cabal v2-repl
</code></pre>
<h3 id="for-stack"><a class="header" href="#for-stack">For stack:</a></h3>
<p>Building the project - on the first run, stack will install the right GHC for this project
which is specified according to the <code>resolver</code> field in the <code>stack.yaml</code> file,
will download the package dependencies, and build the project.</p>
<p>Stack caches these installations between projects that use the same resolver,
so future projects with the same resolver and future runs of this project won't
require reinstallation.</p>
<pre><code class="language-sh">stack build
</code></pre>
<p>Running the project: <code>stack exec</code> will run the executable.</p>
<pre><code class="language-sh">stack exec hs-blog-gen -- &lt;program options&gt;
</code></pre>
<p>Or run <code>ghci</code>:</p>
<pre><code class="language-sh">stack ghci
</code></pre>
<h3 id="build-artifacts"><a class="header" href="#build-artifacts">Build artifacts</a></h3>
<p>Both stack and cabal create build artifacts that we will not want to track using
our version control. These build artifacts are found in the <code>dist</code>, <code>dist-newstyle</code>
and <code>.stack-work</code> directories. We can add these to a <code>.gitignore</code> file
(or similar for other version control programs) to ignore them:</p>
<pre><code class="language-txt">dist
dist-newstyle
.stack-work
</code></pre>
<h2 id="finding-packages"><a class="header" href="#finding-packages">Finding packages</a></h2>
<p>Finding packages isn't a very straightforward process at the moment.
People have written on
<a href="https://www.haskellforall.com/2018/05/how-i-evaluate-haskell-packages.html">how they choose packages</a>,
<a href="https://github.com/soupi/haskell-study-plan#useful-packages">recommendation</a> <a href="https://haskelliseasy.readthedocs.io/en/latest/">lists</a>, and more.</p>
<p>My suggestion is:</p>
<ul>
<li>Search for a tutorial on something you'd like to do, and see which packages come up</li>
<li>Use the download amount on Hackage as an indication of package popularity</li>
<li>Use <a href="https://www.stackage.org/lts">Stackage</a> package synopsises to locate a relevant package</li>
<li>Check social network channels for recommendations, but know that sometimes people tend
to recommend inappropriate solutions and packages that might be too complicated or
still experimental</li>
</ul>
<p>It's also important to note the amount of dependencies a package has. Adding many dependencies
will affect compilation time and code size. And it can sometimes be a good thing to consider
when comparing packages, or considering whether a package is needed at all.</p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>We've created a package description for our library and used <code>stack</code> or/and <code>cabal</code>
to build our program. In future chapters we'll start adding external packages,
we'll only have to add them to the <code>build-depends</code> section in the cabal file and
our package manager will download and install the required package for us!</p>
<p>We've made some change to our project directory, and it should now look like this:</p>
<pre><code>.
├── app
│   └── Main.hs
├── hs-blog.cabal
├── LICENSE.txt
├── README.md
├── src
│   ├── HsBlog
│   │   ├── Convert.hs
│   │   ├── Html
│   │   │   └── Internal.hs
│   │   ├── Html.hs
│   │   └── Markup.hs
│   └── HsBlog.hs
└── stack.yaml

4 directories, 10 files
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fancy-options-parsing"><a class="header" href="#fancy-options-parsing">Fancy options parsing</a></h1>
<p>We'd like to define a nicer interface for our program. And while we could manage something
ourselves with <code>getArgs</code> and pattern matching, using a library for this case is easier.
We are going to use a package called
<a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>.</p>
<p><code>optparse-applicative</code> provides us with an EDSL (yes, another one) to build
command arguments parser. Things like commands, switches, and flags can be built
and composed together to make a parser for command-line arguments without actually
writing operations on strings as we did when we wrote our Markup parser, and will
provide other benefits such as automatic generation of usage lines, help screens,
error reporting, and more.</p>
<p>While <code>optparse-applicative</code>'s dependency footprint isn't very large,
it is likely that a user of our library wouldn't need command-line parsing
in this particular case, so it makes sense to add this dependency on the <code>executable</code>
rather than the <code>library</code> in the cabal file:</p>
<pre><code class="language-cabal">executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , optparse-applicative
    , hs-blog
  ghc-options:
    -O
</code></pre>
<h2 id="building-a-command-line-parser"><a class="header" href="#building-a-command-line-parser">Building a command-line parser</a></h2>
<p>The optparse-applicative package has pretty decent
<a href="https://hackage.haskell.org/package/optparse-applicative-0.16.1.0#optparse-applicative">documentation</a>,
but we will cover a few important things to pay attention to in this chapter.</p>
<p>In general, there are four important things we need to do:</p>
<ol>
<li>
<p>Define our model - we want to define an ADT that describes the various options
and commands for our program.</p>
</li>
<li>
<p>Define a parser that will produce our model when run</p>
</li>
<li>
<p>Run the parser on our program arguments input</p>
</li>
<li>
<p>Pattern match on the model and call the right operations according to the options</p>
</li>
</ol>
<h3 id="define-a-model"><a class="header" href="#define-a-model">Define a model</a></h3>
<p>Let's envision our command-line interface for a second, what would we like it to
look like?</p>
<p>We want to be able to convert a single file or input stream and produce either a file
or an input stream, or we want to process a whole directory and create a new directory.
We can model it in an ADT like this:</p>
<pre><code class="language-hs">data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show
</code></pre>
<blockquote>
<p>Note that we could technically also use <code>Maybe FilePath</code> to encode both <code>SingleInput</code>
and <code>SingleOutput</code>, but then we would have to remember what <code>Nothing</code> meant
in each context. By creating a new type with properly named constructors
for each option we make it easier for readers of the code to understand
the meaning of our code.</p>
</blockquote>
<p>In terms of interface, we could decide that when a user uses our program
without arguments, they would like to read from stdin and write to stdout.
If they'd like to read from or write to a file, they can use the optional flags
<code>--input FILEPATH</code> and <code>--output FILEPATH</code> respectively.</p>
<p>If the user would like to convert a directory, they can use the <code>directory</code>
command and supply the two mandatory flags <code>--input FILEPATH</code> and
<code>--output FILEPATH</code>.</p>
<p>Feel free to change the interface as you'd like!</p>
<h3 id="build-a-parser"><a class="header" href="#build-a-parser">Build a parser</a></h3>
<p>This is the most interesting part of the process. How do we build a parser
that fit our model? What is a parser even?</p>
<p>The <code>optparse-applicative</code> library introduces a new type called <code>Parser</code>.
<code>Parser</code>, similar to <code>Maybe</code> and <code>IO</code>, has the kind <code>* -&gt; *</code> - when it
is supplied with a saturated (or concrete) type such as <code>Int</code>, <code>Bool</code> or
<code>Options</code>, it can become a saturated type (one that has values).</p>
<p>A <code>Parser a</code> represents a specification of a parser for a set of options
that will produce a value of type <code>a</code> when the command-line arguments are
successfully parsed.
This is a bit similar to how <code>IO a</code> represents a description of a program
that can produce a value of type <code>a</code>. The main difference between these
two types is that while we can't really convert an <code>IO a</code> to an <code>a</code>
(we just chain IO operations and have the Haskell runtime execute them),
we <em>can</em> convert a <code>Parser a</code> to a function that takes a list of strings
representing the program arguments and produces an <code>a</code> if it manages
to parse the arguments.</p>
<p>As we've seen with previous EDSLs, this library uses the <em>combinator pattern</em>
as well. We need consider what are the basic primitives for building
a parser, and what are the methods of composing small parsers into bigger
parsers.</p>
<p>Let's see an example for a small parser:</p>
<pre><code class="language-hs">inp :: Parser FilePath
inp =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;FILENAME&quot;
      &lt;&gt; help &quot;Input file&quot;
    )

out :: Parser FilePath
out =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;FILENAME&quot;
      &lt;&gt; help &quot;Output file&quot;
    )
</code></pre>
<p><code>strOption</code> is a parser builder. It is a function that takes <em>option
modifiers</em> as an argument, and returns a parser that will parse a string.
We can specify the type to be <code>FilePath</code> because <code>FilePath</code> is an
alias to <code>String</code>. The parser builder describes how to part the data type,
and the modifiers describe its properties, such as the flag name,
the shorthand of the flag name, and how it would be described in the usage
and help messages.</p>
<blockquote>
<p>Actually <code>strOption</code> can return any string type
that implements the interface <code>IsString</code>. There are a few such types,
such as <code>Text</code>, a much more efficient unicode text type from the <code>text</code> package.
It is more efficient than <code>String</code> because while <code>String</code> is implemented as a
linked list of <code>Char</code>, <code>Text</code> is implemented as an array of bytes.
<code>Text</code> is usually what we should use for text values. We haven't
been using it up until now because it is slightly less ergonomic to use
than <code>String</code>. But it is often the preferred type to use for text!</p>
</blockquote>
<p>As you can see, modifiers can be composed using the <code>&lt;&gt;</code> function,
which means they are an instances of <code>Semigroup</code>!</p>
<p>With such interface it means that we don't have to supply all of the modifier
options, we can just use the one that are relevant. So if we don't want to
have a shortend flag name, we don't have to add it.</p>
<h4 id="functor"><a class="header" href="#functor">Functor</a></h4>
<p>For the data type we've defined, having <code>Parser FilePath</code> takes us
a good step in the right direction, but it is not exactly what we need
for a <code>SingleConvert</code>. We need a <code>Parser SingleInput</code> and a
<code>Parser SingleOutput</code>. If we had a <code>FilePath</code>, we could convert
it into <code>SingleInput</code> by using the <code>FileInput</code> constructor.
Remember, <code>FileInput</code> is also a function:</p>
<pre><code class="language-hs">FileInput :: FilePath -&gt; SingleInput
FileOutput :: FilePath -&gt; SingleOutput
</code></pre>
<p>However, to convert a parser, we need functions with these types:</p>
<pre><code class="language-hs">f :: Parser FilePath -&gt; Parser SingleInput
g :: Parser FilePath -&gt; Parser SingleOutput
</code></pre>
<p>Fortunately, the <code>Parser</code> interface provides us with a function to &quot;lift&quot;
a function like <code>FilePath -&gt; SingleInput</code> to work on parsers, making
it a function with the type <code>Parser FilePath -&gt; Parser SingleInput</code>.
Of course, this function will work for any input and output,
so if we have a function with the type <code>a -&gt; b</code>, we can pass it to
that function and get a new function of the type <code>Parser a -&gt; Parser b</code>.</p>
<p>This function is called <code>fmap</code>:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b

-- Or with its infix version
&lt;$&gt;  :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
</code></pre>
<p>We've seen <code>fmap</code> before in the interface of other types:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]

fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>fmap</code> is a type class function like <code>&lt;&gt;</code> and <code>show</code>, it belongs
to the type class <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor"><code>Functor</code></a>:</p>
<pre><code class="language-hs">class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>And it has the following laws:</p>
<pre><code class="language-hs">-- 1. Identity law:
--    if we don't change the values, nothing should change
fmap id = id

-- 2. Composition law:
--    Composing the lifted functions is the same a composing
--    them after fmap
fmap (f . g) == fmap f . fmap g
</code></pre>
<p>Any type <code>f</code> that can implement <code>fmap</code> and follow these laws can be an
instance of functor.</p>
<blockquote>
<p>Notice how <code>f</code> has a kind <code>* -&gt; *</code>, we can infer the kind of <code>f</code>
by looking at the other types in the type signature of <code>fmap</code>:</p>
<ol>
<li><code>a</code> and <code>b</code> have the kind <code>*</code> because they are used as arguments/return
types of functions</li>
<li><code>f a</code> has the kind <code>*</code> because it is used as an argument to a function, therefore</li>
<li><code>f</code> has the kind <code>* -&gt; *</code></li>
</ol>
</blockquote>
<p>Let's choose a data type and see if we can implement a <code>Functor</code> instance.
We need to choose a data type that has the kind <code>* -&gt; *</code>. <code>Maybe</code> fits the bill.
We need to implement a function <code>fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code>.
Here's one very simple (and wrong) implementation:</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX = Nothing
</code></pre>
<p>check it yourself! It compiles and everything! But unfortunately it does
satisfy the first law. <code>fmap id = id</code> means that
<code>mapMaybe id (Just x) == Just x</code>, however from the definition we can
clearly see that <code>mapMaybe id (Just x) == Nothing</code>.</p>
<p>This is a good example of how Haskell doesn't help us make sure the laws
are satisfied, and why they are important. Unlawful <code>Functor</code> instances
will behave differently than we'd expect a <code>Functor</code> to behave.
Let's try again!</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX =
  case maybeX of
    Nothing -&gt; Nothing
    Just x -&gt; Just (func x)
</code></pre>
<p>This <code>mapMaybe</code> will satisfy the functor laws. This can be proved
by doing algebra - if we can do substitution and reach the other side of the
equation in each law, then the law holds.</p>
<p>Functor is a very important type class, and many types implement this interface.
As we know, <code>IO</code>, <code>Maybe</code>, <code>[]</code> and <code>Parser</code> all have the kind <code>* -&gt; *</code>,
and all allows us to map over their &quot;payload&quot; type.</p>
<p>Often people try to look for analogies and metaphors to what a type class mean,
but type classes with funny names like <code>Functor</code> don't usually have an
analogy or a methapor that fits them so well. It is easier to give up
on the metaphor and think about it as it is - an interface with laws.</p>
<p>We can use <code>fmap</code> on <code>Parser</code> to make a parser that returns <code>FilePath</code>
return a <code>SingleInput</code> or <code>SingleOutput</code> instead:</p>
<pre><code class="language-hs">pInputFile :: Parser SingleInput
pInputFile = fmap FileInput parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

pOutputFile :: Parser SingleOutput
pOutputFile = FileOutput &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Output file&quot;
        )
</code></pre>
<h4 id="applicative"><a class="header" href="#applicative">Applicative</a></h4>
<p>Now that we have two parsers,
<code>ppInputFile :: Parser SingleInput</code>
and <code>pOutputFile :: Parser SingleOutput</code>,
we want to <em>combine</em> them as <code>Options</code>. Again, if we only had
<code>SingleInput</code> and <code>SingleOutput</code>, we could use the constructor <code>ConvertSingle</code>:</p>
<pre><code class="language-hs">ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options
</code></pre>
<p>Can we do a similar trick to the one we saw before with <code>fmap</code>?
Does a function that can lift a binary function to work
on <code>Parser</code>s instead? One with this type signature:</p>
<pre><code>???
  :: (       SingleInput -&gt;        SingleOutput -&gt;        Options)
  -&gt; (Parser SingleInput -&gt; Parser SingleOutput -&gt; Parser Options)
</code></pre>
<p>Yes. This function is called <code>liftA2</code> and it is from the <code>Applicative</code>
type class. <code>Applicative</code> (also known as an applicative functor) has three
primary functions:</p>
<pre><code class="language-hs">class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c 
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative"><code>Applicative</code></a>
is another very popular type class with many instances.</p>
<p>Just like any <code>Monoid</code> as a <code>Semigroup</code>, any <code>Applicative</code>
is a <code>Functor</code>. This means that any type that wants to implement
the <code>Applicative</code> interface should also implement the <code>Functor</code> interface.</p>
<p>Beyond what a regular functor can do, which is to lift a function over
a certain <code>f</code>, applicative functors allow us to apply a function to
multiple instances of a certain <code>f</code>, as well as &quot;lift&quot; any value into an <code>f a</code>.</p>
<p>You should already be familiar with <code>pure</code>, we've seen it when we
talked about <code>IO</code>. For <code>IO</code>, <code>pure</code> let us create an <code>IO</code> action
that would return a specific value without doing IO.
With <code>pure</code> for <code>Parser</code>, we can create a <code>Parser</code> that when run
will return a specific value as output. </p>
<p><code>liftA2</code> and <code>&lt;*&gt;</code> are two functions that can be implemented in
terms of one another. <code>&lt;*&gt;</code> is actually the more useful between
the two, because when combined with <code>fmap</code>, it can be used
to apply a function with many arguments over many values of the
same type which is an instance of an applicative functor.</p>
<p>To combine our two parsers to one, we can use either <code>liftA2</code> or
<code>&lt;*&gt;</code> and <code>fmap</code> (or more specifically the infix version <code>&lt;$&gt;</code>):</p>
<pre><code class="language-hs">-- with liftA2
pConvertSingle :: Parser Options
pConvertSingle =
  liftA2 ConvertSingle pInputFile pOutputFile

-- with &lt;$&gt; and &lt;*&gt;
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pInputFile &lt;*&gt; pOutputFile
</code></pre>
<p>Note that both <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> associate to the left,
so we have invisible parenthesis that look like this:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile
</code></pre>
<p>Let's take a deeper look at the types of the sub-expressions
we have here, to prove that this type-checks:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options

pInputFile :: Parser SingleInput
pOutputFile :: Parser SingleOutput

ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options

&lt;$&gt; :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a` is `SingleInput -&gt; SingleOutput -&gt; Options`
  -- and `b` is `SingleOutput -&gt; Options`,

ConvertSingle &lt;$&gt; pInputFile :: Parser (SingleOutput -&gt; Options)

&lt;*&gt; :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a -&gt; b` is `SingleOutput -&gt; Options`
  -- so `a` is `SingleOutput` and `b` is `Options`

-- So we get:
(ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile :: Parser Options
</code></pre>
<p>With <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> we can chain as many parsers (or any applicative really)
as we want. This is because two things: currying and parametric polymorphism:
Because functions in Haskell take exactly one argument and return exactly one,
any multiple argument function can be represented as <code>a -&gt; b</code>.</p>
<p>You can find the laws for the applicative functors in this article called
<a href="https://wiki.haskell.org/Typeclassopedia#Laws_2">Typeclassopedia</a>, which
talks about various useful type classes and their laws.</p>
<p>Applicatives are a very important concept and will appear in various
parsers interface (not just for command-line arguments, but also json
parsers and general parsers), I/O, concurrency, non-determinism, and more.
The reason this library is called optparse-applicative is because
it uses the <code>Applicative</code> interface as the main API for
constructing parsers.</p>
<hr />
<p>Exercise: create a similar interface for the <code>ConvertDir</code> constructor of <code>Options</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir
</code></pre>
</details>
<hr />
<h4 id="alternative"><a class="header" href="#alternative">Alternative</a></h4>
<p>One thing we forgot about is that each input and output for
<code>ConvertSingle</code> could also potentially use the standard input instead.
Up until now we only offered one option: reading from or writing to a file,
but we'd like to offer the alternative standard i/o. We can do that by using
the function <code>&lt;|&gt;</code> from the <code>Alternative</code> typeclass, which <code>Parser</code> implements:</p>
<pre><code class="language-hs">class Applicative f =&gt; Alternative f where 
  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a
  empty :: f a 
</code></pre>
<p><code>Alternative</code> looks very similar to the <code>Monoid</code> typeclass,
but it works on applicative functors. This type class isn't
very common and is mostly used for parsing libraries,
but it provides us with an interface to combine two <code>Parser</code>s.
If the first one fails to parse, we try the other.</p>
<p>We can create new parsers <code>pStdin</code> and <code>pStdout</code>:</p>
<pre><code class="language-hs">pStdIn :: Parser SingleInput
pStdin =
  flag' Stdin
    ( help &quot;Standard input&quot;
    )

pStdout :: Parser SingleOutput
pStdout =
  flag' Stdout
    ( help &quot;Standard output&quot;
    )
</code></pre>
<p>Create new unifying parsers for <code>SingleInput</code> and <code>SingleOutput</code>:</p>
<pre><code class="language-hs">pSingleInput :: Parser SingleInput
pSingleInput =
  pInputFile &lt;|&gt; pStdin

pSingleOutput :: Parser SingleInput
pSingleOutput =
  pInputFile &lt;|&gt; pStdout
</code></pre>
<p>And use those for <code>pConvertSingle</code> instead:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  ConvertDir &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput
</code></pre>
<p>Our interface is still incomplete, we should still combine
<code>pConvertSingle</code> and <code>pConvertDir</code> and offer them as alternative
options for our interface.</p>
<pre><code class="language-hs">pOptions :: Parser Options
pOptions = pConvertSingle &lt;|&gt; pConvertDir
</code></pre>
<h4 id="parserinfo"><a class="header" href="#parserinfo">ParserInfo</a></h4>
<p>When we finished building a parser, we should wrap it up in a <code>ParserInfo</code>
that adds some extra information to the parser (such as a helper message,
program description, and more depending on what we'd like to add),
and make it ready to run. The optparse-applicative tutorial suggests something like this:</p>
<pre><code class="language-hs">opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )
</code></pre>
<p>Here, <code>info</code> generates a <code>ParserInfo</code> for a parser with additional information
to print, and, <code>helper</code> adds a helper output screen in case the parser fails.</p>
<h3 id="running-a-parser"><a class="header" href="#running-a-parser">Running a parser</a></h3>
<p><code>optparse-applicative</code> provides non-<code>IO</code> interface to parse arguments,
but the most convenient way to use it is to let it take care of fetching
program arguments, try to parse them, and throw errors and help messages in case
it fails. This can be done with the function <code>execParser :: ParserInfo a -&gt; IO a</code>.</p>
<p>Right after <code>main</code> start, we can run a parser and take the result using <code>&lt;-</code>.</p>
<pre><code class="language-hs">main :: IO ()
main = do
  options &lt;- execParser opts
  -- ... rest of the program
</code></pre>
<p>Let's see our program up until now in <code>app/Main.hs</code>:</p>
<pre><code class="language-hs">-- | Entry point for the hs-blog-gen program

module Main where

import Options.Applicative

main :: IO ()
main = do
  options &lt;- execParser opts
  error &quot;not implemented yet&quot;

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

-- | A single input source
data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

-- | A single output sink
data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show

------------------------------------------------
-- * Parser

opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )

-- | Parser for all options
pOptions :: Parser Options
pOptions = pConvertSingle &lt;|&gt; pConvertDir

------------------------------------------------
-- * Single source to sink conversion parser

-- | Parser for single source to sink option
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertDir &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput

-- | Parser for single input source
pSingleInput :: Parser SingleInput
pSingleInput =
  pInputFile &lt;|&gt; pStdin

-- | Parser for single output sink
pSingleOutput :: Parser SingleInput
pSingleOutput =
  pInputFile &lt;|&gt; pStdout

-- | Input file parser
pInputFile :: Parser SingleInput
pInputFile = fmap FileInput parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

-- | Output file parser
pOutputFile :: Parser SingleOutput
pOutputFile = FileOutput &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Output file&quot;
        )

-- | stdin parser
pStdIn :: Parser SingleInput
pStdin =
  flag' Stdin
    ( help &quot;Standard input&quot;
    )

-- | stdout parser
pStdout :: Parser SingleOutput
pStdout =
  flag' Stdout
    ( help &quot;Standard output&quot;
    )

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir

-- | Parser for input directory
pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

-- | Parser for output directory
pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )
</code></pre>
<h3 id="pattern-matching-on-the-command-options"><a class="header" href="#pattern-matching-on-the-command-options">Pattern matching on the command options</a></h3>
<p>After running the command-line arguments parser, we can pattern match
on our model and call the right functions. Currently, our program
does not expose this kind of API. So let's go to our <code>src/HsBlog.hs</code>
module and change the API. We can delete <code>main</code> from that file and
add two functions instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO.html#t:Handle"><code>Handle</code></a>
is an I/O abstraction over file system objects, including <code>stdin</code> and <code>stdout</code>.
Before, we used <code>writeFile</code> and <code>getContents</code> - these functions either
get a <code>FilePath</code> to open and work on, or they assume the <code>Handle</code>.
We can use the explicit versions that take a <code>Handle</code> from <code>System.IO</code> instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)
</code></pre>
<hr />
<p>For <code>convertDirectory</code>, we will need to create the output directory,
get the files in a directory,
do something <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Foldable.html#v:for_">for_</a> each file, and so on.
The API from the
<a href="https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html"><code>directory</code></a> can help us do that. Make sure to add the dependency to the cabal file
in the <code>library</code> section.</p>
<hr />
<p>In <code>app/Main.hs</code>, we will need to pattern match on the <code>Options</code> and
prepare to call the right functions from <code>HsBlog</code>:</p>
<p>Add:</p>
<pre><code class="language-hs">import System.IO
</code></pre>
<p>And:</p>
<pre><code class="language-hs">run :: Options -&gt; IO ()
run options =
  case options of
    ConvertDir input output -&gt;
      convertDirectory input output

    ConvertSingle input output -&gt; do
      (title, inputHandle) &lt;-
        case input of
          Stdin -&gt;
            (,) &quot;&quot; &lt;$&gt; stdin
          InputFile file -&gt;
            (,) file &lt;$&gt; openFile file ReadMode

      outputHandle &lt;-
        case output of
          Stdout -&gt; stdout
          OutputFile file -&gt;
            openFile file WriteMode

      convertSingle title inputHandle outputHandle
      hClose inputHandle
      hClose outputHandle
</code></pre>
<p>Let's look at our full <code>app/Main.hs</code> and <code>src/HsBlog.hs</code>:</p>
<details><summary>app/Main.hs</summary>
<pre><code class="language-hs">-- | Entry point for the hs-blog-gen program

module Main where

import Options.Applicative
import HsBlog

main :: IO ()
main = do
  options &lt;- execParser opts
  error &quot;not implemented yet&quot;

-- | Run the generator
run :: Options -&gt; IO ()
run options =
  case options of
    ConvertDir input output -&gt;
      convertDirectory input output

    ConvertSingle input output -&gt; do
      (title, inputHandle) &lt;-
        case input of
          Stdin -&gt;
            (,) &quot;&quot; &lt;$&gt; stdin
          InputFile file -&gt;
            (,) file &lt;$&gt; openFile file ReadMode

      outputHandle &lt;-
        case output of
          Stdout -&gt; stdout
          OutputFile file -&gt;
            openFile file WriteMode

      convertSingle title inputHandle outputHandle
      hClose inputHandle
      hClose outputHandle

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

-- | A single input source
data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

-- | A single output sink
data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show

------------------------------------------------
-- * Parser

opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )

-- | Parser for all options
pOptions :: Parser Options
pOptions = pConvertSingle &lt;|&gt; pConvertDir

------------------------------------------------
-- * Single source to sink conversion parser

-- | Parser for single source to sink option
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertDir &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput

-- | Parser for single input source
pSingleInput :: Parser SingleInput
pSingleInput =
  pInputFile &lt;|&gt; pStdin

-- | Parser for single output sink
pSingleOutput :: Parser SingleInput
pSingleOutput =
  pInputFile &lt;|&gt; pStdout

-- | Input file parser
pInputFile :: Parser SingleInput
pInputFile = fmap FileInput parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

-- | Output file parser
pOutputFile :: Parser SingleOutput
pOutputFile = FileOutput &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILENAME&quot;
          &lt;&gt; help &quot;Output file&quot;
        )

-- | stdin parser
pStdIn :: Parser SingleInput
pStdin =
  flag' Stdin
    ( help &quot;Standard input&quot;
    )

-- | stdout parser
pStdout :: Parser SingleOutput
pStdout =
  flag' Stdout
    ( help &quot;Standard output&quot;
    )

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir

-- | Parser for input directory
pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

-- | Parser for output directory
pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORYNAME&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )
</code></pre>
</details>
<details><summary>src/HsBlog.hs</summary>
<pre><code class="language-hs">-- HsBlog.hs
module HsBlog
  ( convertSingle
  , convertDirectory
  , process
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)
import System.IO

convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory = error &quot;Not implemented&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()

</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to go next?</a></h1>
<p>Haskell is an incredibly rich and deep programming language.
New cutting-edge techniques, concepts and features are still being discovered
and sometimes integrated into GHC. This sometimes makes it seem impossible
to catch up to.</p>
<p>This phenomena is sometimes dubbed
<a href="https://patrickmn.com/software/the-haskell-pyramid/">The Haskell pyramid</a>.
My hope is that by reading this book and following the exercises,
you readers have reached the bar of productivity, and you can now go and start
working on your own projects with Haskell. I highly encourage you to do so.
In my opinion, writing useful Haskell ptojects is the best method to solidify
what you currently know, and identify what you still need to learn.</p>
<p>However, at some point you are likely to run into new concepts, techniques,
or even just a feeling of &quot;I feel like this could be done better&quot;.
I'd like to point you in the right direction so you can find additional information
and learn new Haskell things when you need to or want to.</p>
<p>I've compiled a list of resources for learning Haskell called
<a href="https://github.com/soupi/haskell-study-plan">Haskell study plan</a>,
it should include links to very useful articles, community hubs, project suggestions,
and even cool open-source Haskell projects.
You will also find alternative explanations to thing we've covered
and even links to other Haskell tutorials, guides and books in case you need
a different view on things.</p>
<p>Don't feel pressured to learn everything Haskell
has to offer, mastering Haskell is a journey that can take a lot time,
and most of us are definitely not there yet, but we can still be very productive
with the language, build real-world projects, and even discover new techniques and concepts.</p>
<p>Remember that in a lazy language we evaluate things only when we need them,
and you can do that as well.</p>
<h2 id="thank-you"><a class="header" href="#thank-you">Thank you!</a></h2>
<p>Thank you for reading this book. I hope you enjoyed it and found Haskell interesting.</p>
<p>I would very much like to hear your feedback. If you'd like, you could leave your
feedback at this book's
<a href="https://github.com/soupi/learn-haskell-blog-generator/issues">Github issue board</a>,
or you could reach me directly on <a href="https://twitter.com/_gilmi">Twitter</a> or via email.
You can find my contact information <a href="https://gilmi.me">on my website</a>.</p>
<p>Finally, if you really liked this book, do let me know - it  means a lot.
If you really <em>really</em> like this book and would like to support future passion projects
like this book, you can throw some money at me via <a href="https://ko-fi.com/gilmi">Ko-fi</a>.</p>
<p>Good luck with your next Haskell project!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
